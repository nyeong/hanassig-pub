{"/":{"title":"하나씩","content":"\n- [[notes/notes/컴퓨터 과학]]\n\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/README":{"title":"","content":"# 하나씩\n\n- 시작 페이지: [notes.md](notes/README.md)\n- 이슈: [GitHub Issues](https://github.com/nyeong/hanassig/issues)\n- 배포: [annyeong.me](https://annyeong.me)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/blog/2022-10-08-nth-week-today":{"title":"","content":"# 오늘은 몇 주차? 업데이트\n\n[오늘은 몇 주차?](https://nyeong.github.io/nth-week-today/)는 오늘이 올해의\n몇 주차인지 알려주는 웹 사이트이다. 2018년 쯔음 유사-군생활을 시작하며\n모든 것을 주 단위로 계획하고 움직이게 되었다. 그런데 은근 오늘이 몇 주차인지\n쉽게 알려주는 서비스가 없어 만들게 되었다.\n\n![](/2022-10-08/nth-week-today.png)\n\n기능은 단순하다. 오늘 날짜와 오늘이 몇 주차인지 알려주고 끝이다. 처음엔 주차만\n넣었는데, 오늘 날짜가 보이지 않으니 얘가 맞게 알려주는 건지 불안해져서 넣었다.\n일부러 초 단위로 날짜를 업데이트하여 \"잘 작동하고 있음\"을 과시했다.\n나름 UX에 신경썼다고 볼 수 있다.\n\n은근 수요가 있었는지 한동안 구글에 \"몇주차\"만 검색해도 제일 먼저 결과가 나왔다.\n그래서 나도 즐겨찾기에 등록하지 않고 편하게 구글에 검색해서 썼던 기억이 있다.\n당시 주소가 `annyeong.me/nth-week-today`였는데, 생각 없이 도메인 설정을 바꾸며\n주소가 바뀌고, 구글 검색 설정에 반영해주지 않아 아쉽게도 검색 결과 순위에서\n내려갔다.\n\n## 몇 주차 기준이 뭔가요?\n\n[노트](/notes/side-projects/nth-weekday)에 자세히 정리하였다.\n\n간단히 요약하면 날짜와 시간을 표현하는 국제 표준 [ISO 8601]에 의하여, 목요일을\n기준으로 주차를 센다. 즉 $n$주차는 $n$번째 목요일이 포함된 주이다.\n따라서 재밌게도 1월 1일이 금요일이라면 그 날은 올해의 첫주차가 아니게 된다.\n대신 지난해의 마지막 주차가 된다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W53** |     |     |     |        | 01  | 02  | 03  |\n| **W01** | 04  | 05  | 06  | **07** | 08  | 09  | 10  |\n\n영어권에서는 week number 혹은 ISO week date로 부르고, **W**를 붙여 표기하는 듯\n하다. 예컨데 22년도 4주차면 2022W4와 같이 쓴다. 관련 [위키]에 내용이 잘\n정리되어 있다.\n\n[위키]: https://en.wikipedia.org/wiki/ISO_week_date\n[ISO 8601]: https://ko.wikipedia.org/wiki/ISO_8601\n\n## 이슈 처리하기\n\n사실 이 [저장소]는 2018년에 저장소 팔 때 이후로는 들어간 적이 없다. 오랜만에\n우연히 접속하니 [누군가 맞춤법을 고쳐주었다][pr-01]. 오랫동안 사이트의 이름이\n**오늘은 몇주차**였는데, **몇 주차**로 띄어쓰기가 맞다는 지적이었다.\n\n인생 처음으로 받은 풀 리퀘스트인데 거진 1년이 지나서야 발견하고 부랴부랴 \n머지하였다.\n\n[pr-01]: https://github.com/nyeong/nth-week-today/pull/1\n[저장소]: https://github.com/nyeong/nth-week-today\n\n[또 다른 이슈][pr-02]는 다른 저장소에 올라왔다. 종종 잘 쓰고 있었는데, 링크가\n깨졌다는 이슈였다. 이슈를 열어주신 분은 이 오류 때문에 GitHub 계정까지 새로\n만드신 것 같았다.\n\n[pr-02]: https://github.com/nyeong/hanassig/issues/15\n\n상기했다시피 본래 `annyeong.me/nth-week-today`로 접속 가능했으나 GitHub Pages에\n연결된 도메인을 바꾸며 `nyeong.github.io/nth-week-today`로 접속해야해서 생긴\n문제였다.\n\n여러가지 방법이 있겠으나, 이 블로그에 리다이렉션을 추가하는 것이 가장 빠를\n것으로 판단하고 바로 작업하였다.\n\n오랜만에 업데이트를 위하여 저장소에 접속해보니 메인 브랜치가 `master`이다.\n메인 브랜치부터 `main`으로 다시 이름지었다.\n\n![](/2022-10-08/rename-branch.png)\n\nGitHub 브랜치 설정에서 원격 저장소의 브랜치 이름을 바꾸고, 로컬에서는 아래의\n명령어로 원격 저장소를 다시 설정해준다.\n\n```bash\n# master를 main으로 바꾸기\ngit branch -m master main\n# origin(github 리모트 저장소)의 변경사항 받아오기\ngit fetch origin\n# origin/main과 main을 연결하기\ngit branch -u origin/main main\n# HEAD 설정하기\ngit remote set-head origin -a\n```\n\n지금 이 블로그는 [도큐사우르스](https://docusaurus.io/) 프레임워크로 만들었는데\n`src/pages` 밑에 `.md`, `.tsx` 따위를 만들면 파일 이름으로 바로 접속할 수 있는\n페이지를 손쉽게 만들 수 있다. 이 경우는 `annyeong.me/nth-week-today`로의\n접속을 다뤄야 하므로 `nth-week-today.tsx`를 만들어준다.\n\n```diff\nsrc/\n├── components/\n├── css/\n└── pages/\n   ├── index.md\n+  └── nth-week-today.tsx\n```\n\n각 페이지는 리엑트로 렌더한다. 리엑트는 잘 모르지만, `componentDidMount`와\n비슷한 역할을 [useEffect](https://reactjs.org/docs/hooks-effect.html)로\n할 수 있다고 한다. 혹시 `window.location.href`를 변경하는 것으로 리다이렉션이\n안 될 경우를 대비하여 사용자가 클릭할 수 있는 링크도 넣는다:\n\n```tsx title=\"src/pages/nth-week-today.tsx\"\nimport React, { useEffect } from 'react'\nconst siteUrl = \"https://nyeong.github.io/nth-week-today/\"\n\nexport default () =\u003e {\n  useEffect(() =\u003e {\n    window.location.href = siteUrl;\n  });\n\n  return (\n    \u003cLayout\u003e\n      \u003cLink to={siteUrl}\u003e오늘은 몇 주차?\u003c/Link\u003e 사이트로 이동합니다.\n    \u003c/Layout\u003e\n  )\n}  \n```\n\n수동으로 테스트해보니 잘 작동하여 커밋-푸쉬하였다. \n\n## 오픈 그래프로 결과 미리 알려주기\n\n여기까지 해보니 조금 욕심이 생겼다. 웹 사이트를 소셜 미디어로 공유하면 작게\n미리보기를 띄워주는데, 여기서 몇 주차인지 결과를 미리 알 수 있으면 좋겠다는\n생각이 들었다.\n\n![카카오톡으로 \"오늘은 몇 주차\"를 공유할 경우의 화면. 오늘은 몇 주차? 오늘은 올해의 몇 번째 주인가?](/2022-10-08/og-old-example.jpeg)\n\n현재 띄워주는 미리보기는 사이트의 제목과 간단한 설명만 나온다.\n[오픈 그래프 프로토콜](https://ogp.me/)을 이용하여 간단하게 제목과 설명을\n넣었다. 여기서 몇 주차인지 알 수 있다면 링크를 누르지 않아도 알 수 있으니\n편리할 것이다.\n\n기존의 관련 코드는 아래와 같다:\n\n```html title=\"index.html\"\n\u003cmeta property=\"og:title\" content=\"오늘은 몇 주차?\"\u003e\n\u003cmeta property=\"og:description\" content=\"오늘은 올해의 몇 번째 주인가요?\"\u003e\n```\n\n임베디드 템플릿 엔진을 쓰면 저 내용을 편리하게 바꿀 수 있다. 엘릭서 공부 겸\n엘릭서를 활용할 예정이기에 [EEx](https://hexdocs.pm/eex/1.14/EEx.html) 문법에\n맞게 고쳐준다.\n\n```html title=\"index.html.eex\"\n\u003cmeta property=\"og:title\" content=\"\u003c%= @og_title %\u003e\"\u003e\n\u003cmeta property=\"og:description\" content=\"\u003c%= @og_description %\u003e\"\u003e\n\u003cmeta property=\"og:type\" content=\"\u003c%= @og_type %\u003e\"\u003e\n\u003cmeta property=\"og:url\" content=\"\u003c%= @og_url %\u003e\"\u003e\n\u003cmeta property=\"og:image\" content=\"\u003c%= @og_image %\u003e\"\u003e\n```\n\n이제 엘릭서 코드를 이용하여 `\u003c%= @variable %\u003e` 영역을 다른 문자열로 손쉽게\n대치할 수 있다.\n\n```elixir\nsource = \"src/index.html.eex\"\nhtml = EEx.eval_file(source, assigns: [\n  og_title: \"오늘은 몇 주차?\",\n  og_type: \"website\",\n  og_url: baseurl,\n  og_description: \"오늘은 올해의 #{week_number}번째 주입니다!\",\n  og_image: image\n])\nFile.write(dest, html)\n```\n\n주차가 바뀔 때마다 엘릭서 코드를 실행하기만 하면 된다. GitHub Action을 이용하면\nGitHub에서 이 작업을 대신 해준다.\n\n```yml title=\".github/workflows/build.yml\"\n# 많이 생략함\nname: Build Pages\n\non:\n  schedule:\n  - cron: 0 0 * * 0 # 매주 일요일 0시 0분마다 실행\n\njobs:\n  build:\n    name: build\n    runs-on: ubuntu-latest\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n\n    - uses: actions/checkout@v3\n    - name: Set up Elixir # for generate open graphs\n    - name: build\n      run: elixir bin/build.exs\n    - name: Setup Pages\n      uses: actions/configure-pages@v2\n    - name: Upload artifact\n      uses: actions/upload-pages-artifact@v1\n      with:\n        path: 'dest'\n    - name: Deploy to GitHub Pages\n      id: deployment\n      uses: actions/deploy-pages@v1  \n```\n\n퍼블리싱해도 바로 카카오톡에서 결과가 반영되지는 않는데, 아래의 주소에서 기존의\n썸네일 캐싱을 지워주어야 한다.\n\nhttps://developers.kakao.com/tool/debugger/sharing\n\n![](/2022-10-08/new-og-example.jpeg)\n\n[Iframely](http://debug.iframely.com/) 사이트에서 다른 사이트에서 어떻게\n파싱되는지 볼 수도 있다.\n\n## 기타\n\n생각나는 대로 빠르게 구현해서 몇 가지 문제가 예상된다.\n\n먼저 소셜 미디어 서비스에서 페이지를 캐싱할 경우, 실제의 주수(*week number*)와\n다른 주수가 미리보기 될 수 있다.\n\n별 다른 계산 없이 갱신 시기를 잡아, 실제 시간과 표기되는 주수가 일치하지 않을\n수 있다.\n\n엘릭서로 구현하였는데, 바뀌는 내용은 실질적으로 숫자 뿐이 없으니 의존성 없이 \n셸 스크립트로 작성하는 것이 더 좋을 법하다.\n\n이 문제들은 실제로 문제가 생기면 해결하기로 하자","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/DIY/README":{"title":"","content":"# DIY\n\n직접 만들며 쓰는 것들\n\n- [UiBox](UiBox) - 홈랩\n- [UiRouter](UiRouter) - 홈랩을 위한 라우터\n- [crkbd](crkbd) - 키보드","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/DIY/crkbd/README":{"title":"","content":"# Corne Keyboard\n\n![corne keyboard 사진](crkbd.jpeg)\n\n[footsan/crkbd](https://github.com/foostan/crkbd)\n\n3x6 사이즈 + 3 엄지 세로 스테거 스플릿 키보드\n\n- 키캡: 까먹었다\n- 스위치: 게이트론 저소음 갈축\n  - 나중에 그냥 갈축으로 바꿔야지\n- MCU: ELITE-C, nice!nano\n- 케이스: 3D printed\n- 펌웨어: QMK, ZMK\n- 보드: crkbd cherry v2, crkbd choco v3\n- 배열: [[notes/miryoku]] flip inverted T 변형\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/DIY/crkbd/miryoku":{"title":"","content":"# miryoku\n\n[manna-harbour/miryoku](https://github.com/manna-harbour/miryoku)\n\n36개의 키만으로 구현 가능한 키배열. home-row mod와 엄지키를 이용한 레이아웃 활용이 특징이다.\n\n[[notes/crkbd]]에 miryoku flip inverted T 배열을 변형하여 쿼티 기반으로 [사용 중](https://github.com/nyeong/zmk-config/commit/50526193a33168c58b006f9b6b8ef15e95ee08b3) (2022-03-31)\n\n\n## 레이아웃\n\n### home-row mods\n\n컨트롤, 알트, GUI 등 모드 키를 손이 기본 위치하는 2열(A, S, D, F, J, K, L, ;)에 두자는 생각이다.\n\n짧게 누를 경우 원래 키(A, S 등...)가 입력되고, 길게 누를 경우 설정한 모드키가 동작한다.\n\n길게 누르는 시간을 0.15초 정도로 설정해주면 굳이 의식하지 않아도 누르고 조합할 키를 누르면 모드키로 동작한다.\n\n```\n그냥 누르면:\n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  | \n길게 누르면:\n|  _  | CTL | OPT | CMD | SHF |  _  |        |  _  | SHF | CMD | OPT | CTL |  _  | \n```\n\n예를 들어 복사를 위해 `\u003ccmd\u003e-c`를 누르려면 그냥 `k`를 꾹 누른 채로 `c`를 누르면 된다.\n`kc`를 입력하려면 평범하게 `k`를 누르고 `c`를 누르면 된다.\n\nhome-row mods로 할당한 키는 원래키를 길게 눌러도 연속입력이 안 되는게 단점이다.\n\n### 레이아웃\n\nhome-row mods와 마찬가지로, 아래의 키는 짧게 누르면 원래의 키로 입력되고, 길게 누르면 모드가 바뀐다.\n\n- `ESC` -\u003e function 레이아웃\n- `SPC` -\u003e 숫자 레이아웃\n- `TAB` -\u003e 기호 레이아웃\n- `ENT` -\u003e 마우스 레이아웃\n- `BSP` -\u003e 방향키 레이아웃\n- `DEL` -\u003e 시스템 레이아웃\n\n```\n그냥 누르면:\n| ESC  | SPC  | TAB  |        |  ENT   |  BSP   |  DEL   |\n길게 누르면:\n| 펑션 | 숫자 | 기호 |        | 마우스 | 방향키 | 시스템 |\n```\n\n\n### 일반 레이아웃\n\nhome row mods가 적용되어 있어서 A, S, D, F, J, K, L, ;은 위에 기술된 대로 MODS키로 동작한다.\n\n```\n|  _  |  Q  |  W  |  E  |  R  |  T  |        |  Y  |  U  |  I  |  O  |  P  |  _  | \n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  | \n|  _  |  Z  |  X  |  C  |  V  |  B  |        |  N  |  M  |  ,  |  .  |  /  |  _  | \n                  | ESC | SPC | TAB |        | ENT | BSP | DEL |            \n```\n\n### 펑션 레이아웃\n\n```\n|  _  |     |     |     |     |     |        |     | F7  | F8  | F9  | F12 |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  =  | F4  | F5  | F6  | F11 |  _  | \n|  _  |     |     |     |     |     |        |  +  | F1  | F2  | F3  | F10 |  _  | \n                  | *** | SPC | TAB |        | ENT | BSP | DEL |            \n```\n\n### 숫자 레이아웃\n\n우측 키보드를 키패드처럼 쓸 수 있다. 따옴표(\", ', `)는 모두 오른쪽 새끼손가락으로 입력할 수 있다.\n\n```\n|  _  |     |     |     |     |     |        |     |  7  |  8  |  9  |  \"  |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  =  |  4  |  5  |  6  |  '  |  _  | \n|  _  |     |     |     |     |     |        |  +  |  1  |  2  |  3  |  `  |  _  | \n                  |     | *** |     |        |  -  |  0  |  .  |            \n```\n\n### 기호 레이아웃\n\n```\n|  _  |     |     |     |     |     |        |  (  |  \u0026  |  *  |  ~  |  )  |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  {  |  $  |  %  |  ^  |  }  |  _  | \n|  _  |     |     |     |     |     |        |  [  |  !  |  @  |  #  |  ]  |  _  | \n                  |     |     | *** |        |  _  |  |  |  \\  |            \n```\n\n### 마우스 레이아웃\n\nZMK 펌웨어에서는 아직 마우스 키를 지원하지 않기 때문에 이 부분은 비워두었다.\n\n### 네비게이션 레이아웃\n\n방향키, HOME, END, PG UP, PG DN 등 네비게이션과 관련된 버튼을 모아둔 레이아웃\n\n```\n|  _  |     |HOME |  ↑  | END |PG UP|        |     |     |     |     |     |  _  | \n|  _  |     |  ←  |  ↓  |  →  |PG DN|        |     | SHF | CMD | OPT | CTL |  _  | \n|  _  |     |     |     |     |     |        |     |     |     |     |     |  _  | \n                  | ESC | SPC | TAB |        |     | *** |     |            \n```\n\n### 시스템 레이아웃\n\n블루투스, 화면 밝기, 미디어 재생, 볼륨 조절 등 버튼을 모아놓은 레이아웃\n\n```\n|  _  |BR UP|REWND|PAUSE|FA FO|VL UP|        |     |     |     |     |     |  _  | \n|  _  |BR DN|PREV |PLAY |NEXT |VL DN|        |     | SHF | CMD | OPT | CTL |  _  | \n|  _  |BR AT|BTCLR|BTOFF|BT ON|MUTE |        |     |     |     |     |     |  _  | \n                  | BT0 | BT1 | BT2 |        |     |     | *** |            \n```\n\n## 개선 여지\n\n- home row mod로 할당된 키들은 꾹 눌러서 입력이 불가능하다\n  - 양손 검지로 누르는 안쪽열 키(`g`, `k`)를 누르고 있으면 home row mod가 풀리도록?\n- 한 손으로 할 수 있는 것들이 적다.\n- 매크로 등 편의기능\n  - 여는 괄호(`(`, `{`, `[`) 입력시 닫는 괄호와 왼쪽 방향키를 입력하여 바로 괄호 속에서 입력 가능하도록\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/DIY/uibox/README":{"title":"","content":"# UiBox\n\n![UiBox 사진](uibox.jpeg)\n\n작고 조용한 SFF 서버 제작\n\n## 구성\n\n- UiBox: 서버\n- UiRouter: 라우터\n\n## 목표\n\n- [ ] 비밀번호 관리 (vaultwarden)\n- [ ] NAS\n  - [x] samba\n  - [ ] Nextcloud\n- [ ] HomeAssistant\n- [ ] 개발 서버\n  - [ ] CI 서버 (Jenkins? GitHub Actions?)\n  - [ ] 원격으로 접속하여 쓸 수 있는 개발환경\n- [ ] 웹 서버\n- [ ] 윈도우 (게임 및 금융용)\n\n### 비밀번호 관리\n\n[bitwarden](https://bitwarden.com/)\n\n오픈소스 비밀번호 관리 도구. 개인 사용자용으로 기본 기능은 무료이고, 유료로 추가 기능을 사용하거나 상업용으로 사용할 수 있다. 서버를 직접 호스팅하여 쓸 수도 있다. 서버에 설치하여 내 비밀번호를 내 서버에 저장해보자.\n\n- [danci-garcia/vaultwarden](https://github.com/dani-garcia/vaultwarden)\n\n### NAS 서버\n\n대학 공부 자료, PDF, 전자책 뿐 아니라 친구, 가족과 찍은 사진도 저장한다.\n\nTrueNAS나 OMV 같은 나스용 OS가 필요한지는... 고민해보자.\n\n- nextcloud\n\n### IoT 관리\n\n[Home Assistant](https://www.home-assistant.io/installation/)\n\nIoT 관리를 위한 경량 서버를 설치하여 집의 스마트 전구를 관리하자.\n\n### 개발 서버\n\ngit, CI를 물려두고 푸쉬 훅을 돌리거나, x86 리눅스가 필요할 때 요긴하게 사용하자.\n\n예로, 키보드를 만들때 QMK 개발환경을 M1 macOS에 구축하는게 번거로운데, 서버에서 작업하고 펌웨어를 내려받으면 된다.\n\n### 웹 서버, 메일 서버\n\n할 필요는 없지만 할 수 있는데 안 할 이유도 없다!\n\n### 윈도우\n\n가끔 금융 등 환경에서 필요한 경우가 있는데, VM으로 해결 가능한지 도전\n\nGPU passthrough하여 간단한 스팀 게임 집에서 돌리기.\n\n## 구성\n\n### 하드웨어\n\n- CPU: Intel Celeron J4105 (4) @ 2.5GHz\n- GPU: Intel GeminiLake [UHD Graphics 600]\n- RAM: 8GB\n- MBD: ODROID-H2\n- Storage:\n\t- OS Storage:  SAMSUNG PM981 M.2 NVMe SSD 256GB\n\t- Data Storage: HDD\n\n### 소프트웨어 레이어\n\n- Proxmox VE\n  - Windoes VM\n  - HomeAssistant VM\n  - NAS VM: Nextcloud, vaultwarden\n  - DevServer CT\n  - WebServer CT\n\n## 참고\n\n- [Proxmox VE Wiki](https://pve.proxmox.com/wiki/Main_Page)\n- [The Perfect Home Server Build! 18TB, 10Gbit LAN, Quiet \u0026 Compact](https://www.youtube.com/watch?v=qACTvCW_yDc)\n- [awesome-selfhosted](https://github.com/awesome-selfhosted/awesome-selfhosted)\n- [홈 서버 만들기 -- Varins](https://varins.com/library/server/)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/DIY/uirouter":{"title":"","content":"# UiRouter\n\nipTIME AX2004M + OpenWrt\n\nOpenWrt를 활용하여 집 공유기를 보다 다목적으로 사용해보자.\n\n## OpenWrt\n\n[OpenWrt](https://openwrt.org/)는 임베디드 기기를 위한 리눅스이다. 주로 라우터에 사용된다.\n온전한 리눅스 배포판이므로 일반 공유기에 OpenWrt를 설치하여 라즈베리 파이처럼 임베디드 컴퓨터로서 다룰 수 있다.\n\n## 활용\n\n1. VPN 서버 - [[notes/install-wireguard]]\n2. 웹 프록시 서버\n3. 홈 네트워크용 DNS 서버\n\n그 외 아래의 용도로도 활용할 수 있다고 하나 내 목표가 아닌 것들:\n\n1. 외장 드라이브를 연결하여 NAS처럼 활용하기\n2. 토렌트 클라이언트를 설치하여 다운로드 서버로 활용하기\n3. 네트워크 프린터 만들기\n4. QoS\n\n## 참고\n\n- [OpenWrt](https://openwrt.org/)\n- [ipTIME AX2004M용 OpenWrt](https://kasugano.tistory.com/m/157)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/README":{"title":"","content":"# 하나씩\n\n배운 것들을 하나씩 정리합니다.\n\n## 💻 컴퓨터 관련 정보\n\n- [컴퓨터 과학](computer-science)\n- [프로그래밍 언어](programming-languages)\n- [웹 백엔드](web-backend)\n- [개발환경](dev-env) - 내 개발 환경 및 개발 도구 사용법\n\n## 취미\n\n- [DIY](diy)\n- [사이드 프로젝트](side-projects)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/README":{"title":"","content":"# 컴퓨터 과학\n\n\u003e 컴퓨터 과학에서의 컴퓨터란 천문학에서의 망원경 그 이상의 것이 아니다.\n\u003e\n\u003e -- **에츠허르 데이크스트라**\n\n- [카테고리 이론](category-theory/README.md)\n- [자료구조](data-structures/README.md)\n- [알고리즘](algorithms)\n- 운영체제\n- 데이터베이스\n- 머신러닝\n\n## 참고\n\n- [GitHub: EbookFoundation/free-programming-books]\n\n[GitHub: EbookFoundation/free-programming-books]: https://github.com/EbookFoundation/free-programming-books\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/algorithms/README":{"title":"","content":"# 알고리즘\n\n- 정렬 알고리즘: quicksort, 병합정렬, 힙정렬\n- 그래프 탐색 알고리즘: DFS, BFS, Prim, 다익스트라\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/category-theory/README":{"title":"","content":"# 카테고리 이론\n\n**Category Theory for Programmers**를 읽고 정리합니다.\n\n- [합성과 프로그래밍](composition-and-programming)\n- [타입은 집합이다](types-are-sets)\n\n## 참고자료\n\n- [Category Theory for Programmers -- Bartosz Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)\n- [hmemcpy/milewski-ctfp-pdf](https://github.com/hmemcpy/milewski-ctfp-pdf)\n- [Category Theory in Life - Eugenia Cheng](https://www.youtube.com/watch?v=ho7oagHeqNc)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/category-theory/composition-and-programming":{"title":"","content":"# 합성과 프로그래밍\n\n## 카테고리\n\n```\n+----------+  f  +----------+  g  +----------+\n| object a |----\u003e| object b |----\u003e| object c |\n+----------+     +----------+     +----------+\n     |               g∘f               ^\n     +---------------------------------+\n```\n\n카테고리는 대상(*object*)와 사상(*morphism*)의 모음이다.\n위 그림에서 네모는 대상, 화살표는 사상이다.\n위의 사상 $f$는 아래와 같이 표기한다. 대상 $a$에서 대상 $b$로 가는 사상이라는\n뜻이다.\n\n$$\nf: a \\rarr b\n$$\n\n위의 그림에서 사상 $f$와 $g$를 순서대로 따라가면 대상 $a$에서 대상 $c$로 도달할\n수 있다. 이를 합성(*composition*)이라고 하며 $g \\circ f$라고 쓴다. \n\n- 합성은 결합법칙(*associativitiy*)이 성립한다. 무엇을 먼저 합성하든 결과가 같아야한다.\n  $a \\xrightarrow f b \\xrightarrow g c \\xrightarrow h d$에 대하여 아래가\n  만족한다:\n  $$\n  h \\circ (g \\circ f) = (h \\circ g) \\circ f\n  $$\n\n- 모든 대상에 대해 항등 사상(*identity morphism*)이 존재한다. 항등 사상은\n  $id_a: a \\rarr a$와 같은 꼴이며 따라서 모든 사상 $f$에 대해 아래가 성립한다:\n  $$\n  id_b \\circ f = f \\circ id_a = f\n  $$\n\n위의 조건을 만족하기만 하면 무엇이든 대상과 사상, 즉 카테고리로 볼 수 있다. \n\n## 카테고리로서의 프로그래밍 언어\n\n프로그래밍 언어에서는 타입을 대상으로, 함수를 사상으로 볼 수 있다.\n아래의 하스켈, 엘릭서 코드의 함수 `f`를 위의 사상 $f$로 볼 수 있다.\n\n```haskell\nf :: a -\u003e b\n```\n\n```elixir\n@spec f(a) :: b\n````\n\n프로그래밍 언어를 카테고리로 보려면 합성이 가능해야하고, 합성에 대해 결합법칙과\n항등사상이 존재해야한다.\n\n먼저 합성이다. 이미 존재하는 $f$, $g$를 합성하여 새로운 함수를 만들고 이름을\n붙일 수 있다.\n\n```rust\nfn f(obj: A) -\u003e B;\nfn g(obj: B) -\u003e C;\nfn g_after_f(obj: A) -\u003e C {\n  g(f(obj))\n}\n```\n\n하스켈 같은 일부 언어는 언어 자체에서 함수의 합성을 지원한다. 아래의 두 줄은\n동일하다:\n\n```haskell\ng . f object\ng(f(object))\n```\n\n실제로 동작할 때에는 가장 오른쪽의 `f`부터 연산을 시작하기 때문에 시각적으로\n헷갈릴 수 있다. 이에 엘릭서 같은 일부 언어는 아래와 같은 함수의 합성을 지원한다.\n보통은 `pipe operator` 라는 이름으로 지원한다.\n\n```elixir\nf(object) |\u003e g()\n```\n\n프로그램의 합성을 상상해도 좋다. git 디렉토리에서 커밋 목록을 출력하는 프로그램\n`git log`와 문자열에서 줄 수를 세는 프로그램 `wc -l`을 합성하여 커밋의 수를\n출력하는 프로그램으로 바꿀 수 있다:\n\n```bash\ngit log --oneline | wc -l\n```\n\n프로그램의 함수의 합성도 결합법칙을 만족한다. 합성을 할 때에 무얼 먼저 합성하든\n결과는 동일하다:\n\n```haskell\nf :: a -\u003e b\ng :: b -\u003e c\nh :: c -\u003e d\n-- f, g, h에 대하여 아래의 두 합성은 동일하다.\nh . (g . f)\n(h . g) . f\n```\n\n```elixir\n@spec f(a) :: b\n@spec g(b) :: c\n@spec h(c) :: d\n\n# f, g, h에 대하여 아래의 두 합성은 동일하다.\n(f(a) |\u003e g()) |\u003e h()\nf(a) |\u003e (g() |\u003e h())\n```\n\n모든 대상에 대한 항등사상도 쉽게 만들 수 있다. 동적 언어의 경우 받은 값을 그대로\n돌려주기만 하면 된다.[^1]\n\n[^1]: https://hexdocs.pm/elixir/main/Function.html#identity/1\n\n```elixir\n@spec identity(value) :: value when value: var\ndef identity(value), do: value\n```\n\n제네릭을 지원하는 언어는 이를 이용하여 만들 수 있다[^2]:\n\n[^2]: https://doc.rust-lang.org/std/convert/fn.identity.html\n\n```rust\npub const fn identity\u003cT\u003e(x: T) -\u003e T {\n  x\n}\n```\n\n당연히 하스켈에서도 쉽게 정의할 수 있다. [^3]\n\n[^3]: https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:id\n\n```\nid :: a -\u003e a\nid x = x\n\nf . id == f\n```\n\n\n## 합성과 프로그램\n\n카테고리는 간단한 규칙으로 정의되며, 프로그래밍 언어는 이 규칙을 만족한다.\n따라서 프로그램 역시 카테고리이며 카테고리 이론의 도구들로 분석할 수 있다.\n\n프로그램은 분해와 조합으로 만들어진다. 프로그램은 어떤 문제를 해결하기 위해\n존재하고, 프로그래머는 이를 쪼개어 작은 문제로 바꾼다. 문제가 충분히 작아졌다면\n이를 해결하고 합성하여 다시 큰 프로그램을 만들어낸다.\n\n좋은 코드는 구현부보다 결합부가 느리게 늘어난다. 구현부는 구현하고 나면\n그 디테일은 잊어도 된다. 다른 것들과 어떻게 상호작용하는 지만 알면 된다.\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/category-theory/types-are-sets":{"title":"","content":"# 타입은 집합이다\n\n타입을 집합으로 생각해보자.\n\n정수 타입 `i32`를 생각해보자. 보통 이 타입은 구간 $[-2^{31},2^{31} - 1]$에 속한\n정수를 표현할 수 있다. 구간 내의 정수를 원소로, 타입 `i32`를 집합으로 볼 수\n있다.\n\n$$\n\\text{i32} = \\{x\\mid -2^{31}, \\cdots, -1, 0, 1, \\cdots, 2^{31} - 1\\}\n$$\n\n`i32`를 인자로 취하는 함수를 생각해보자. 아래의 함수 `i32`는 수를 제곱해준다.\n따라서 반환 타입도 `i32`이다.\n\n```rust\nfn square(n: i32) -\u003e i32 { n * n }\n```\n\n이를 집합으로 생각해보자. 함수 $\\operatorname{square}$는 $\\text{i32}$를 취하여\n$\\text{i32}$를 반환하는 함수이다.\n\n$$\n\\operatorname{square}: \\text{i32} \\rarr \\text{i32}\n$$\n\n타입을 집합으로 생각하면 아래처럼 볼 수 있다:\n\n- 값은 원소이다.\n- 타입은 가능한 값들의 집합이다.\n- 함수는... 함수이다. 집합의 함수가 그러하듯 어떤 타입을 다른 타입과 이어준다.\n\n## 사실 집합은 아니다\n\n그러나 프로그래밍 언어는 컴퓨터에 내리는 명령이고, 정의만으로 끝나는 것이 아니라\n실제로 수행하는 작업의 나열이다. 어떤 때에는 작업이 끝나지 않을 수도 있다.\n그리고 작업이 끝나지 않는 것을 미리 알 수 있는 방법은 없다.[^1]\n\n[^1]: https://en.wikipedia.org/wiki/Halting_problem\n\n```rust\nfn some_function(arg: bool) -\u003e bool;\n// 이 함수가 정상적으로 `bool`을 반환하지 않을 수도 있다.\n```\n\n위의 함수가 정상적으로 `bool`을 반환한다는 것은 보장할 수 없다.\n무한 루프에 빠질 수도 있고, 무한 재귀에 빠질 수도 있고, 예외가 발생할 수도\n있고, 에러가 날 수도 있고, 프로그램이 강제 종료 될 수도 있다.\n아니면 결과가 나오기 전에 컴퓨터가 폭발하여 사라질 수도 있다.\n\n\n따라서 끝나지 않는 작업(*non-terminating computation*)을 표현하기 위하여\n*bottom*이라는 값이 도입되었다. $\\bot$으로 표기한다.\n모든 타입은 `⊥`을 값으로 갖는다. 특정 타입을 반환할 때만 안전하리라는 보장이\n없기 때문이다. 따라서 `bool` 타입은 `true`, `false`, `⊥`을 값으로 취한다.\n\n`⊥`도 `bool` 타입이기 때문에 아래의 코드는 정상적으로 컴파일된다.\n그리고 의도대로 `true`도 `false`도 아닌 `⊥`을 반환할 것이다.\n\n```rust\nfn some_function(_arg: bool) -\u003e bool {\n    panic!()\n}\n```\n\n`⊥`의 존재로 프로그래밍 언어의 타입은 엄밀히 말하여 집합은 아니다. 그러나\n`⊥`만 제외한다면 집합과 유사하기 때문에 집합으로 생각하여도 괜찮다.\n\n## 타입은 집합이다\n\n타입을 집합이라고 생각해도 괜찮다. 타입을 집합으로 생각하면 프로그램을 분석하기\n쉬워진다.\n\n프로그램이 옳은지 분석하고 검증하는 것은 어려운 일이다. 프로그램을 함수의\n결합(*composition*)으로 생각하고, 유효한 결합인지 검증하는 것은 훨씬 쉽다.\n또한 프로그래밍 언어는 각 언어 설계자의 취향과 의도에 따라 서로 다른 용어를\n사용하는데, 이를 집합으로 봄으로써 동일한 언어와 용어로 분석할 수 있다.\n\n### 공집합\n\n공집합(*empty set*)은 아무런 원소가 없는 집합이다. $\\varnothing$ 혹은 $\\{\\}$로\n표기한다. 공집합에 대응하는 타입을 상상해보자.\n\n```rust\nenum EmptySet {}\nlet some_value: EmptySet = ???;\n```\n\n`EmptySet`이라는 타입은 존재하지만 그 타입에 속하는 값이 존재하지 않는다.\n`EmptySet`을 인자로 취하는 함수를 상상해보자.\n\n```rust\nfn absurd(arg: EmptySet) -\u003e T;\n```\n\n위 함수를 호출할 수 있을까? `EmptySet`을 인자로 취하기 때문에 값을 넘겨주어야\n하지만 `EmptySet` 타입인 값은 존재하지 않는다. 따라서 위의 함수는 호출할 수 없다.\n\n```rust\nabsurd(???); // 인자로 넘겨줄 값이 존재하지 않다.\n```\n\n`EmptySet`을 반환하는 함수는 만들 수 있을까? 얼핏보아서는 불가능할 것 같다.\n반환하면 `EmptySet`의 원소를 메모리에 표현해야하는데, 존재하지 않는 것을 메모리에\n표현할 수는 없다.\n\n그럼에도 `EmptySet`을 반환하는 함수를 정의하고 실행할 수 있다. 말장난 같지만 \n끝나지 않는 작업을 $\\bot$이라는 값으로 정의하였고, 모든 타입은 $\\bot$을 원소로\n갖기 때문에 공타입 `enum EmptySet {}` 또한 $\\bot$을 원소로 취한다.\n\n따라서 아래 함수는 정의할 수 있고, 컴파일되고, 실행할 수 있다.\n아래가 바로 공타입을 반환하는 함수이다. 정말 대단해.\n\n```rust\nfn some_function() -\u003e EmptySet {\n    loop {}\n}\n```\n\n러스트에서는 원시타입으로 [never][rust-never]가 정의되어 있으며 `!`[^1]로 표기하기 때문에\n*bang-type*이라고도 부른다. 위의 `EmptySet`은 `!`로 대체할 수 있다.\n\n대체 이걸 어디다 써먹는단 말인가? 위에서 보았듯이 공타입은 오로지 $\\bot$, 즉\n**반환이 없음**만을 그 값으로 취할 수 있다. 따라서 이를 표현하는 타입으로 활용할 수 있다. \n문제가 있는 경우를 타입으로 표기함으로써 이를 타입 시스템에서 파악할 수 있다.\n\n현재 프로세스를 종료하는 러스트 표준 함수 `std::process::exit`의 타입은 아래와 같다:\n\n```rust title=\"std::process\"\npub fn exit(code: i32) -\u003e !\n```\n\n반환형이 `!`이기 때문에 이 함수가 실행되면 다음 작업을 실행할 수 없음을 알 수 있다.\n덕분에 컴파일러가 아래처럼 실행 전에 미리 경고해줄 수 있다.\n\n```rust\nfn main() {\n    std::process::exit(0);\n//  --------------------- any code following this expression is unreachable\n    println!(\"Hello, World!\");\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n}\n```\n\n[rust-never]: https://doc.rust-lang.org/std/primitive.never.html\n[^1]: https://rust-lang.github.io/rfcs/1216-bang-type.html\n\n\n### 단위 집합\n\n단위 집합(*unit set*)은 단 하나의 원소만을 갖고 있는 집합이다.\n원소가 하나니까 싱글톤(*singleton*)이라고도 불리운다. 싱글톤 패턴의 그 싱글톤 맞다.\n\n싱글톤 패턴은 어떤 클래스에 대한 인스턴스가 오직 단 하나만 존재하도록 하는\n디자인 패턴이다. 아래의 예시에서 변수 `x`, `y`, `z` 모두 같은 싱글톤 인스턴스를\n가리키고 있다. 인스턴스가 단 하나이기 때문에 싱글톤이라는 이름이 붙었다:\n\n```java\nclass Singleton {\n    private static Singleton instance = null;\n    private Singleton() { /* initiating Singleton object */ }\n    public static Singleton getInstance() {\n        if (instance == null)\n            instance = new Singleton();\n        return instance;\n    }\n}\n\n// in other methods...\nSingleton x = Singleton.getInstance();\nSingleton y = Singleton.getInstance();\nSingleton z = Singleton.getInstance();\n```\n\n어떤 언어에서는 특별한 값을 나타내기 위해 단위 타입을 사용한다.\n루비의 `true`, `false`, `nil` 등의 값은 `TrueClass`, `FalseClass`, `NilClass`의\n유일한 값이다. 따라서 이들은 단위 타입이다.\n\n```ruby\nirb\u003e true\n=\u003e true\nirb\u003e true.class\nTrueClass\n```\n\n`TrueClass`의 원소는 ($\\bot$을 제외하면) `true` 말고는 없다.\n\n$$\n\\text{TrueClass} = \\{\\text{true}\\}\n$$\n\n단위 타입은 사실 암묵적으로 정말 많이 쓰이고 있다. 아래의 예시를 통해 알아보자.\n아래의 함수 `hello_world`는 아무 인자를 취하지 않고 `String`을 반환하고 있다.\n아무것도 아닌 것을 인자로 취하는 공타입과는 구별된다.\n\n```rust\n// 인자를 취하지 아니함\nfn hello_world() -\u003e String { /* ... */ }\n// 인자를 넘기지 않아도 실행된다\nlet hi = hello_world();\n\n// 아무것도 아닌 것을 인자로 취하는 공타입과는 다르다\nfn hello_world(arg: !) -\u003e String { /* ... */ }\n// 아무것도 아닌 것을 인자로 넘길 수는 없다...\nlet hi = hello_world(???);\n```\n\n정말 아무것도 취하지 않고 `String`을 반환한다면 사실상 `String`과\n동일해야 한다. 그러나 `hello_world`는 `String`은 아니다.\n아래의 예시는 타입 에러가 난다:\n\n```rust\nfn hello_world() -\u003e String { /* ... */ }\nlet hello_string: String;\n\nfn print_it(arg: \u0026String);\nprint_it(\u0026hello_world);  // mismatched types\nprint_it(\u0026hello_string); // 문제 없음\n```\n\n`hello_world`는 그냥 `String`인 것이 아니라 **아무것도 아닌 무언가를 `String`으로\n바꿔주는 함수**이다. 아무것도 아닌 무언가의 역할을 할 것이 있어야 하는데 이\n암묵적인 역할을 단위 타입이 맡는다. 러스트에서는 이를 [`()`][rust-unit]으로 표기하고\n유닛이라고 읽는다. `hello_world` 함수를 인자로 받는 함수는 아래와 같다:\n\n[rust-unit]: https://doc.rust-lang.org/stable/std/primitive.unit.html\n\n```rust\nfn print_it(arg: dyn \u0026Fn() -\u003e String);\nprint_it(\u0026hello_world);\n```\n\n아무것도 반환하지 않는 함수도 사실은 아무것도 아닌 무언가를 반환하고 있다.\n아래의 셋은 동일하다:\n\n```rust\nfn main() { /* ... */ }\nfn main() -\u003e () { /* ... */ }\nfn main() { return (); } // () 타입은 그 값도 ()로 표기한다.\n```\n\nC계열 언어에서는 반환값이 없는 함수를 표현할 때에 `void`로 선언하기 때문에\n좀 더 명시적으로 확인할 수 있다.\n\n```c\nvoid function_no_return() { /* ... */ }\n```\n\n단위 타입을 이용함으로써 아무것도 아님을 표현할 수 있다.\n\n어떤 타입 `T`를 받아 단위 타입을 반환하는 함수는 타입 별로 딱 하나만 존재한다.\n예를 들어 `bool -\u003e ()`인 함수는 아래의 함수 외에는 존재할 수 없다.\n\n```rust\nfn unit(_: bool) -\u003e () { return (); } \n```\n\n반대로 단위 타입을 받아 어떤 타입 `T`를 반환하려면, 타입 `T`의 원소 수만큼\n함수를 만들 수 있다. 예를 들어 `() -\u003e bool`인 함수는 아래의 두 함수가 있다.\n\n```rust\nfn true() -\u003e bool { true }\nfn false() -\u003e bool { false }\n```\n\n### 원소가 둘인 집합\n\n원소가 둘인 집합은 그 값이 이거 아니면 저거인 집합이다.\n\n```rust\nenum Boolean {\n    True,\n    False,\n}\n```\n\n우리에게 친숙한 원소가 둘인 집합은 바로 `bool`이다. `0`, `1`도 좋고\n`true`, `false`도 좋다. 어쨌든 원소는 둘뿐이어야한다.\n\n$$\n\\text{bool} = \\{\\text{true}, \\text{false}\\}\n$$\n\n`bool`을 취하여 `bool`을 반환하는 함수는 몇 개나 있을까? 집합 $F$의 갯수를\n생각해보자.\n\n$$\nF = \\{ f \\mid f : \\text{bool} \\rarr \\text{bool} \\}\n$$\n\n아래와 같이 항등함수 두 개(`always`, `never`), 단위함수 하나(`id`), `not` 함수까지\n총 네 개를 생각할 수 있다.\n\n```rust\nfn always(_: bool) -\u003e { true }\nfn never(_: bool) -\u003e { false }\nfn id(b: bool) -\u003e { b }\nfn not(b: bool) -\u003e {\n    match b {\n        true -\u003e false,\n        false -\u003e true,\n    }\n}\n```\n\n우리가 흔히 쓰는 \"boolean 타입\"과 완벽히 대응함을 알 수 있다.\n\n### 합집합\n\n두 집합 A, B가 있을 때, 두 집합의 모든 원소를 가지고 새로운 집합을 만들\n수 있다. 새로운 집합 $A \\cup B$의 원소는 본래 $A$의 원소이거나 $B$의 원소이다.\n이를 합집합(*union*)이라 부르고 아래처럼 정의한다:\n\n$$\nA \\cup B = \\{ x \\mid x \\in A \\lor x \\in B \\}\n$$\n\n합집합에 대응하는 타입은 합타입(*union type* 혹은 *sum type*)이다.\n합타입을 이용하면 타입을 확장할 수 있다.\n아래의 예시에서 `Number`의 원소는 `i64`의 원소이거나 `f64`의 원소이다:\n\n```rust\nenum Number {\n    Int(i64),\n    Float(f64),\n}\nlet a: Number = Int(3);\nlet b: Number = Float(1.1);\n```\n\n어떤 언어는 다음처럼 쉽게 합집합을 표현할 수 있도록 한다. \n\n```typescript\nfunction padLeft(value: string, padding: string | number);\n```\n\n위의 `enum`으로 표현한 합타입과 밑의 `|`로 표현한 합타입은 무슨 차이가 있을까?\n같은 타입을 합쳤을 경우를 살펴보자:\n\n```typescript\nlet bnb = boolean | boolean;\n```\n\n`|`로 같은 타입을 합집합을 만들 경우 본래의 타입과 다를 바가 없다. 같은 집합의\n원소를 모으면 본래의 집합과 동일하다.\n\n$$\n\\begin{aligned}\n\\text{BnB} \u0026= \\{ x \\mid x \\in \\text{boolean} \\lor x \\in \\text{boolean} \\}\\\\\n\u0026= \\{ x \\mid x \\in \\text{boolean} \\}\\\\\n\u0026= \\{\\text{true}, \\text{false}\\}\n\\end{aligned}\n$$\n\n```rust\nenum BnB {\n    B1(bool),\n    B2(bool),\n}\n```\n\n타입 생성자(위의 `B1`, `B2`)와 함께 정의한 경우 그냥 합집합이 아니라 서로소\n합집합(*disjoint union*)이 된다. `B1`으로 정의하는 `bool`과 `B2`로 정의하는\n`bool`은 서로 다른 타입이다. 값도 동일하지 않다. `B1(true)`과 `B2(true)`는\n다른 값이다. 따라서 타입 `BnB`의 가능한 값은 총 네 가지이다.\n\n$$\n\\begin{aligned}\n\\text{BnB}\n \u0026= \\{x \\mid x \\in \\text{bool}_1 \\lor x \\in \\text{bool}_2 \\}\\\\\n \u0026= \\{\\text{true}_1, \\text{false}_1, \\text{true}_2, \\text{false}_2\\}\n\\end{aligned}\n$$\n\n### 교집합\n\n합집합이 있으므로 교집합도 있지 않을까?\n$A \\cap B$는 $A$의 원소이면서 동시에 $B$의 원소인 값들의 집합이다.\n\n$$\nA \\cap B = \\{x \\mid x \\in A \\land x \\in B\\}\n$$\n\n### 곱집합\n\n집합을 합할 수 있으므로 곱할수도 있다. 곱집합(*product set*)은 두 집합의 원소로\n만들 수 있는 가능한 모든 쌍의 집합으로 정의한다.\n\n$$\nA \\times B = \\{(a, b) \\mid a \\in A \\land b \\in B \\}\n$$\n\n곱타입은 구조체(*struct*) 혹은 튜플로 정의할 수 있다. 이를 이용하면\n타입을 조합할 수 있다.","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/README":{"title":"","content":"# 자료구조\n\n\u003e 나쁜 프로그래머는 코드를 신경씁니다. 훌륭한 프로그래머는 자료구조와\n\u003e 자료구조 사이의 관계를 신경씁니다. —  [리누스 토르발즈, 2006](https://lwn.net/Articles/193245/)\n\n\u003e 올바른 자료구조로 구성했다면 알고리즘은 언제나 자명합니다.\n\u003e 알고리즘이 아니라 자료구조가 프로그래밍의 핵심입니다. —  [롭 파이크, 1989](http://doc.cat-v.org/bell_labs/pikestyle)\n\n## 추상 자료형\n\n- [추상 자료형](adt)\n- [선형 리스트](linear-list)\n- 스택\n- 큐\n- [딕셔너리](dictionary)\n- 우선 순위 큐\n- [서로소 집합](disjoint-set)\n- 이진 검색 트리\n- [최소 신장 트리](minimum-spanning-tree)\n\n# 알고리즘을 개발하기 위한 단계\n\n1. 문제를 모델링하기\n2. 문제를 해결하기 위한 알고리즘을 찾아 써보기\n3. 효율적인지 확인하기\n4. 다른 방법이 더 있는지 확인하고 개선하기","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/adt":{"title":"","content":"# 추상 자료형\n\nADT; abstract data type. 한국어로는 추상 자료형이라고 한다. 자료형에 대한\n수학적 정의이다.\n\n추상 자료형은 두 가지로 정의한다. 무엇에 대한 자료형인가? 어떤 연산을 할 수 있는가?\n자료에 대한 표현이나 연산에 대한 구현은 생각하지 않는다.\n\n하나의 추상 자료형에 대해 여러 실제 구현이 있을 수 있다. 내가 사용하는 알고리즘이\n어떤 추상 자료형을 사용하고, 그 추상 자료형에 대해 여러 자료 구조 구현이 있으며,\n각 구현이 옳은 구현임이 확실하다면 내가 필요한 연산을 효율적으로 하는 자료구조를\n쉽게 고를 수 있다.\n\n추상 자료형으로 정의된 바와 실제 구현된 자료구조의 API는 구현자의 의도와 목적에\n따라 다소 다를 수 있다.\n\n예를 들어 일반적으로 연결 리스트는 선형 리스트의 구현체이다.\n선형 리스트가 표현하고자 하는 자료를 저장할 수 있고, 필요한 연산을 구현할 수 있다.\n그러나 연결 리스트의 특성상 인덱싱, 길이 구하기 등 연산이 비효율적이기 때문에\n구현할 때 API에서 이를 배제하기도 한다.\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/dictionary":{"title":"","content":"# 딕셔너리\n\n검색, 삽입, 삭제 세 가지 연산을 지원하는 동적 집합을 딕셔너리라고 부른다.\n\n흔히 딕셔너리라고 하면 아래와 같이 키와 그에 대응하는 값들이 모인 키-값 쌍의 모음을 떠올린다:\n\n```python\ndic = {'alice': [1, 2, 3], 'bob': 42}\n# dic['alice'] = [1, 2, 3]\n```\n\nADT로서 정의하고자 하는 딕셔너리는 이보다 더 일반적이다. 파이썬의 딕셔너리도 검색, 삽입, 삭제가 가능하므로 딕셔너리 ADT의 구현체라고 할 수 있다. 더 넓게 보면 배열이나 연결 리스트와 같은 선형 리스트나 이진 탐색 트리도 마찬가지로 검색, 삽입, 삭제가 가능한 동적 집합이므로 딕셔너리이다.\n\n수많은 일반적인 데이터 처리는 딕셔너리의 연산으로 처리할 수 있다. 딕셔너리라는 ADT를 정의함으로서 일반적인 데이터 처리 알고리즘을 표현할 기준이 생기고, 또한 어떤 구현체가 해당 알고리즘에 효과적인지 손쉽게 분석할 수 있다.\n\n그래도 딕셔너리면 키-값 쌍이여야 하는 거 아니야? 선형 리스트면 키-값 쌍이 아니잖아? 라는 생각이 든다면 맘 편히 키값이 값과 같다고 생각해도 좋고, 키가 인덱스와 같다고 생각해도 좋다.\n\n```ruby\nlinear_list_0 = { 0 =\u003e '철수', 1 =\u003e '영희', 2 =\u003e '명수', 3 =\u003e '상수'}\nlinear_list_1 = { '철수' =\u003e '철수', '영희' =\u003e '영희', '명수' =\u003e '명수', '상수' =\u003e '상수'}\nlinear_list_2 = ['철수', '영희', '명수', '상수']\n```\n\n## 연산\n\n아래의 정의는 \"The Algorithm Design Manual\"과 \"Introduction to Algorithms\"을 참고하였다.\n\n- $\\operatorname{Search}(D, k)$: 딕셔너리 $D$에서 키 $k$에 대응하는 원소의 포인터를 반환한다.\n- $\\operatorname{Insert}(D, x)$: 딕셔너리 $D$의 집합에 포인터 $x$가 가리키는 원소를 추가한다.\n- $\\operatorname{Delete}(D, x)$: 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소를 삭제한다. (키값이 아닌 원소 $x$에 대한 포인터임에 유의한다.)\n- $\\operatorname{Min}(D)$: 딕셔너리 $D$에서 가장 키값이 작은 원소을 반환한다.\n- $\\operatorname{Max}(D)$: 딕셔너리 $D$에서 가장 키값이 큰 원소을 반환한다.\n- $\\operatorname{Successor}(D, x)$: 정렬된 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소의 다음 원소를 반환한다.\n- $\\operatorname{Predecessor}(D, x)$: 정렬된 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소의 이전 원소를 반환한다.\n\n위의 연산은 딕셔너리의 내용을 바꾸는 수정연산($\\operatorname{Insert}$, $\\operatorname{Delete}$)과 내용을 바꾸지 않는 탐색연산($\\operatorname{Search}$, $\\operatorname{Max}$, $\\operatorname{Min}$, $\\operatorname{Successor}$, $\\operatorname{Predecessor}$)으로 나눌 수 있다.\n\n## 구현\n\n- 선형 리스트로 구현할 수 있다.\n- 이진 탐색 트리를 이용하여 구현할 수 있다.\n- 해시 테이블을 이용하여 구현할 수 있다.\n\n### 선형 리스트\n\n선형 리스트로 구현한다면 정렬의 유무에 따라 효과적인 연산이 달라진다. 정렬하지 않을 경우 수정연산이 효과적이고, 정렬할 경우 탐색연산이 효과적이다.\n\n| 연산                                 | unsorted array | sorted array | unsorted linked list (s/d) | sorted linked list (s/d) |\n|------------------------------------|:--------------:|:------------:|:--------------------------:|:------------------------:|\n| $\\operatorname{Search}(D, k)$      |     $O(n)$     | $O(\\log n)$  |      $O(n)$ / $O(n)$       |     $O(n)$ / $O(n)$      |\n| $\\operatorname{Insert}(D, x)$      |     $O(1)$     |    $O(n)$    |      $O(1)$ / $O(1)$       |     $O(n)$ / $O(n)$      |\n| $\\operatorname{Delete}(D, x)$      |     $O(1)$     |    $O(n)$    |     $O(n)^*$ / $O(1)$      |    $O(n)^*$ / $O(1)$     |\n| $\\operatorname{Min}(D)$            |     $O(n)$     |    $O(1)$    |      $O(1)$ / $O(n)$       |     $O(1)$ / $O(1)$      |\n| $\\operatorname{Max}(D)$            |     $O(n)$     |    $O(1)$    |      $O(1)$ / $O(n)$       |    $O(1)^*$ / $O(1)$     |\n| $\\operatorname{Successor}(D, x)$   |     $O(n)$     |    $O(1)$    |      $O(n)$ / $O(n)$       |     $O(1)$ / $O(1)$      |\n| $\\operatorname{Predecessor}(D, x)$ |     $O(n)$     |    $O(1)$    |      $O(n)$ / $O(n)$       |    $O(n)^*$ / $O(1)$     |\n\n연결 리스트도 단순이냐, 이중이냐에 따라 연산의 비용이 달라진다. 단순일 경우 다음 노드를 찾기 쉬우나, 이전 노드를 찾기 위해서는 결국 순회해야 하므로 $O(n)$의 비용이 든다.\n이중 연결 리스트는 이전 노드에 대한 정보도 함께 갖고 있으므로 삭제 연산의 비용이 $O(1)$으로 줄어들며, 정렬되었을 경우 $\\operatorname{Predecessor}$ 연산도 $O(1)$으로 줄어든다.\n\n### 이진 탐색 트리\n\n| 연산                                 | binary search tree |\n|------------------------------------|:------------------:|\n| $\\operatorname{Search}(D, k)$      |       $O(\\log n)$       |\n| $\\operatorname{Insert}(D, x)$      |       $O(\\log n)$       |\n| $\\operatorname{Delete}(D, x)$      |       $O(\\log n)$       |\n| $\\operatorname{Max}(D)$            |       $O(\\log n)$       |\n| $\\operatorname{Min}(D)$            |       $O(\\log n)$       |\n| $\\operatorname{Successor}(D, x)$   |       $O(\\log n)$       |\n| $\\operatorname{Predecessor}(D, x)$ |       $O(\\log n)$       |\n\n## 참고\n\n- Steven S.Skiena. \"The Algorithm Design Manual\" 2008.\n- Thomas H.Cormen et al. \"Introduction to Algorithms\" 2009.\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/disjoint-set":{"title":"","content":"# 서로소 집합\n\n그래프 추상 자료형. `union` 연산과 `find` 연산을 쓰기 때문에\n`union-find` 자료구조라고도 한다.\n\n## 연산\n\n- `union`: 두 오브젝트를 연결함.\n- `find`: 두 오브젝트가 연결 되었는지 질의함.\n\n`union`, 즉 연결에 대한 합의가 있어야 한다. 따라서 연결을 다음과 같이 정의한다.\n\n오브젝트 $p$가 다른 오브젝트 $p$에 연결되었음을 $p \\rarr p$라고 하자.\n\n- 반사적(*reflexive*)[^1]: $p \\rarr p$ 모든 객체는 자기 자신과 연결되어있다.\n- 대칭적(*symmetric*): $p \\rarr q$이면 $q \\rarr p$이다. 연결은 양방향이다.\n- 추이적(*transitive*): $p \\rarr q$이고 $q \\rarr r$이면 $p \\rarr r$이다.\n\n[^1]: 반사적, 대칭적, 추이적 용어는 이산수학에서 관계를 표현하는 용어를 그대로 썼다.\n\n연결되어 있는 가장 커다란 집합을 연결 요소(*connected component*)라고 부른다.\n아래의 그림에서는 0은 `{0}` 그 자체, 1, 4는 서로 연결되어 있으므로 `{1, 4}`,\n2, 3도 마찬가지로 `{2, 3}`이 연결 요소라고 볼 수 있다. 연결 요소를 이용하면\n`find` 연산을 오브젝트끼리 연결 되어있는지 확인하는 문제에서 하나의 연결 요소에\n포함되어있는지 확인하는 문제로 바꿀 수 있다.\n\n```\n 0 1 2-3\n   | \n   4\n```\n\n## 구현\n\n### Quick Find\n\n`find` 연산이 빠른 구현이다.\n\n선형 리스트를 이용하여 간단히 구현할 수 있다. 아래의 서로소 집합을 예로 보자:\n\n```\n0  1--2  3--4\n|     |  |  |\n5--6  7  8  9\n```\n\n이를 선형 리스트로 나타내면 아래와 같다. 각각의 원소를 인덱스로, 리스트의 값을\n연결 요소의 id로 표현한다. 같은 연결 요소에 있다면 같은 리스트 값을 가진다:\n\n```\nindex     0   1   2   3   4   5   6   7   8   9  \n        +---+---+---+---+---+---+---+---+---+---+\ncontent | 0 | 1 | 1 | 8 | 8 | 0 | 0 | 1 | 8 | 8 |\n        +---+---+---+---+---+---+---+---+---+---+\n```\n\n`0, 5, 6`은 같은 연결 요소에 있기 때문에 해당 인덱스의 리스트 값이 같다. \n\n`find` 구현은 쉽다. $p$와 $q$의 연결 요소가 같은지 확인하면 된다.\n\n`union`는 조금 번거롭다. 연결 할 때 같은 연결 요소의 원소 수만큼 그 내용을\n바꾸어주어야 한다. 위의 그림에서 0번 연결 요소(`{0, 5, 6}`)과 8번\n연결 요소(`{3, 4, 8, 9}`)를 `union`한다고 생각해보자. 0번의 원소를 8로 바꾸거나\n8번의 원소를 0으로 바꾸어주어야한다. 연결 요소 $C$의 원소를 별도로 저장하지 않는다면\n배열 전체를 순회하며 확인해야한다.","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/linear-list":{"title":"","content":"# 선형 리스트\n\n선형 리스트(*linear list*)는 자료가 순서 있게 나열된 추상적 자료형(ADT)입니다.\n\n$$\n(a_0, a_1, a_2, \\cdots, a_{n-1})\n$$\n\n아래와 같은 예시를 생각해볼 수 있습니다:\n\n- `(폰, 룩, 퀸, 킹, 비숍, 나이트)`\n- `(월, 화, 수, 목, 금, 토, 일)`\n- `(1, 2, 3, 4, 5, ...)`\n- 그 외 순서 있게 나열할 수 있는 모든 것들\n\n## 구분\n\n선형 리스트에 포함된 자료의 타입이 모두 같다면 동형(*homogeneous*)이라고 합니다.\n아래는 러스트의 배열이며, 동형 선형 리스트입니다.\n\n```rust\nlet ages: [i32; 4] = [15, 26, 34, 42];\n```\n\n반대로 자료의 타입이 다를 수 있다면 이형(*heterogeneous*)이라고 합니다.\n아래는 엘릭서의 리스트이며, 이형 선형 리스트입니다.\n\n```elixir\ninputs = [:something, \"Hello\", 42]\n```\n\n## 연산\n\n- 길이 구하기\n- 모든 원소를 하나씩 방문하기\n- $k$번째 원소 구하기\n- $k$번째 원소 바꾸기\n- $k$번째 자리에 새 원소를 삽입하고 나머지 원소를 뒤로 밀기\n- $k$번째 원소를 삭제하고 나머지 원소를 앞으로 당기기\n- 서로 다른 두 리스트를 합치기\n\n## 구현\n\n### 배열\n\n배열(*array*)은 가장 기본적인 연속적 자료구조입니다.\n\n고정된 크기의 메모리에 각 원소가 순서에 맞게 연속적으로 저장됩니다.\n각 원소에 바로 접근할 수 있어 효율적이지만, 원소를 더하거나 뺄 때 형태를\n유지하기 위해 비용이 필요합니다.\n\n#### 장점\n\n- **랜덤 엑세스가 가능하다**: 시작 주소와 인덱스로 각 원소의 메모리 주소를 바로\n  알 수 있기 때문에 각 원소에 바로 접근할 수 있습니다.\n- **공간 효율성이 좋다**: 순수한 데이터의 나열이기 때문에 낭비되는 공간이 없습니다.\n- **메모리 지역성이 좋다**: 현대 컴퓨터는 캐시 메모리를 적극 이용하는데, 배열은\n  연관된 자료가 한 곳에 모여있으므로 캐시 적중률이 좋아서 실질적으로 더 빠릅니다.\n  \n#### 단점\n\n- 프로그램 실행 중 그 크기를 바꿀 수 없습니다.\n  - **동적 배열**로 해결할 수 있습니다.\n- 리스트를 쪼개고 합치거나, 앞에 자료를 추가하는것이 비효율적입니다.\n  - 리스트의 $n$개의 원소를 옮겨야하므로, $O(n)$의 비용이 듭니다.\n  \n#### 용례\n\n대부분의 프로그래밍 언어들이 동적 배열을 기본 선형 리스트로 사용합니다.\n\n효율이 중요한 시스템 프로그래밍 언어들은 배열\n\n\n### 연결 리스트\n\n연결 리스트(*linked list*)는 가장 기본적인 연결적 자료구조입니다.\n\n각각의 원소는 메모리 이곳저곳에 떨어져서 저장되고, 이들을 포인터로 논리적으로\n연결합니다. 각 원소가 논리적으로 연결되어 있기 때문에 중간에 값을 추가하거나\n자르거나 나누거나 합치는 등의 연산은 효율적이지만 랜덤 엑세스가 불가능하여\n특정 원소를 찾기 위해서는 대부분의 경우 앞에서부터 순차적으로 확인해야합니다.\n\n#### 장점\n\n- **쪼개고 잇는 연산이 효율적이다**: 배열은 수정을 위해서 배열 전체를 복사해야\n  하지만 연결 리스트는 그럴 필요가 없습니다. 해당 노드에서 다음 노드로의\n  연결 고리만 바꾸어주면 되기 때문에 상수시간($O(1)$)에 해결할 수 있습니다.\n  원소의 순서를 바꿔야할 필요가 있을 경우에도, 원소 자체를 옮기는 것보다는\n  포인터를 바꾸는 것이 훨씬 효율적입니다.\n- **성능이 일정하다**: 동적 배열의 경우 실행 중간에 크기가 커질 때에 한해\n  성능 저하가 일어나기 때문에 성능이 일정하지 않습니다.\n- **추가가 자유롭다**: 컴퓨터의 메모리가 부족하지 않는 이상 오버플로우 등의\n  문제를 겪을 일이 없습니다.\n  \n#### 단점\n\n- 최적화가 어렵습니다. 캐시 지역성(*cach locality*)이 좋지 않기 때문에 캐시\n  적중률이 낮으며, 반드시 포인터로 메모리 여기저기를 순회해야합니다.\n- 랜덤 엑세스가 불가능합니다. 리스트의 마지막 원소에 접근하려면 대부분의 경우\n  전체 리스트를 순회해야합니다.\n- 공간 효율성이 나쁩니다. 포인터를 활용하기 때문에 반드시 배열보다 많은 메모리를\n  사용합니다.\n\n#### 용례\n\n불변 자료구조를 적극 활용하는 프로그래밍 언어들이 연결 리스트를 기본 선형 리스트로\n자주 사용합니다. ex) 엘릭서의 `List`, 하스켈의 `[a]`\n\n이러한 언어들은 언어 차원에서 리스트를 쪼개고 잇는 연산을 쉽게 쓸 수 있도록 지원합니다.\n\n```elixir\nlist = [1, 2, 3, 5, 7]\n\n[_ | primes] = list\nassert primes == [2, 3, 5, 7]\n```\n\n이러한 언어들은 포인터로 잇는 연결적 자료구조의 특성을 적극 활용하여 성능을 높입니다.\n이를 영속적 자료 구조(*persistent data structure*)라고 합니다. \n예를 들어 아래와 같이 `1, 2, 3, 4`를 담은 연결 리스트 `list`가 있고, 이를 이용해\n`new_list`를 만들었다고 합시다:\n\n```elixir\nlist = [1, 2, 3, 4]\nnew_list = [0 | list]\n```\n\n연결 리스트의 특성을 활용하면 `1, 2, 3, 4`를 복사하지 않고도 이를 표현할 수 있습니다.\n\n```\n     /-\u003e [1, 2, 3, 4]\n[0, *]\n```\n\n그러나 위에서 언급한 단점으로 인하여 데이터를 저장하고 다룰 때에는 배열을 쓸 수\n있도록 지원하고 있습니다. ex) 엘릭서의 `:array`, `{}`, 하스켈의 `Data.Array` 등.\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/computer-science/data-structures/minimum-spanning-tree":{"title":"","content":"# 최소 신장 트리\n\nMST; minimum spanning tree\n\n그래프 $G = (V, E)$가 있을 때\n\n- **트리**란, 사이클이 없는 연결 그래프이다.\n- **$G$의 신장 트리**란, $G$의 부분 그래프로서 $G$의 모든 정점을 포함하는 트리이다.\n- **$G$의 최소 신장 트리**란, $G$의 신장 트리 중 가중치의 합이 최소가 되도록 하는 트리이다.\n\n최소 신장 트리를 구하는 알고리즘으로는 대표적으로 kruskal's algorithm과 prim's algorithm이 있다. 둘 다 한 번 한 결정을 번복하지 않는 욕심쟁이(greedy) 알고리즘이다.\n\n## Kruskal's Algorithm\n\n희소한 그래프에 유리하다.\n\n1. 비용이 가장 적은 간선을 찾는다.\n2. 해당 간선을 추가해도 사이클이 생기지 않으면 이를 추가한다.\n3. 모든 정점이 연결될 때까지 이를 반복한다.\n\n### 증명\n\n두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지. 먼저 신장 트리가 되는지 확인하자. 신장 트리가 되려면 다음의 세 조건을 만족해야한다.\n\n1. 사이클이 없어야 하고\n2. 연결 그래프여야 하고\n3. 모든 정점을 포함해야한다.\n\n귀류법으로 확인해보자. 가중치가 있는 연결 그래프 $G$에서 Kruskal 알고리즘으로 최소 신장 트리 $K$를 구했다고 하자.\n\n$K$에는 사이클이 없다. 간선을 추가할 때 사이클이 생기는지 확인하고 추가하니까 당연하다.\n\n$K$는 연결 그래프이다. $G$가 이미 연결 그래프이기 때문에 $K$가 연결 그래프가 아니려면 $G$의 특정 간선을 추가하지 않았어야 한다. 그 간선을 추가하지 않으려면 간선을 추가함으로써 사이클이 생긴다는 건데, 사이클이 있다는건 이미 연결된 상태라는 소리니까 말도 안 되는 소리다.\n\n$K$는 $G$의 모든 정점을 포함한다. $G$가 이미 연결 그래프이기 때문에 $K$에 사이클이 없고 끝까지 돈다면 모든 정점을 포함할 수 밖에 없다.\n\n따라서 kruskal 알고리즘으로 만든 $K$는 신장 트리이긴 하다. 그렇다면 가중치의 합이 최소가 되긴 하는가?\n\n최소 신장 트리가 존재하긴 할테다. 최소 신장 트리의 간선의 집합을 $T_{mst}$라고 라고, kruskal 알고리즘으로 만든 트리의 간선의 집합을 $T_k$라고 하자. 이 둘이 다르다고 가정하고 모순을 찾아보자. 귀류법이다.\n\n처음에는 $T_k$에 아무것도 없을 테니 $T_k \\subset T_{mst}$이다. 그런데 어느 순간에 $T_{mst}$에는 없는 간선 $\\{u, v\\}$가 추가되어 $T_k \\not\\subset T_{mst}$가 된다.\n\n$T_{mst}$에는 왜 $\\{u, v\\}$가 없을까? $u$와 $v$가 간접적으로 연결되어 있기 때문에 추가하는 순간 사이클이 생기기 때문일 것이다.\n\n그런데 말입니다. $T_k$와 $T_{mst}$ 둘 다 신장 트리의 간선의 집합이기 때문에 그 크기가 같다. 즉 $T_{mst}$는 $u$와 $v$를 연결하기 위해 다른 간선을 썼다는 뜻이다. 허나 kruskal 알고리즘은 간선을 비용이 낮은 순으로 연결하기 때문에 $T_{mst}$가 $\\{u, v\\}$ 대신 고른 간선보다 비용이 작거나 같다. $T_{mst}$가 최소 신장 트리라고 했으니 더 작을 수는 없고 같을 것이다. 따라서 $T_{mst}$의 비용과 $T_k$ 비용이 같으므로 $T_k$도 최소 신장 트리이다.\n\n### 구현\n\n구현의 핵심은 두 가지이다. 첫째, 간선들을 어떻게 정렬할 것인가? 둘째, 사이클이 있는지는 어떻게 확인할 것인가?\n\n간선 정렬은 그냥 정렬해도 되지만 최소 힙을 사용하여 해결할 수도 있다.\n\n사이클이 있는지는 DFS나 BFS를 이용하여 확인할 수도 있지만 그보다 UnionFind 자료구조를 이용하는 편이 효율적이다.\n\n위키피디아에 예쁜 의사코드가 있다.\n\n``` text\nKRUSKAL(G):\n  A = ∅\n  foreach v ∈ G.V:\n    MAKE-SET(v)\n  foreach (u, v) in G.E ordered by weight(u, v), increasing:\n    if FIND-SET(u) ≠ FIND-SET(v):\n      A = A ∪ {(u, v)}\n      UNION(u, v)\n  return A\n```\n\n### 시간 복잡도\n\n$O(E \\log E)$\n\n## Prim\\'s Algorithm\n\n밀집 그래프에 유리\n\n1. 정점 v를 고른다. (이거다 싶은거 아무거나 고른다)\n1. 정점 v의 간선 중 비용이 가장 적은 간선을 추가한다. 이젠 정점이 두 개다.\n1. 두 정점의 간선 중 (서로를 연결하는거 말고) 비용이 가장 적은 간선을 추가한다.\n1. ...\n1. PROFIT!!\n\n### 증명\n\n마찬가지로 두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지.\n\n먼저 신장 트리가 되는지는 Kruskal 알고리즘과 같은 이유이다.\n\n그렇다면 가중치의 합이 최소가 되는가? 아까와 같은 방법으로 해보자. 그래프 $G$에 대해 어딘가 어떤 형태로든 존재하는 최소 신장 트리의 간선의 집합을 $T_{mst}$라고 하고, Prim 알고리즘으로 만들어낸 간선의 리스트를 $T_p$라고 하자. 처음에는 $T_p \\subset T_{mst}$인데 $T_p$에 $\\{u, v\\}$가 추가되는 순간 $T_p \\not\\subset T_{mst}$가 되었다고 하자. 왜 $T_{mst}$에는 간선 $\\{u, v\\}$가 없을까? $T_{mst}$는 신장 트리, 즉 연결 그래프이기 때문에 이미 정점 $u$와 $v$는 연결되어 있다. 따라서 간선 $\\{u, v\\}$를 추가하면 사이클이 생기게 된다.\n\n둘 다 신장 트리이므로 간선의 수는 같다. $\\{u, v\\}$ 대신 다른 간선이 그 역할을 하고 있다는 뜻이다. 그런데 Prim 알고리즘은 가중치가 작은 순으로 간선을 추가하므로 간선 $\\{u, v\\}$는 그 다른 간선보다 비용이 같거나 더 작다. $T_{mst}$가 최소 신장 트리라고 했으므로 더 작을 수는 없고 같을 것이다. $\\therefore T_p$는 최소 신장 트리이다.\n\n### 시간 복잡도\n\n$O(V^2+E) → O(E \\log V)$\n\n## 참고자료\n\n- [네이버캐스트/최소 비용 신장 트리 알고리즘: 가장 적은 비용으로 연결하려면?](https://terms.naver.com/entry.nhn?docId=3579408\u0026cid=59086\u0026categoryId=59093)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/README":{"title":"","content":"# 개발환경\n\n\u003e 나쁜 목수는 언제나 연장 탓을 한다\n\n- 🐚 셸: [zsh](zsh)\n- 📝 텍스트 편집기: helix\n- 🖥터미널 레이아웃: [tmux](tmux)\n- 📂 파일 탐색기: lf\n- 📈 시스템 모니터링: `bottom`, `htop`\n- 버전 관리자: git\n\n## 터미널\n\n- [유닉스 신호](unix-signal)\n\n## 시스템\n\n- [UiBook](UiBook) - 리눅스 랩탑\n- MacBook Air (M1, 2020)\n- ODROID H2\n\n## 운영체제\n\n- [macOS 추천 앱](macos-recommended-apps)\n- [macOS에서 Vim 방향키 사용하기](use-vim-arrow-in-macos)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/git":{"title":"","content":"# git\n\n![flow of git](git-flow.jpg)\n\n## 추적하지 않는 파일 삭제\n\nuntracked file을 한 번에 삭제하기\n\n```\n$ git clean -f\n$ git clean -fd # 디렉토리도 지우기\n```\n\n## 스테이징 하지 않은 작업 취소\n\n```\n$ git restore .\n```\n\n## 수정사항 확인하기\n\n```\n$ git diff\n```\n\n## 참고\n\n- [Oh Shit, Git!?!](https://ohshitgit.com/ko)\n- [새 버전에 맞게 git checkout 대신 switch/restore 사용하기](https://blog.outsider.ne.kr/1505)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/helix":{"title":"","content":"# helix\n\n[helix-editor/helix](https://github.com/helix-editor/helix)\n\nRust로 쓴 모달 에디터.\n\n## 특징\n\n- 터미널에서 돌아가는 편집기\n  - SSH로 서버에 접속했을 때에도 쓸 수 있다.\n  - tmux와 같은 터미널 멀티플렉서와 쓸 수 있다.\n  - 메모리를 적게 먹는다.\n  - `|`, `!` 같이 쉘 명령어에 넘길 수 있는 파이프라인이 있다.\n- 모드가 있는 편집기 (modal editor)\n  - [vim]처럼 일반모드, 입력모드 등등 모드가 있다.\n  - 손을 마우스나 방향키로 옮기지 않고도 빠르게 이곳저곳으로 이동할 수 있다.\n- 선택 기반 모달 에디터\n  - [kakoune]처럼 선택 → 명령 순서로 명령어를 입력한다.\n  - 선택 후 명령어를 입력하기 때문에 명령어가 영향을 끼치는 영역이 눈으로 보여\n    실수의 여지가 적다.\n  - vim은 명령 → 선택 순으로 명령어를 입력하기 때문에, 선택을 잘못하면 바로\n    실행되어버려 실수하기 쉽상이다.\n- 다중 선택 지원\n  - 다중 선택을 기본으로 지원하여 편리하다.\n  - 특히 `%s` 기능이 좋다. `%`로 파일 전체 선택 후 `s`로 내가 원하는 영역만\n    정규식으로 골라 선택하여 동시에 편집할 수 있다.\n- LSP 내장\n  - LSP를 지원하는 언어는 IDE와 비슷하게 사용할 수 있다.\n  - 별도로 설정할 필요가 없어서 편하다.\n\n[vim]: https://www.vim.org/\n[kakoune]: https://kakoune.org/\n\n## 자주 쓰는 키\n\nvim과 다르게 kakoune처럼 모드 -\u003e 조합\n\n- `\u003cspace\u003e`: \n  - `f`: 파일 선택기. 퍼지 파인더라 엄청 편하다\n  - `b`: 버퍼 선택기\n- `v`: select 모드. 현재 선택 영역을 늘리거나 줄일 때 쓴다. kakoune에서의 `shift` 키조합과 비슷.\n  kakoune에서 `e`로 선택하고, 더 늘리려면 `\u003cs-e\u003e`를 누르면 되는데, helix에서는 `ve`를 누르면 된다.\n- `g`: goto 모드\n- `m`: match 모드\n\n## 참고\n\n- [Vim 도대체 왜 쓰는가 - Bengi의 잉여로그](https://bengi.kr/1349)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/macos-recommended-apps":{"title":"","content":"# macOS 추천 앱\n\n## maccy\n\n[maccy](https://maccy.app/)\n\n![maccy 동작 화면](maccy.png)\n\n클립보드 히스토리 도구. 오픈소스고 `brew cask`로 쉽게 설치할 수 있다.\n\n## hammerspoon\n\n[hammerspoon](https://www.hammerspoon.org/)\n\nlua 언어를 이용한 자동화 도구. macOS의 대부분의 동작을 프로그래밍 할 수 있다.\n[기계인간님의 사용 용례](https://johngrib.github.io/wiki/hammerspoon/)를 보고 쓰기 시작했다.\n\n특정 프로그램에서 ESC 누를 시 영문 IME로 변경하기 위해서 쓰고 있다. -- [설정](https://github.com/nyeong/.dotfiles/tree/master/hammerspoon)\n\n## karabiner-elements\n\n[Karabiner-Elements](https://karabiner-elements.pqrs.org/)\n\n키보드 커스터마이즈 도구. 키보드 동작을 간단하게 매핑할 수 있다. 아래와 같은 동작을 위해 쓰고 있다:\n\n1. `caps-lock`을 짧게 누르면 ESC로 동작한다.\n2. `caps-lock`을 누르고 있다면\n   1. H, J, K, L이 각각 좌, 하, 상, 우로 동작한다. (vim arrow binding)\n   2. `back-space` 키가 `delete` 키로 동작한다.\n\n-- [설정](https://github.com/nyeong/.dotfiles/blob/master/karabiner/assets/complex_modifications/nyeong.json)\n\n## raycast\n\n[raycast](https://www.raycast.com/)\n\n![raycast 사용화면](raycast.png)\n\n텍스트 기반 앱 런처. macOS의 spotlight나 Alfred를 대체할 수 있다.\n개인 사용자용은 무료고, 별다른 기능 제약도 없다.\n확장 기능을 추가할 수 있다는 것이 장점이다.\n\n## dozer\n\n[Mortennn/Dozer](https://github.com/Mortennn/Dozer)\n\n메뉴바 아이콘을 깔끔하게 가릴 수 있는 앱이다. `brew cask`로 간편하게 설치할 수 있다.","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/tmux":{"title":"","content":"# tmux\n\n[tmux/tmux](https://github.com/tmux/tmux)\n\n터미널 멀티플렉서. 한 화면에 여러 터미널 세션을 띄우고 관리할 수 있다.\n\n- 한 화면에서 여러 세션과 프로그램을 사용할 수 있다.\n- 현재 세션을 잠시 백그라운드로 돌렸다가, 나중에 다시 불러올 수 있다.\n- 동일한 리모트 서버 세션을 다른 여러 로컬에서 접속할 수 있다.\n\n## 설치\n\n```bash\n# macOS with brew\n$ brew install tmux\n\n# arch with pacman\n$ pacman -S tmux\n```\n\n## 꿀팁\n\n`c-d`로 세션을 종료하면 마지막 셸 세션이 종료될 때 tmux도 함께 꺼진다.\n`\u003cprefix\u003e d`로 세션을 종료하지 않고 tmux를 종료할 수 있다.\n\n쉘로 원격 접속 후 `\u003cprefix\u003e d`, `c-d` 하면 tmux를 살리고 원격 접속을 종료할 수\n있다.\n\n## 단축키\n\nprefix 키를 먼저 눌러 단축키를 쓸 수 있다. 기본값은 `\u003cc-b\u003e`이다.\n\n`\u003cc-w\u003e`로 바꿔서 쓰는 중 (2022-03-31 기준)\n\n### 윈도우\n\n- `\u003cprefix\u003e [n]` : 숫자에 해당하는 탭으로 이동\n- `\u003cprefix\u003e n` : 다음 탭으로 이동\n- `\u003cprefix\u003e p` : 이전 탭으로 이동\n- `\u003cprefix\u003e l` : 마지막 탭으로 이동\n\n### 틀 (pane)\n\n- `\u003cprefix\u003e %` : 세로로 나누기\n- `\u003cprefix\u003e \"` : 가로로 나누기\n- `\u003cprefix\u003e [방향키]` : 틀 이동\n- `\u003cprefix\u003e q` : 틀 번호 표시. 표시된 번호를 눌러 이동할 수 있다.\n- `\u003cprefix\u003e o` : 다음 틀로 이동\n- `\u003cprefix\u003e m-[방향키]` : 틀 크기 조절\n- `c-d` : 틀 종료\n\n### 트리모드\n\n- `\u003cprefix\u003e s` : 세션 트리모드로 진입\n- `\u003cprefix\u003e w` : 윈도우 트리모드로 진입\n \n## 대안\n\ntmux의 기능으로 충분해서 굳이 대안이 필요 없긴 하다.\n\n- zellij: macOS 환경에서 한국어를 입력할 때 지연되는 문제가 있어 보류.\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/uibook/README":{"title":"","content":"# UiBook\n\n## 사양\n\n- 구매: 2022-08-23\n- 제품명: HP 파빌리온 Aero 13-be1041AU\n- CPU: AMD Ryzen 5 5625U\n- RAM: DDR4 8GB\n- 디스플레이: 13.3\" 1920x1200 sRGB 100% 400nit\n- 무게: 970g\n- 통신: WiFi 6, Bluetooth 5.2\n  * Realtek RTL8852BE ➡  Intel AX210NGW로 교체함\n\n## 구성\n\n- OS: Arch Linux\n- 패키지 매니저: pacman, paru\n- 텍스트 편집기: helix\n- 윈도우 매니저: Hyprland\n- 화면 잠금: swaylock\n- 터미널: alacritty\n- 컬러스킴: catppuccino_macchiato\n- IME: kime\n- 백라이트 유틸리티: wluma\n- 사운드 유틸리티: PulseAudio\n\n## 해주어야 하는 것들\n\n- [복사 붙여넣기가 안돼요]\n- [한글 입력](set-korean-ime)\n- [GUI 구성하기]\n- [개발환경 구성하기]\n- [키보드 레이아웃 커스텀하기](custom-keyboard-layout)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/uibook/custom-keyboard-layout":{"title":"","content":"# 키보드 레이아웃 커스텀하기 (with kmonad)\n\n```\nsudo usermod -aG input $USER\nsudo groupadd uinput\nsudo usermod -aG uinput $USER\n\necho 'KERNEL==\"uinput\", MODE=\"0660\", GROUP=\"uinput\", OPTIONS+=\"static_node=uinput\"' | sudo tee /etc/udev/rules.d/90-uinput.rules\n```\n\n```\n$ mkdir ~/.config/kmonad\n$ touch ~/.config/kmonad/aero13.kbd\n```\n\n```clojure\n(defcfg\n  input (device-file \"/dev/input/by-path/platform-i8042-serio-0-event-kbd\")\n  output (uinput-sink \"KMonad output\")\n)\n```\n\n- `/dev/input/by-id`: plugged-in\n- `/dev/input/by-path`: internel\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/uibook/set-korean-ime":{"title":"","content":"\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/unix-signal":{"title":"","content":"# 유닉스 신호\n\n유닉스 신호를 사용하는 리눅스, macOS, BSD 계열 OS에 한정한 이야기이다.\n\n각각의 프로세스들은 서로와, 그리고 운영체제와 **유닉스 신호**(*unix signal*)을\n이용하여 소통한다. CLI에서 프로그램을 쓰다가 `Ctrl+C`를 눌러 종료할 때에도\n유닉스 신호가 전달된다.\n\n아래의 C 프로그램은 `SIGINT` 신호를 받을 때까지 대기하고, 받으면 종료한다.\n일반적으로는 프로그램이 실행되고 있을 때 `Ctrl-C`를 눌러 신호를 보낼 수 있다.\n\n```c\n#include \u003csignal.h\u003e // signal function\n#include \u003cstdio.h\u003e  // printf function\n#include \u003cunistd.h\u003e // sleep function\n#include \u003cstdlib.h\u003e // exit function\n\nvoid handle_sigint(int signum) {\n  printf(\"%d: SIGINT catched.\\n\", signum);\n  exit(0);\n}\n\nint main() {\n  signal(SIGINT, handle_sigint);\n\n  while (1) {\n    sleep(1);\n  }\n  \n  return 0;\n}\n```\n\n```bash\n$ clang test.c\n$ ./a.out\n^C2: SIGINT catched.\n```\n\n신호는 기본적으로 프로세스를 인터럽트한다. 위의 C 예시에서 프로세스는\n`while`문을 실행하고 있겠지만, 유닉스 신호를 받는 순간\n`void handle_sigint(int)` 콜백부터 처리한다.\n\n## 신호 보내기\n\n유닉스 신호 전체는 `man signal`로 볼 수 있다.\n\n주로 쓰는 유닉스 신호와 신호 번호(*signum*), 매핑된 단축키는 아래와 같다.\n번호는 유닉스의 [macOS signal 메뉴얼][macos-signal]을 참고하였는데, 리눅스의\n그것과 다를 수도 있다.\n\n[macos-signal]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/signal.3.html\n\n| 신호이름 | 번호 | 단축키 | 설명                           | 기본동작    |\n|----------|--- --|--------|--------------------------------|-------------|\n|`SIGHUP`  | 1    | 없음   | 신호 끊김(hang up)             |프로세스 종료|\n|`SIGINT`  | 2    | Ctrl-C | 프로세스 인터럽트              |프로세스 종료|\n|`SIGQUIT` | 3    | Ctrl-\\ | 프로세스 종료                  |코어 덤프    |\n|`SIGKILL` | 9    | 없음   | 프로세스 강제종료              |코어 덤프    |\n|`SIGSTOP` | 17   | 없음   | 프로세스 멈춤 (무시할 수 없음) |프로세스 멈춤|\n|`SIGTSTP` | 18   | Ctrl-Z | 프로세스 멈춤 (키보드로 발생)  |프로세스 멈춤|\n|`SIGCONT` | 19   | 없음   | 프로세스 재개                  |신호 무시    |\n|`SIGCHLD` | 20   | 없음   | 자식 프로세스의 상태가 바뀜    |신호 무시    |\n|`SIGUSR1` | 30   | 없음   | 프로세스 재개                  |신호 무시    |\n\n- 프로세스 종료(*terminate*): 프로세스의 작동을 멈추고 종료한다.\n- 프로세스 멈춤(*stop*): 프로세스를 정지시킨다. `SIGCONT`로 다시 실행시킬 수\n  있다.\n- 코어 덤프(*create core image*): 프로세스를 종료(*terminate*)하고 메모리\n  상태를 기록한다. 프로그램이 종료되었을 때 상태를 확인하고 재현할 수 있도록\n  하기 위함이다.\n  \n### `SIGHUP`?\n\n**sig**nal **h**ang **up**의 약어이다. *hang up*이 전화를 끊다라는 뜻인데,\n전화선으로 \n\n프로세스를 실행하고 있는 터미널이 종료되면 프로세스에게 `SIGHUP` 신호가\n전달된다. 기본 동작은 종료이기 때문에 터미널을 종료하면 켜놓았던 프로세스는\n다 종료된다. 이를 막으려면 `nohup` 명령어를 사용하면 된다.\n\n### `SIGQUIT`과 `SIGKILL`의 차이\n\n`SIGQUIT`은 프로세스에 멈춤 신호를 보내어 자식 프로세스나 메모리를 정리하도록\n한다. 반면 `SIGKILL`은 강제로 종료해버린다. 그래서 문제가 생긴 프로세스를\n강제 종료할 때에는 아래와 같이 `kill -9`으로 `SIGKILL` 신호를 보내어 강제로\n종료한다.\n\n```bash\n$ kill -9 [pid]\n```\n\n### `SIGSTOP`과 `SIGTSTP`의 차이\n\n둘 다 프로세스에 멈추라는 신호를 보낸다. `SIGTSTP`은 주로 `tty`를 통하여\n키보드로 보내며 (보통 `ctrl-z`) 프로그램이 무시할 수 있는 반면 `SIGSTOP`은 \n`kill`등의 명령어와 조합하여 신호를 보내며 무시할 수 없다.\n\n프로세스가 멈추면 종료되는 것과는 다르게 일시중지된 상태로 현재 세션에\n남아있는다.\n\n```\n# \u003cc-z\u003e를 눌러 SIGTSTP 신호 보내기\n$ ruby test.rb\n^Z\nzsh: suspended  ruby test.rb\n\n# `kill` 명령어를 이용하여 SIGSTOP 신호 보내기\n$ ruby test.rb \u0026\n[2] 69330\n$ kill -17 69330\n[2]  + suspended (signal)  ruby test.rb\n\n# 일시 중지된 작업 보기\n$ jobs\n[1]  - suspended  ruby test.rb\n[2]  + suspended (signal)  ruby test.rb\n```\n\n이렇게 일시 중지된 작업들은 `fg` 명령어로 포어그라운드에서, `bg` 명령어로 \n백그라운드에서 작업을 재개할 수 있다. 이대로 종료하고 싶다면 `kill` 명령어로\n`SIGINT` 등의 신호를 보내면 된다.\n\n### 프로그래밍 언어에서\n\n### 러스트에서\n\n러스트에서는 표준 라이브러리만으로는 유닉스 신호를 처리하기 힘들다.\n표준 라이브러리로 `std::io::signal`이 있었으나, 처리를 위하여 운영체제에 의존한\n런타임 라이브러리가 필요해서 삭제된 것 같다.[^1] [CtrlC]와 같은  외부\n라이브러리를 이용하면 처리할 수 있다.\n\n[^1]: https://github.com/rust-lang/rust/pull/17673\n[CtrlC]: https://crates.io/crates/ctrlc\n\n## 참고\n\n- [Signal handling](https://rust-cli.github.io/book/in-depth/signals.html)\n- [signal(7) - Linux manual page][unix-signal]\n\n[unix-signal]: https://man7.org/linux/man-pages/man7/signal.7.html\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/use-vim-arrow-in-macos":{"title":"","content":"# macOS에서 Vim 방향키 사용하기\n\nvim 계열 텍스트 편집기는 H, J, K, L을 이용하여 커서를 좌, 하, 상, 우로 움직일 수 있습니다.\n오른손을 원래 자리에서 때고 방향키로 옮기지 않고도 편하게 커서를 옮길 수 있어서 매우 유용합니다.\n\nmacOS에서 [Karabiner](https://karabiner-elements.pqrs.org/)를 이용하면 같은 동작을 구현할 수 있습니다.\n\n자동화 도구인 [Hammerspoon](https://www.hammerspoon.org/)을 이용해서도 구현할 수 있으나, 체감상 karabiner가\n더 빠릿한 느낌입니다.\n\n## 짧은 설명\n\n먼저 Karabiner-Elements를 다운로드 받습니다. [공식 홈페이지](https://karabiner-elements.pqrs.org/)에서 \n받아도 좋고, 아래 명령어로 `brew`를 이용해 받을 수도 있습니다.\n\n```bash\nbrew install karabiner-elements\n```\n\n![](karabiner-apps.png)\n\n받고 나면 Karabiner-Elements와 Karabiner-EventViewer를 쓸 수 있습니다. EventViewer는 디버깅 등에 유용한 이벤트 뷰어로 현재는 불필요합니다.\n\n[설정 파일](https://github.com/nyeong/.dotfiles/blob/2f7e43f314941bbd3c323ad9a21805cd3fe00f35/karabiner/assets/complex_modifications/nyeong.json)을 내려받습니다.\n`curl` 명령어로 내려받을 수 있습니다.\n내려받은 후 `~/.config/karabiner/assets/complex_modifications` 디렉토리 밑으로 파일을 넣어줍니다.\n\n```bash\ncd ~/Downloads\ncurl https://raw.githubusercontent.com/nyeong/.dotfiles/2f7e43f314941bbd3c323ad9a21805cd3fe00f35/karabiner/assets/complex_modifications/nyeong.json --output nyeong.json\nmkdir -p ~/.config/karabiner/assets/complex_modifications\nmv nyeong.json ~/.config/karabiner/assets/complex_modifications/\n```\n\n그 후 Karabiner-Elements를 켜면 Complex Modifications 탭에서 설정 파일의 규칙을 적용할 수 있습니다.\n\n![](karabiner-elements-complex-modifications.png)\n\n위의 설정은 아래의 동작을 합니다.\n\n- 캡슬락을 짧게 누르면 ESC키로 동작합니다\n- 캡슬락을 누른 채로 H, J, K, L을 누르면 방향키로 동작합니다.\n- 캡슬락을 누른 채로 U, I, O, P를 누르면 Page Up, Home 등으로 동작합니다.\n- 캡슬락을 누른 채로 스페이스 바를 누르면 백스페이스로 동작합니다.\n- 캡슬락을 누른 채로 백스페이스를 누르면 delete로 동작합니다.\n\n캡슬락을 이용하는 설정이므로 \n`시스템 환경설정` → `키보드` → `보조키...`에 들어가 Caps Lock키를 작업 없음으로 설정해줍니다.\n\n![](macos-preference-keyboard-caps-lock.png)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/dev-env/zsh":{"title":"","content":"# zsh\n\n## 이상한 괄호쌍\n\n쉘을 쓰다 보면 너무나도 다양한 괄호쌍이 나온다... 헷갈려서 정리했다.\n\n대괄호, 중괄호, 소괄호를 영어로는 각각 brackets, curly braces, parenthese라고\n한다.\n\n- 단일 대괄호(`[ ]`): 조건 표현문. POSIX 표준[^1]\n- 이중 대괄호(`[[ ]]`): `[`의 개선판.\n- 중괄호(`{ }`): 중괄호 확장문(*brace expansion*)[^3]\n- 단일 소괄호(`( )`): 배열 표현.\n- 이중 소괄호(`(( ))`): 산술 표현문.[^2]\n- 산술 확장문(`$[ ]`): 더 이상 쓰지 않는다.\n- 변수 확장문(`${ }`)\n- 명령어 대치문(`$( )`): 명령어를 실행하고 그 결과로 값을 대치한다.\n- 산술 확장문(`$(( ))`)\n\n[^1]: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html\n[^2]: https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html\n[^3]: https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html\n\n### 대괄호\n\n`[ ]`(단일 대괄호, *single bracket*), `[[ ]]`(이중 대괄호, *double bracket*)\n모두 조건 검사에 쓴다.\n\n`[ ]`는 조건 검사 명령어이다. 보통 `/bin/[`에 위치하며 `/bin/test`와 동치이다.\nPOSIX 호환 문법이다.[^4]\n\n[^4]: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html\n\n`[[ ]]`는 확장 문법이다. korn, bash, zsh 등의 쉘에서 폭넓게 사용한다. 해당 쉘을\n쓴다면 `[[ ]]`만 알아도 충분하다.\n\n자세한 사용법은 [Bash Conditional Expressions] 참고.\n\n[Bash Conditional Expressions]: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html\n\n`$[ ]`(산술 대치문, *arithmetic expansion*)은 `$(( ))`로 대치되어 현재는 쓰지\n않는다.[^5]\n\n[^5]:https://wiki.bash-hackers.org/scripting/obsolete\n\n### 중괄호\n\n`{ }`(중괄호, *braces, curly braces*)는 문자열의 리스트를 만들 때 쓴다.\n\n아래의 두 명령어는 똑같다. `{ }`를 이용하여 간편하게 줄여 쓸 수 있다.\n\n```bash\n$ mv -i lib/user/{accont,account}.ex\n$ mv -i lib/user/accont.ex lib/user/account.ex\n```\n\n아래와 같이 범위를 지정할 수도 있다. 이는 문자열도 가능하다.\n\n```bash\n$ mkdir test_dir_{00..99..2}\n$ touch {가..힣} # 왜 이런 짓을...?\n```\n\n`${ }`(변수 확장문, *parameter expansion*)을 쓰면 변수를 결과값으로\n대치(*substitute*)할 뿐 아니라, 여러가지 옵션으로 확장할 수 있다.\n\n변수와 뒤에 오는 문자열을 구분해야 할 경우 `$var` 대신 쓸 수 있다.\n\n```bash\n$ DIR_PREFIX=hello\n$ echo $DIR_PREFIX_world\n# \n$ echo ${DIR_PREFIX}_world\n# hello_world\n```\n\n옵션으로 확장하면 다양한 기능을 함께 쓸 수 있다. `${var=str}` 문법은 `var`\n변수가 정의되어 있으면 그걸 쓰고, 정의되어 있지 않다면 `var`에 `str`을 대입하고\n`str` 값을 결과로 쓴다. 아래의 코드는 `$EDITOR` 변수가 정의되어 있으면 해당\n편집기로 `config` 파일을 열고, 아니라면 `vim`으로 여는 명령어이다.\n\n```bash\n$ ${EDITOR=vim} config\n```\n\n그 외의 옵션은 [Shell parameter Expansion] 참고.\n\n[Shell parameter Expansion]: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\n\n### 소괄호\n\n`( )`(단일 소괄호, *single parentheses*)는 배열을 만들 때 쓴다.\n\n```bash\n$ array=(1 2 3)\n$ $array\n# 1 2 3\n```\n\n`(( ))`(이중 소괄호, *double parentheses*)는 산술 연산에 쓴다.\n\n```bash\n$ i=10\n$ i+=10\n# i = 1010\n\n$ i=10\n$ ((i += 10))\n# i = 20\n```\n\n`$(( ))`(산술 확장문, *arithmetic expansion*)은 산술 계산 후 결과값으로\n대치된다.\n\n```bash\n$ echo ((i += 10))\n# zsh: no maches found: ((i += 10))\n$ echo $((i += 10))\n# 30\n```\n\n## 팁\n\n### 특정 명령어가 있는지 확인하기\n\n`(( $+commands[foobar] ))` 쓰면 된다.\n\n[Speed Test: Check the Existence of a Command in Bash and Zsh][check-speed-test]\n\n[check-speed-test]: https://www.topbug.net/blog/2016/10/11/speed-test-check-the-existence-of-a-command-in-bash-and-zsh/\n\n- `type foobar \u0026\u003e /dev/null`\n- `hash foobar \u0026\u003e /dev/null`\n- `command -v foobar \u0026\u003e /dev/null`\n- `which foobar \u0026\u003e /dev/null`\n- `(( $+commands[foobar] ))`\n\n아래와 같이 쓸 수 있다.\n\n```bash\nexport EDITOR=vi\n\nif (( $+commands[vim] )); then\n  export EDITOR=vim\nfi\n\nif (( $+commands[helix] )); then\n  export EDITOR=helix\n  alias hx='helix'\nfi\n```","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/README":{"title":"","content":"# 프로그래밍 언어\n\n- [elixir](elixir)\n- [rust](rust)\n- ruby\n\n## 참고\n\n- [CodeCrafters](https://app.codecrafters.io/)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/OTP":{"title":"","content":"# OTP\n\nOTP; Open Telecom Platform. 옛날에는 전화 교환기, 스위치를 만드는 데에 쓰여서 이름이 저렇다.\n얼랭, 엘릭서 생태계에서 거대한 시스템을 관리하기 위한 범용 도구이다.\n\n엘릭서 프로그램을 개발할 때 [[notes/elixir/프로세스]]를 직접 쓰기보다는 OTP에서 제공하는 도구를 쓰는 편이 낫다.\n\n- Task: 작업을 백그라운드에서 하고 싶을 때 쓴다.\n- Agent: 상태를 관리하고 싶을 때 쓴다.\n- GenServer: 범용적인 상황에서 쓸 수 있는 만능 구현.\n\n## Task\n\n무언가를 백그라운드에서 돌리고 싶을 때 쓴다.\n\n```elixir\niex\u003e worker = Task.async(fn -\u003e 오래_걸리는_작업() end)\niex\u003e # do something else\niex\u003e result = Task.await(worker)\n```\n\n익명 함수를 취하는 `Task.async/1`과 이름 있는 함수를 취하는 `Task.async/3`이 있다.\n\n## Agent\n\n상태를 관리하는 백그라운드 프로세스이다.\n\n```elixir\niex\u003e {:ok, count} = Agent.start(fn -\u003e 2 end)\niex\u003e Agent.get(count, \u0026Function.identity/1)\n2\niex\u003e Agent.update(count, \u0026(\u00261 * \u00261))\n:ok\niex\u003e Agent.get(count, \u0026Function.identity/1)\n4\n```\n\n## GenServer\n\n여러 상황에 쓰일 수 있는 범용 서버이다.\n`init/1`, `handle_call/3`, `handle_cast/2` 등의 콜백을 구현하여 사용한다.\n\n### init\n\nGenServer를 초기화한다.\n\n```elixir\ndef init(start_args) do\n  {:ok, state}\nend\n```\n\n```elixir\niex\u003e {:ok, server} = GenServer.start_link(MyServer, args)\n```\n\n### handle_call/3\n\n`GenServer.call/3`을 통해 호출된 동기 메시지를 다룬다.\n\n```elixir\ndef handle_call(request, _from, state) do\n  {:reply, return, new_state}\nend\n```\n\n인자는 `request, from, state` 꼴이다. `request`는 `call/3`에 의해 호출된 메시지를, `from`은 누가 호출했는지를,\n`state`는 서버의 현재 상태를 나타낸다.\n\n반환은 `{:reply, return, new_state}` 꼴이다. 반환값이 필요 없다면 `{:noreply, new_state}` 꼴로 반환하면 된다.\n\n보통은 `request`를 튜플로 하여 인자를 함께 넘긴다.\n\n```elixir\niex\u003e GenServer.call(MyServer, {:call_name, call_args})\n```\n\n### handle_cast/2\n\n`cast/2`를 통해 호출된 비동기 메시지를 다룬다.\n\n인자는 `request, state` 꼴이다. `request`는 `cast/2`에 의해 호출된 메시지를,`state`는 서버의 현재 상태를 나타낸다.\n\n```elixir\ndef handle_cast(request, state) do\n  {:noreply, new_state}\nend\n```\n\n아래와 같이 쓸 수 있다.\n\n```elixir\niex\u003e GenServer.cast(MyServer, {:call_name, call_args})\n```\n\n반환값이 필요 없다면 `{:noreply, new_state}` 꼴로 반환하면 된다.\n\n### 구현 감싸기\n\n```elixir\ndef start_link(start_args) do\n  GenServer.start_link(__MODULE__, current_number, name: __MODULE__)\nend\n```","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/README":{"title":"","content":"# Elixir\n\n- [module-directives](module-directives)\n- [process](process)\n- [OTP](OTP)\n- [dialyxir](dialyxir)\n- [bitstrings](bitstrings)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/bitstrings":{"title":"","content":"# Bitstrings\n\n[[notes/elixir]]는 메모리의 비트열을 [bitstring]이라는 단위로 다룬다.\n\n[bitstring]: https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#bitstrings\n\n## 기본 표기\n\n`bitstring` 리터럴은 기본적으로 8비트, 즉 1바이트 단위로 값을 표기한다.\n\n```elixir\niex\u003e \u003c\u003c255\u003e\u003e\n\u003c\u003c255\u003e\u003e\niex\u003e \u003c\u003c256\u003e\u003e\n0\n```\n\n그 외의 단위로 값을 표기하고 싶다면 `::size`를 붙여주면 된다.\n\n```elixir\niex\u003e \u003c\u003c4::8\u003e\u003e\n\u003c\u003c4\u003e\u003e\niex\u003e \u003c\u003c4::4\u003e\u003e\n\u003c\u003c4::size(4)\u003e\u003e\niex\u003e \u003c\u003c15::4\u003e\u003e\n\u003c\u003c15::size(4)\u003e\u003e\niex\u003e \u003c\u003c16::4\u003e\u003e\n\u003c\u003c0::size(0)\u003e\u003e\n```\n\n패턴매칭도 된다.\n\n```elixir\niex\u003e \u003c\u003ca::1, b::1, c::1, d::1\u003e\u003e = \u003c\u003c4::4\u003e\u003e\n\u003c\u003c4::size(4)\u003e\u003e\niex\u003e [a, b, c, d]\n[0, 1, 0, 0]\n```\n\n```elixir\niex\u003e \u003c\u003cn::32\u003e\u003e = \u003c\u003c0, 255, 255, 255\u003e\u003e\n\u003c\u003c0, 255, 255, 255\u003e\u003e\niex\u003e n\n16777215\n```\n\n```elixir\niex\u003e \u003c\u003c255, 255, 255\u003e\u003e = \u003c\u003c0xFF, 0xFF, 0xFF\u003e\u003e\n\u003c\u003c255, 255, 255\u003e\u003e\niex\u003e Base.encode16(\u003c\u003c255, 255, 255\u003e\u003e)\n\"FFFFFF\"\n```\n\n## 타입\n\n- `\u003c\u003c\u003e\u003e`\n- `binary()` = `\u003c\u003c_::_*8\u003e\u003e`\n- `bitstring()` = `\u003c\u003c_::_*1\u003e\u003e`\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/dialyxir":{"title":"","content":"# dialyxir 적용하기\n\nmix 프로젝트에서 `mix.exs`를 열고 `deps/0`에 다음을 추가한다.\n\n```elixir\ndefp deps do\n  [\n  # highlight-next-line\n    {:dialyxir, \"~\u003e 1.0\", only: :dev, runtime: false}\n  ]\nend\n```\n\n이후 `mix dialyzer`로 타입 검사를 할 수 있다.\n\n```bash\n$ mix do deps.get, deps.compile\n$ mix dialyzer\n```","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/module-directives":{"title":"","content":"# 모듈 지시자\n\nModule Directives. 모듈을 합성하기 때문에 composition이라고 부르기도 하는 듯.\n\n## alias\n\n모듈에 별칭을 붙일 때 쓴다.\n\n```elixir\ndefmodule Sangatsu.State do\n  def new, do: \"어쩌구\"\nend\n\n# 아무것도 없다면\nstate = Sangatsu.State.new()\n\n# alias를 쓴다면\nalias Sangatsu.State\nstate = State.new()\n\n# `as`와 함께 쓴다면\nalias Sangatsu.State, as: S\nstate = S.new()\n```\n\n## import\n\n다른 모듈의 함수와 매크로를 불러올 때 쓴다.\n\n```elixir\n# 다 불러오면\nimport Sangatsu.State\nstate = new()\n\n# 불러올 함수 선택하기\nimport Sangatsu.State, only: [new: 0]\nstate = new()\n\nimport Sangatsu.State, expect: [other: 1]\nstate = new()\n```\n\n기본적으로 `import` 하지 않아도 `List` 모듈의 함수를 쓰는 데에는 지장이 없음. 다만 `List.duplicate`처럼 모듈을 명시해주어야함.\n\n## require\n\n해당 모듈이 컴파일 된 후에 불러옴\n\n```elixir\nrequire Sangatsu.State\n# Sangatsu.State가 컴파일 된 후에 이 코드가 실행됨이 보장된다.\n```\n\n## use\n\n해당 모듈의 콜백을 사용. 클래스 상속같은 느낌으로 쓴다.\n\n```elixir\ndefmodule Sangatsu.State do\n  defmacro __using__(_opts) do\n    quote do\n      # 어쩌고\n    end\n  end\nend\n\ndefmodule MySangatsu.State do\n  use Sangatsu.State\n  # Sangatsu.State.__using__ 콜백이 실행되었음\nend\n```\n\n## 참고\n\n[Making Sense of Elixir Directives](https://github.com/rwdaigle/elixir-directives)\n[alias, require, and import -- elixir Getting Started](http://elixir-lang.org/getting-started/alias-require-and-import.html)\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/elixir/process":{"title":"","content":"# 프로세스\n\n## 생성\n\n```elixir\n@spec spawn(module, atom, list) :: pid\n```\n\n`module`과 `atom`은 실행할 함수를, `list`는 넘길 인자 리스트를 의미한다.\n반환값인 `pid`는 프로세스 식별자이다.\n\n```elixir\niex\u003e spawn(SpawnBasic, :greet, [])\n```\n\n\n## 메시지 주고 받기\n\n`send/2` 함수와 `receive` 매크로로 프로세스끼리 메시지를 주고 받을 수 있다.\n\n### 보낼 때\n\n`send/2` 함수를 이용하여 보낸다. 첫 인수는 `pid`, 메시지를 받을 프로세스이다.\n두번째 인수는 `term()`으로 아무 값이나 보내도 되는데, 보통 `{:type, message}` 패턴을 많이 쓴다.\n\n```elixir\niex\u003e pid = spawn(Module, :function, [])\niex\u003e send pid, {:ok, message}\n```\n\n### 받을 때\n\n`receive` 매크로로 해당 프로세스에 도착한 메시지를 받아본다.\n패턴매칭을 이용하여 메시지가 매칭되는 절을 실행한다.\n\n```elixir\nreceive do\n  {:ok, message} -\u003e\n    IO.puts message\nend\n```\n\n`receive` 매크로는 기본적으로 메시지를 받을 때까지 블록된다. 이를 원치 않으면\n`after` 절을 써서 타임아웃되도록 한다.\n\n```elixir\nreceive do\n  {:ok, message} -\u003e\n    IO.puts \"do something with #{message}\"\n  after 500 -\u003e\n    IO.puts \"timeout\"\nend\n```\n\n또한 기본적으로 한 번에 하나의 메시지만 처리하므로, 여러 메시지를 처리하기\n원한다면 재귀를 써야 한다.\n\n```elixir\ndef loop do\n  receive do\n    {:ok, message} -\u003e\n      IO.puts \"do something with #{message}\"\n  end\n  loop\nend\n```\n\n### 상태 유지\n\n프로세스는 엘릭서에서 상태를 다루는 방법 중 하나이다. 프로세스가 루프의 인자로\n상태를 들고 있으면, 다른 프로세스에서 활용할 수 있다.\n\n```elixir\n# a loop for stack process\ndef loop([h | l] = state) do\n  receive do\n    {:push, elem} -\u003e\n      loop([elem | state])\n\n    {:pop, caller} -\u003e\n      send caller, h\n      loop(l)\n  end\nend\n\niex\u003e send stack, {:push, 1}\niex\u003e send stack, {:pop, self()}\n```\n\n### 상태 전파\n\n`Process.link/1` 함수로 현재 프로세스와 다른 프로세스를 링크할 수 있다.\n`spawn_link` 함수를 쓰면 생성과 링크를 한 번에 할 수 있다.\n\n``` elixir\niex\u003e boom = fn -\u003e\n...\u003e   :timer.sleep 500\n...\u003e   exit :boom\n...\u003e end\niex\u003e spawn boom      # 아무 일도 일어나지 않는다\niex\u003e spawn_link boom # spawn한 프로세스가 `exit` 되므로 현재 프로세스도 종료된다.\n** (EXIT from #PID\u003c0.105.0\u003e) shell process exited with reason: :boom\n```\n\n`Process.monitor/1` 함수나 `spawn_monitor` 함수를 사용하면 단방향으로 프로세스를 연결할 수 있다.","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/programming-languages/rust/README":{"title":"","content":"# Rust\n\n## 참고\n\n- [rust-lang/rustlings](https://github.com/rust-lang/rustlings)\n- [Rust By Practice](https://practice.rs/why-exercise.html)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/side-projects/README":{"title":"","content":"# 사이드 프로젝트\n\n- [[notes/nth-weekday]]","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/side-projects/nth-weekday":{"title":"","content":"# 오늘은 몇 주차\n\n[오늘은 몇 주차](https://annyeong.me/nth-week-today/)\n\n## '주'란 무엇인가?\n\n**주**란 과연 무엇일까요? 주에 대해 자세히 생각해보면 이런 저런 의문이 듭니다.\n\n- *한 주의 시작*은 월요일일까, 일요일일까? \n- 365.25일을 7로 나누면 약 52.178이다. 즉 1년은 평균 52.178주이다?\n- 올해(2022년)의 첫날은 토요일이다. 그렇다면 올해의 첫주는 1월 1일을 포함할까?\n\n세상에는 혼돈을 줄이기 위하여 별에 별 것들에 대해 표준이 있습니다. 날짜와 시간과 관련된 데이터에 대한 국제 표준으로 [ISO 8601](https://ko.wikipedia.org/wiki/ISO_8601)이 있으며, 이에 대응하는 국내 표준으로 [KS X ISO8601](https://www.standard.go.kr/KSCI/standardIntro/getStandardSearchView.do?menuId=503\u0026topMenuId=502\u0026ksNo=KSXISO8601\u0026tmprKsNo=KSXISO8601)이 있습니다. 표준이력사항을 읽어보면 국내산업에서 개정의 요구가 없어 국제 표준과 동일한 내용으로 국내에 적용하고 있는 것을 확인할 수 있습니다.\n\n해당 표준 내용을 정리하면 아래와 같습니다.\n\n- 한 주는 7일로 이루어져있다.\n- 한 주는 월요일로 시작하여 일요일로 끝난다.\n- 1년은 52주 또는 53주이다. (즉 364일 또는 371일이다.)\n- 1년의 첫번째 주는 해당 해의 **첫번째 목요일**이 포함된 주이다.\n- 1년의 마지막 주는 해당 해의 **마지막 목요일**이 포함된 주이다.\n- 주를 표현할 때에는 **2018-W12** 혹은 날짜를 포함하여 **2018-W12-4**처럼 한다. 이 경우 2018년의 13번째 주의 4번째 날이므로 2018년 03월 22일이 된다.\n\n요약하면, 한 주의 시작은 월요일, 끝은 일요일이지만, **주차에 대한 판단 기준은 목요일**에 있습니다.\n\n예시를 들어보면 아래와 같다. 아래처럼 첫해의 첫 목요일이 포함된 주가 그 해의 첫번째 주가 됩니다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W01** | 01  | 02  | 03  | **04** | 05  | 06  | 07  |\n\n만약 첫 목요일이 아래와 같이 되어 있다면 해당 연도의 1월 1일부터 1월 3일은 그 해의 첫주가 아니라, *그 전 해의 마지막 주*가 됩니다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W53** |     |     |     |        | 01  | 02  | 03  |\n| **W01** | 04  | 05  | 06  | **07** | 08  | 09  | 10  |\n\n## Week Number 계산하기\n\n주차를 직접 계산해봅시다. 깔끔하게 `week_number(date: Date) -\u003e i32` 같은 함수가 나오는 것이 목표입니다. 주차란 올해의 첫번째 주로부터 몇 주가 지났는지를 의미합니다. 오늘이 올해의 몇 번째 날인지만 알면 7로 나누어 알아낼 수 있습니다. 오늘이 올해의 몇번째 날인지를 $\\text{ordinal}(\\text{date})$라고 하겠습니다. 이는 컴퓨터로는 오늘에서 1월 1일을 빼면 알 수 있고, 손으로는 오늘 날짜와 지나간 월들의 날을 모두 합하여 알아낼 수 있습니다.\n\n가장 간단하게 1월 1일이 월요일인 해를 가정해봅시다. 다음은 해당 해의 첫주이므로 $\\text{week}(1)$부터 $\\text{week}(7)$까지의 값이 1로 같아야합니다. \n\n|Week   |Mon|Tue|Wed| *Thu* |Fri|Sat|Sun|\n|-------|---|---|---|-------|---|---|---|\n|**W01**| 01| 02| 03| **04**| 05| 06| 07|\n\n다음과 같이 6을 더하고 버림 함수를 사용하면 이 구간에서는 의도한 대로 나옵니다.\n\n$$\n\\text{week}(\\text{date}) =\n\\left\\lfloor\\frac{\\text{ordinal}(\\text{date}) + 6}{7} \\right\\rfloor\n$$\n\n다른 예시를 살펴봅시다. 1일이 작년으로 넘어가면 올바른 결과가 나오지 않습니다. 해가 금요일부터 시작하여 1월 1일이 W01이 아닌 예를 봅시다.\n\n|Week   |Mon|Tue|Wed| *Thu* |Fri|Sat|Sun|\n|-------|---|---|---|-------|---|---|---|\n|**W53**|   |   |   |       | 01| 02| 03|\n|**W01**| 04| 05|06 | **07**| 08| 09| 10|\n\n$\\text{week}(1)=52$, $\\text{week}(4)=1$이 되어야 하지만, 위의 식을 적용하면, 둘 다 1이 되어버립니다.\n\n주의 시작이 월~목일 때와 이를 넘어갈 때를 구분할 방법이 필요하다. 오늘 날짜에서 요일을 빼면 가능할 것 같다. ISO 8601에 요일을 수로 표현할 때는 월요일을 1로, 일요일을 7로 하여 나열한다고 나와있다. (이를 *week day*라고 한다.) 이렇게 하면 같은 주의 $\\text{ordinal}(\\text{date}) - \\text{weekday}(\\text{date})$의 값은 일정해진다.\n\n값을 명확히 보기 위해 바닥함수는 제외하고 `wN = (date) =\u003e (ordinal(date) - weekday(date) + 6) / 7`이라고 하자. 1월 1일이 월요일일 때와 금요일일 때의 `wN`값을 확인해보자\n\n| Week    | Mon    | Tue    | Wed    | *Thu*  | Fri    | Sat    | Sun    |\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| 요일    | 01     | 02     | 03     | 04     | 05     | 06     | 07     |\n| **W01** | 01     | 02     | 03     | **04** | 05     | 06     | 07     |\n| `wN`    | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` |\n| **W53** |        |        |        |        | 01     | 02     | 03     |\n| `wN`    |        |        |        |        | `0.29` | `0.29` | `0.29` |\n| **W01** | 04     | 05     | 06     | **07** | 08     | 09     | 10     |\n| `wN`    | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` |\n\n`wN`이 1보다 작은 경우는 전년도의 마지막 주로 처리하면 깔끔할 것 같다. 그런데 1월 1일이 월요일일 경우 `wN`이 1.0을 넘지 않는다. 위에서 주었던 보정값 `+6` 대신 다른 상수를 더해서 해결해보자.\n\n$$\\text{week}(\\text{date}) =\n\\left\\lfloor\\frac{\\text{ordinal}(\\text{date}) - \\text{weekday}(\\text{date}) + C}{7} \\right\\rfloor$$\n\n- 1월 1일이 **월요일**이라면 이날은 **첫번째 주**이므로 $1-1+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 화요일이라면 이날은 첫번째 주이므로 $1-2+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 수요일이라면 이날은 첫번째 주이므로 $1-3+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 목요일이라면 이날은 첫번째 주이므로 $1-4+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 **금요일**이라면 이날은 **마지막 주**이므로 $1-5+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n- 1월 1일이 토요일이라면 이날은 마지막 주이므로 $1-6+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n- 1월 1일이 일요일이라면 이날은 마지막 주이므로 $1-7+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n\n위의 조건에 만족하려면 $C=10$이여야한다.\n\n상수가 바뀌었으니 새로운 보정값에 맞춰 `wN`을 계산해보자. 이때 `wN = (date) =\u003e (ordinal(date) - weekday(date) + 10) / 7`이다.\n\n| Week    | Mon    | Tue    | Wed    | *Thu*  | Fri    | Sat    | Sun    |\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| **W53** | 28     | 29     | 30     | **31** | 01     | 02     | 03     |\n| `wN`    | `53`   | `53`   | `53`   | `53`   | `0.86` | `0.86` | `0.86` |\n| **W01** | 04     | 05     | 06     | **07** | 08     | 09     | 10     |\n| `wN`    | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` |\n\n따라서 오늘의 날짜를 알고 있다면 위의 공식으로 오늘의 *주수*(week number)를 알 수 있습니다.\n\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/side-projects/sangatsu":{"title":"","content":"# sangatsu\n\n쇼기 게임 만들기\n\n- 쇼기 엔진\n- 쇼기 표현\n- 쇼기 렌더링\n\n## 참고\n\n- [Chess Engine: A Zero to One](https://www.chessengines.org/)","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/web-backend/README":{"title":"","content":"# 웹 엔지니어링\n\n- [[notes/phoenix-framework]]","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/notes/web-backend/phoenix-framework":{"title":"","content":"# Phoenix Framework\n\n- Channel\n- PubSub\n- Presence","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/src/pages":{"title":"","content":"# 반갑습니다 😊\n\n인터넷에서 **안녕**이라는 이름을 쓰고 있습니다.\n컴퓨터와 프로그래밍을 공부하고 있습니다. 이 사이트는 제가 배운 것들을\n정리하여 스스로 더 잘 이해하고자 만들었습니다.\n\n배움이 부족하기에 내용에 옳지 않거나 오래된 것들이 있을 수 있습니다.\n고쳐야 할 점이 있다면 [저장소 이슈]를 통해 연락주시면 반영하겠습니다.\n\n[misskey]도 하고 있습니다. 마스토돈 등 ActivityPub 구현 인스턴스에서 멘션 주시면 됩니다.\n\n[저장소 이슈]: https://github.com/nyeong/hanassig/issues \"nyeong/hanassig\"\n[misskey]: https://misskey.dev/@annyeong \"@annyeong\"\n\n[노트]에는 제가 배운 내용을 계층 형식으로 정리하여 올리고 있습니다.\n[블로그]에는 제가 보고 느낀 것을 줄글로 올리고 있습니다.\n\n[노트]: /notes\n[블로그]: /blog\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null},"/static/katex/README":{"title":"","content":"# [\u003cimg src=\"https://katex.org/img/katex-logo-black.svg\" width=\"130\" alt=\"KaTeX\"\u003e](https://katex.org/)\n[![npm](https://img.shields.io/npm/v/katex.svg)](https://www.npmjs.com/package/katex)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![CI](https://github.com/KaTeX/KaTeX/workflows/CI/badge.svg?branch=main\u0026event=push)](https://github.com/KaTeX/KaTeX/actions?query=workflow%3ACI)\n[![codecov](https://codecov.io/gh/KaTeX/KaTeX/branch/main/graph/badge.svg)](https://codecov.io/gh/KaTeX/KaTeX)\n[![Discussions](https://img.shields.io/badge/Discussions-join-brightgreen)](https://github.com/KaTeX/KaTeX/discussions)\n[![jsDelivr](https://data.jsdelivr.com/v1/package/npm/katex/badge?style=rounded)](https://www.jsdelivr.com/package/npm/katex)\n![katex.min.js size](https://img.badgesize.io/https://unpkg.com/katex/dist/katex.min.js?compression=gzip)\n[![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod)](https://gitpod.io/#https://github.com/KaTeX/KaTeX)\n[![Financial Contributors on Open Collective](https://opencollective.com/katex/all/badge.svg?label=financial+contributors)](https://opencollective.com/katex)\n\nKaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.\n\n * **Fast:** KaTeX renders its math synchronously and doesn't need to reflow the page. See how it compares to a competitor in [this speed test](https://www.intmath.com/cg5/katex-mathjax-comparison.php).\n * **Print quality:** KaTeX's layout is based on Donald Knuth's TeX, the gold standard for math typesetting.\n * **Self contained:** KaTeX has no dependencies and can easily be bundled with your website resources.\n * **Server side rendering:** KaTeX produces the same output regardless of browser or environment, so you can pre-render expressions using Node.js and send them as plain HTML.\n\nKaTeX is compatible with all major browsers, including Chrome, Safari, Firefox, Opera, Edge, and IE 11.\n\nKaTeX supports much (but not all) of LaTeX and many LaTeX packages. See the [list of supported functions](https://katex.org/docs/supported.html).\n\nTry out KaTeX [on the demo page](https://katex.org/#demo)!\n\n## Getting started\n\n### Starter template\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003c!-- KaTeX requires the use of the HTML5 doctype. Without it, KaTeX may not render properly --\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css\" integrity=\"sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC\" crossorigin=\"anonymous\"\u003e\n\n    \u003c!-- The loading of KaTeX is deferred to speed up page rendering --\u003e\n    \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js\" integrity=\"sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e\n\n    \u003c!-- To automatically render math in text elements, include the auto-render extension: --\u003e\n    \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js\" integrity=\"sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\" crossorigin=\"anonymous\"\n        onload=\"renderMathInElement(document.body);\"\u003e\u003c/script\u003e\n  \u003c/head\u003e\n  ...\n\u003c/html\u003e\n```\n\nYou can also [download KaTeX](https://github.com/KaTeX/KaTeX/releases) and host it yourself.\n\nFor details on how to configure auto-render extension, refer to [the documentation](https://katex.org/docs/autorender.html).\n\n### API\n\nCall `katex.render` to render a TeX expression directly into a DOM element.\nFor example:\n\n```js\nkatex.render(\"c = \\\\pm\\\\sqrt{a^2 + b^2}\", element, {\n    throwOnError: false\n});\n```\n\nCall `katex.renderToString` to generate an HTML string of the rendered math,\ne.g., for server-side rendering.  For example:\n\n```js\nvar html = katex.renderToString(\"c = \\\\pm\\\\sqrt{a^2 + b^2}\", {\n    throwOnError: false\n});\n// '\u003cspan class=\"katex\"\u003e...\u003c/span\u003e'\n```\n\nMake sure to include the CSS and font files in both cases.\nIf you are doing all rendering on the server, there is no need to include the\nJavaScript on the client.\n\nThe examples above use the `throwOnError: false` option, which renders invalid\ninputs as the TeX source code in red (by default), with the error message as\nhover text.  For other available options, see the\n[API documentation](https://katex.org/docs/api.html),\n[options documentation](https://katex.org/docs/options.html), and\n[handling errors documentation](https://katex.org/docs/error.html).\n\n## Demo and Documentation\n\nLearn more about using KaTeX [on the website](https://katex.org)!\n\n## Contributors\n\n### Code Contributors\n\nThis project exists thanks to all the people who contribute code. If you'd like to help, see [our guide to contributing code](CONTRIBUTING.md).\n\u003ca href=\"https://github.com/KaTeX/KaTeX/graphs/contributors\"\u003e\u003cimg src=\"https://contributors-svg.opencollective.com/katex/contributors.svg?width=890\u0026button=false\" alt=\"Code contributors\" /\u003e\u003c/a\u003e\n\n### Financial Contributors\n\nBecome a financial contributor and help us sustain our community.\n\n#### Individuals\n\n\u003ca href=\"https://opencollective.com/katex\"\u003e\u003cimg src=\"https://opencollective.com/katex/individuals.svg?width=890\" alt=\"Contribute on Open Collective\"\u003e\u003c/a\u003e\n\n#### Organizations\n\nSupport this project with your organization. Your logo will show up here with a link to your website.\n\n\u003ca href=\"https://opencollective.com/katex/organization/0/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/0/avatar.svg\" alt=\"Organization 1\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/1/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/1/avatar.svg\" alt=\"Organization 2\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/2/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/2/avatar.svg\" alt=\"Organization 3\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/3/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/3/avatar.svg\" alt=\"Organization 4\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/4/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/4/avatar.svg\" alt=\"Organization 5\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/5/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/5/avatar.svg\" alt=\"Organization 6\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/6/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/6/avatar.svg\" alt=\"Organization 7\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/7/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/7/avatar.svg\" alt=\"Organization 8\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/8/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/8/avatar.svg\" alt=\"Organization 9\"\u003e\u003c/a\u003e\n\u003ca href=\"https://opencollective.com/katex/organization/9/website\"\u003e\u003cimg src=\"https://opencollective.com/katex/organization/9/avatar.svg\" alt=\"Organization 10\"\u003e\u003c/a\u003e\n\n## License\n\nKaTeX is licensed under the [MIT License](https://opensource.org/licenses/MIT).\n","lastmodified":"2022-12-09T04:50:05.375496015Z","tags":null}}