{"/":{"title":"index","content":"\n안녕하세요. 인터넷에서 안녕이라는 이름을 쓰고 있습니다.\n컴퓨터와 프로그래밍을 공부하고 있습니다.\n이 사이트는 제가 배운 것들을 정리하여 스스로 더 잘 이해하고자 만들었습니다.\n\n배움이 부족하기에 내용에 옳지 않거나 오래된 것들이 있을 수 있습니다.\n고쳐야 할 점이 있다면 [저장소 이슈](https://github.com/nyeong/hanassig/issues/new)\n혹은 연합우주를 통해 연락주시면 반영하겠습니다.\n\n- [연합우주 (@annyeong@misskey.dev)](https://stella.place/@annyeong)\n- [전체 글 목록](https://annyeong.me/notes/)\n- [전체 태그 목록](https://annyeong.me/tags/)\n\n## 주제별 대분류\n\n- [[notes/기술스택]]\n- [[notes/컴퓨터 과학]]\n- [[notes/기계학습]]\n- [[notes/DIY]]\n- 도구들\n\t- [[notes/개발환경]]\n\t- [[notes/소유록]]\n- [[notes/음악]]","lastmodified":"2023-02-05T06:08:13.019516128Z","tags":null},"/README":{"title":"","content":"\n배운 것들을 하나씩 정리합니다.\n\n- 각 파일은 `notes` 디렉토리 밑에 위치하며, 작성 규칙은 [해당 문서](notes/하나씩.md)를 따릅니다.\n- 웹으로의 공유는 [nyeong/nyeong.github.io](https://github.com/nyeong/nyeong.github.io) 저장소에서 하고 있으며, [annyeong.me](https://annyeong.me) 도메인으로 발행하고 있습니다.","lastmodified":"2023-02-05T06:08:13.019516128Z","tags":null},"/notes/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD":{"title":"개발환경","content":"\n내 개발환경 설정 모음\n\n- 셸: zsh\n- 텍스트 편집기: [[helix]]\n- 터미널 레이아웃: tmux\n- 파일탐색: nnn\n- 시스템 모니터링: bottom\n- 버전 관리자: git\n\n## 시스템\n\n- MacBook Air (M1, 2020)\n\t- [[macOS]] 참고\n- UiBox","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EA%B7%80%EC%B9%B4%ED%94%BC-%ED%95%98%EB%8A%94-%EB%B2%95":{"title":"귀카피 하는 법","content":"\n1. 곡의 구성을 파악한다.\n2. 곡의 키를 찾는다.\n3. 해당 파트의 베이스 음의 진행을 찾는다.\n4. 해당 마디의 코드를 찾는다.\n5. 특이한 구성음을 찾는다.\n6. 해당 노트의 주법을 찾는다.\n\n\n## 참고\n\n- [『耳コピ』の手順を５ステップで解説！やり方、コツなど..【初心者でも可能！】 - YouTube](https://www.youtube.com/watch?v=Ba6tA-BWIR8)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EA%B8%89%ED%95%98%EA%B2%8C-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%B0%B0%EC%9A%B0%EA%B8%B0":{"title":"급하게 파이썬 배우기","content":"\n## REPL\n\n```python\n# type 함수로 값의 타입을 알 수 있음\ntype({}) # =\u003e \u003cclass 'dict'\u003e\n```\n\n## 산술연산\n\n```python\n# 나누기 연산 결과는 float임\n35 / 5 # =\u003e 7.0\n\n# 몫을 구하는 연산자가 따로 있음\n35 // 5 # =\u003e 7\n\n# 모듈러 연산자도 있음\n35 % 3 # =\u003e 2\n\n# 제곱 연산자가 있음\n2 ** 3 # =\u003e 8\n\n# 형변환이 필요한 경우 `int`와 `float` 함수를 이용\n```\n\n## 논리 연산\n\n```python\n# 참 거짓은 대문자로 시작\nTrue\nFalse\n\n# `not`, `and`, `or`\nnot True\nTrue and True\nFalse or True\n\n# 산술 연산에서는 1과 0으로 취급함\nTrue + True # =\u003e 2\n1 == True # =\u003e True\n\n# `bool` 함수를 생성자로 쓸 수 있음\n# 0, None, 빈 컨테이너는 False로 취급함\n# None은 null, nil과 같음.\nbool(0) # =\u003e False\nbool([]) # =\u003e False\nbool({}) # =\u003e False\n\n# 비교 연산은 `==`, `!=`. 나머지는 아는 대로.\n# `==`는 값의 비교. `is`는 존재의 비교\n[1, 2, 3] == [1, 2, 3] # =\u003e True\n[1, 2, 3] is [1, 2, 3] # =\u003e False\n```\n\n## 문자열\n\n```python\n# \"\"랑 ''랑 차이가 없음\n# 문자열 합치기는 `+`\n\"안녕\" + '세상아' # =\u003e '안녕세상아'\n\n# 배열 인덱싱 가능\n\"안녕 세상아\"[2] # =\u003e ' '\n\n# 길이 구하기는 `len()`\n\n# 문자열 보간은 f\"`{variable}`\"\n# 혹은 `\"{순서}\".format()` 함수를 이용\n# 혹은 `% (value)` 이용\nage = \"17\"\nf\"저는 영원한 {age}세입니다\"\n\n# 포맷팅\nprint('{0:5s}')\nprint('{0:\u003e10s}')\nprint('{0:\u003c10s}')\nprint('{cel:.2f}')\n```\n\n## 제어구문\n\n```python\n# 삼항연산자는 TrueCaluse if Condition else FalseCaluse\n\"good\" if True else \"bad\"\n\n# 들여쓰기가 중요함\nif True:\n\t\"good\"\nelse:\n\t\"bad\"\n\n# for-in 문법\nfor animal in [\"dog\", \"cat\"]:\n\tprint(f\"{animal}\")\n\n# for로 dict 순회\nfor key in a:\n\tpass\nfor val in a.values():\n\tpass\nfor key, val in a.items():\n\tpass\n\n# for comprehension\n[x for x in [1, 2, 3] if x % 2 == 0] # =\u003e [2]\n\n# while문\nwhile True:\n\tpass\n```\n\n## 자료구조\n\n```python\n# 리스트. 가변임\n[1, 2, 3]\n\n# concat은 extend()\nl = [1, 2, 3]\nm = [4, 5, 6]\nl.extend(m)\nl # =\u003e [1, 2, 3, 4, 5, 6]\n\n# 원소 추가하기\nl.append(20)\n\n# 원소 빼기\nl.pop()\n\n# 튜플. 불변임\n(1, 2, 3)\n\n# 딕셔너리. (3.6부터는 ordered)\n# 키는 불변, 값은 가변.\na = {'a': 1}\n\n# 업데이트\na['a'] = new_value\n\n# 키가 있는지는 key in dict\nif 'a' in d:\n\tdo_something(d['a'])\n\n# collections 모듈에 있는 것\n# - deque\n# - Counter\n# - OrderedDict\n# - namedtuple\n```\n\n## 익명함수\n\n람다라고 있긴 한데 권장하지 아니함.\n\n### 복사\n\n```python\n# 그냥 대입하면 복사되지 않는다.\na = {}\nb = a\na is b # =\u003e True\n\n# `copy`로 얕은 복사\n# 얕은 복사라서 \na = {1: [1]}\nb = a.copy()\na is b # =\u003e False\na[0] is b[0] # =\u003e True\n\n# `copy.deepcopy()`로 깊은 복사\nimport copy\na = {1: [1]}\nb = copy.deepcopy(a)\na is b # =\u003e False\na[0] is b[0] # =\u003e False\n```\n\n## 클래스\n\n```python\n# class로 클래스 만들 수 있음\n# 상속하려면 인자로 상속 객체를 넘김.\nclass Node(object):\n\t# 생성자는 `__init__(self)`로 정의함\n\t# 호출은 `Node()`\n\t# self를 명시적으로 넘기는 게 특이함.\n\tdef __init__(self):\n\t\tself.어쩌구=0\n\n\t# 그 외의 특수한 예약 함수. magic matehod라고 함.\n\t# __str__, __add__, __eq__, __main__\n\t# __str__은 str로 포맷할 내용을 정의.\n\t# __add__는 `+`에 대응하는 동작.\n\tdef __str__(self):\n\t\treturn \"str\"\n```\n\n## 이터 툴\n\n```python\n# itertools에서 불러와야함\nimport itertools\n\n# groupby\nitertools.groupby(data, key=keyfunc)\n\n# reduce는 functools에 따로 있음\nfrom functools import reduce\n```\n\n## 모듈\n\n- `import X`: 파일을 모두 메모리에 불러오기\n- `import X as X'`: alias\n- `from X import Y`: 특정 함수, 클래스만 호출하기\n- `from X import *`: 모든 함수, 클래스를 호출하기\n\n```python\n# some_file.py\ndef some_function():\n\treturn 'something'\n```\n\n```python\n# 다른 파일에서 불러오기\n# 기본적으로 같은 디렉토리에 있어야\nimport some_file\n\n# 모듈 속 모듈 불러오기\nimport some_module.sub_module\n\n# 상대경로 사용하기\nimport ..some_module\n\n# 모듈.함수\nsome_file.some_function()\n```\n\n\n디렉토리로 분리하려면 `__init__.py`를 엔트리 포인트로 쓰면 됨.\n없어도 패키지로 인식은 함.\n\n### init\n\n```python\n# __init__.py\n\n# 서브 모듈에 대한 정의\n__all__ = [\"module1\", \"module2\"]\n\n# 불러오기\nfrom . import module1\nfrom . import module2\n```\n\n### main\n\n패키지에 대한 엔트리 포인트\n\n```python\n# __main__.py\n\nif __name__ == \"__main__\":\n\tdo_something()\n```\n\n### built-in module\n\n- `random`\n- `time`\n- `urllib`\n- `os`\n- `logging`\n\n```python\nimport logging\n\nlogger = logging.getLogger('main')\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger.setLevel(logging.INFO)\n\n# 따로 파일로 로그 뺴기\nstream_handler = logging.FileHandler()\nlogger.addHandler(stream_handler)\n\n# 아래로 갈수록 중요함\nlogger.debug('')\nlogger.info('')\nlogger.warning('')\nlogger.error('')\nlogger.critical('')\n```\n\n## 예외처리\n\n- try-except 문법\n- 대표적인 예외\n\t- IndexError, NameError, ZeroDivisionError, ValueError, FileNotFoundError\n\n```python\ntry:\n\t# 예외가 발생할 가능성이 있는 작업\n\t10 / 0\nexcept ZeroDivisionError:\n\t# 예외를 어떻게 처리할지\n\tprint('divided by zero occured.')\nexcept Exception as e:\n\t# 모든 에러를 변수 `e`로 받아서 처리\n\tprint(e)\nelse:\n\t# 에러가 발생하지 않았을 경우 실행할 블록\nfinally:\n\t# 에러가 발생하든 말든 실행해야하는 블록.\n\t# 사용한 자원 처리 등\n\n# raise로 에러 발생시키기\ndef some_function():\n\traise ValueError(\"message\")\n```\n\n## 파일처리\n\n- `open(filename, mode)`\n- `file.read()` -- 다 가져옴\n- `file.write(data)`\n- `file.close()`\n\n```python\n# with 구문을 쓰면 close를 까먹지 않을 수 있음.\nwith open(\"filename\", \"r\") as f:\n\tdo_something_with(f)\n```\n\n디렉토리는 `os`, `os.path`, `shutil` 모듈이 유용함.\n\n- `os.mkdir(dirname)`\n- `os.path.exists(dirname)`\n- `os.path.isfile(filename)`\n- `shutil.copy(src, dest)`\n\n파이썬 객체를 영속화 할 때에는 `pickle`\n\n```python\nimport pickle\n\n# 파일에 객체를 영속화하여 쓰기\ntest = [1, 2, 3, 4, 5]\nf = open(\"file\", \"wb\")\npickle.dump(test, f)\nf.close()\n\n# 파일을 불러오기\ntest = [1, 2, 3, 4, 5]\nf = open(\"file\", \"rb\")\nloaded = = pickle.load(f)\nf.close()\n```\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EA%B8%B0%EA%B3%84%ED%95%99%EC%8A%B5":{"title":"기계학습","content":"\n기계학습의 개론적인 갈래를 이해하기 위한 문서.\n\n주어진 데이터를 이용하여 문제를 해결하기 위해 최적의 모델을 찾는 학문.\n\n## 종류\n\n- 지도학습(supervised learning) — 정답이 주어지는 학습\n\t- 분류(classification)\n\t- 회귀(regression)\n- 비지도학습(unsupervised learning) — 정답이 주어지지 않는 학습\n\t- 클러스터링(clustering)\n- 자기지도학습(SSL; Self-Supervised Learning) — 정답이 없을 경우 직접 달면서 학습\n\t- 단어 임베딩 등\n- 강화학습(reinforcement learning) — 행동을 통해 보상을 얻으며 학습\n\n### 지도학습\n\n데이터에 정답 $y$가 주어지는 경우 지도학습 알고리즘을 쓸 수 있다.\n\n- 분류 — 예측하고자하는 레이블이 이산적일 경우 **분류** 문제이다.\n\t- 스팸이거나 아니거나. 글의 카테고리가 무엇인지 등.\n\t- [[로지스틱 회귀]]\n\t- KNN, SVM, 의사 결정 트리 등을 이용하여 해결한다.\n- 회귀 — 예측하고자하는 값이 연속적일 경우 **회귀** 문제이다.\n\t- [[선형 회귀]]\n\n## 과정\n\n1. 데이터를 수집한다.\n2. 데이터를 분석하여 파악하고 학습에 맞게 전처리한다.\n3. 적절한 모델을 세워서 학습한다.\n4. 학습 결과에 대해 평가한다.\n5. 반복\n\n## 평가\n\n### 혼동행렬\n\n알고리즘의 정확성을 평가하기 위한 도구.\n\n| 구분      | 예측 참 (P) | 예측 거짓 (N) |\n| --------- | ------- | --------- |\n| 실제 참   | TP      | FN        | \n| 실제 거짓 | FP        |  TN         |\n\n- $TP$; True Positive — 참양성 혹은 참긍정\n- $FP$; False Positive — 위양성 혹은 거짓긍정\n- $FN$; False Negative — 위음성 혹은 거짓부정\n- $TN$; True Negative — 참음성 혹은 참부정\n\n위 값을 이용하여 정밀도, 재현율, 정확도를 구하여 알고리즘을 평가한다:\n\n- 정밀도(precision) — 참으로 예측한 것이 얼마나 맞는가\n\t$P=\\frac{TP}{TP+FP}$\n- 재현율(recall) — 실제로 참인 것을 얼마나 맞추는가\n\t$R = \\frac{TP}{TP+FN}$\n- 정확도(accuracy) — 정답을 얼마나 맞추는가\n\t$\\text{ACC}=\\frac{TP+TN}{TP+TN+FP+FN}$\n- $F_1$ 값 — $F_1 = \\frac{2PR}{P+R}$\n\n### 과적합과 과소적합\n\n모델이 데이터를 과하게 학습한 경우 **과적합**(overfitting)이라고 한다.\n- 학습 데이터에서는 높은 성능을 발휘하지만 평가 데이터에서는 성능이 떨어진다.\n- dropout, early stopping을 활용한다.\n\n모델이 충분히 데이터를 학습하지 못한 경우 **과소적합**(underfitting)이라고 한다.\n- 학습 데이터에서도 높은 성능을 발휘하지 못한다.\n\n## 참고\n\n- [Team-Neighborhood/I-want-to-study-Data-Science](https://github.com/Team-Neighborhood/I-want-to-study-Data-Science)\n- 유원준, [딥 러닝을 이용한 자연어 처리 입문](https://wikidocs.net/book/2155). WikiDocs, 2022.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EA%B8%B0%EC%88%A0%EC%8A%A4%ED%83%9D":{"title":"기술스택","content":"\n## 언어\n\n- 엘릭서\n- 러스트\n\n## DB\n\n- Postgresql","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%85%BC%EB%A6%AC%EA%B0%92%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95":{"title":"논리값을 다루는 방법","content":"\n\n여기서 얘기하려는 논리값은 `bool`, `true`와 `false`를 의미.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%8B%A4%EC%9D%B4%EC%96%B4%ED%86%A0%EB%8B%89-%EC%BD%94%EB%93%9C":{"title":"다이어토닉 코드","content":"\ndiatonic chord. 어떤 음계에서 그 음계의 구성음으로만 이루어진 코드를 의미한다.\n\n![](assets/diatonic-chords.svg)\n\n\u0008다이어토닉 코드를 분석할 때에 로마숫자로 표기하면 특정 키에 얽매이지 않고 코드 진행을 볼 수 있어서 편리하다.\n\n## 3화음의 경우\n\n| I   | ii  | iii | IV  | V   | vi  | vii\u003csup\u003eo\u003c/sup\u003e |\n| --- | --- | --- | --- | --- | --- | --------------- |\n| C   | Dm  | Em  | F   | G   | Am  | Bm\u003csup\u003e(♭5)\u003c/sup\u003e |\n\nvii\u003csup\u003eo\u003c/sup\u003e는 감3화음(diminished triad)이며 [[7화음]]과의 구분을 위해 VIIm\u003csup\u003e(♭5)\u003c/sup\u003e로 표기하기도 한다.\n\n## 7화음의 경우\n\n| I\u003csup\u003e△7\u003c/sup\u003e | ii\u003csup\u003e7\u003c/sup\u003e | iii\u003csup\u003e7\u003c/sup\u003e | IV\u003csup\u003e△7\u003c/sup\u003e | V\u003csup\u003e7\u003c/sup\u003e | vi\u003csup\u003e7\u003c/sup\u003e | vii\u003csup\u003eo7\u003c/sup\u003e |\n| -------------- | -------------- | --------------- | -------------- | ------------- | -------------- | ---------------- |\n| C\u003csup\u003e△7\u003c/sup\u003e  | Dm\u003csup\u003e7\u003c/sup\u003e | Em\u003csup\u003e7\u003c/sup\u003e  | F\u003csup\u003e△7\u003c/sup\u003e  | G\u003csup\u003e7\u003c/sup\u003e | Am\u003csup\u003e7\u003c/sup\u003e |  G\u003csup\u003eo7\u003c/sup\u003e                | \n\n마찬가지로 vii\u003csup\u003eo7\u003c/sup\u003e는 감7화음인데, 표기에 마이너가 없어도 3음은 단3도이다.\n\n## 코드의 성질\n\n### 토닉\n\n우리말로 으뜸화음이라고 한다. 안정감을 주어 특히 곡의 끝에 많이 쓰인다.\n\n메이저에서는 I\u003csup\u003e△7\u003c/sup\u003e이 토닉이며, iii\u003csup\u003e7\u003c/sup\u003e과 vi\u003csup\u003e7\u003c/sup\u003e이 대리코드로 쓰일 수 있다.\n\n### 도미넌트\n\n우리말로 딸림화음이라고 한다. 불안정하며 토닉으로, 혹은 완전5도 아래로 진행하려는 성질이 있다.\n\n메이저에서는 V\u003csup\u003e7\u003c/sup\u003e이 도미넌트이며, vii\u003csup\u003eo7\u003c/sup\u003e이 대리코드로 쓰일 수 있다\n\n### 서브 도미넌트\n\n우리말로 버금딸림화음이라고 한다. 도미넌트보다는 덜하지만 토닉으로 진행하려는 성질이 있다.\n\n메이저에서는 IV\u003csup\u003e△7\u003c/sup\u003e이 서브 도미넌트이며, ii\u003csup\u003e7\u003c/sup\u003e이 대리코드로 쓰일 수 있다.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%84-%EB%8B%AC%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95":{"title":"다형성을 달성하는 방법","content":"\n- [9가지 프로그래밍 언어로 배우는 다형성](https://tech.devsisters.com/posts/programming-languages-2-polymorphism/)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4":{"title":"","content":"씨\n---\ntitle: 데이터베이스\ntags: [데이터베이스, PostgreSQL]\n---\n\n- [[ROLE 관리하기]]\n- [[PostgreSQL]]\n\n## 참고\n\n- 한양미, [데이터베이스의 원리와 응용](http://www.kocw.net/home/search/kemView.do?kemId=1163794). 한양대학교, 2015.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1":{"title":"동시성과 병렬성","content":"\n\n\u003e 동시성은 여러 일을 한꺼번에 다루는 것이다.\n\u003e 병렬성은 여러 일을 한꺼번에 해내는 것이다.\n\u003e - [롭 파이크](https://go.dev/blog/waza-talk)\n\n## 동시성\nconcurrency. 일부에서는 병행성이라 부르기도 한다. 병렬성과의 명확한 구분을 위해 동시성이라 부르자.\n- 논리적 개념.\n- 병렬적이지 않더라도 동시적일 수 있다.\n- 따라서 싱글 코어 CPU도 동시성을 달성할 수 있다.\n\t- 이거했다 저거했다 하면 된다.\n- 액터, 스레드 등 [[동시성을 다루는 방법|동시성 모델]]로 실현한다.\n\n## 병렬성\nparallelism.\n- 물리적 개념.\n- 실제로 작업이 동시에 처리된다.\n- 다중 코어, 분산 시스템 등을 이용하여 실현.\n- 병렬적이려면 동시적이어야한다.\n\n## 참고\n- Rob Pike, [Concurrency is not Parallelism](https://www.youtube.com/watch?v=oV9rvDllKEg), 2015.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95":{"title":"동시성을 다루는 방법","content":"\n[[동시성과 병렬성]]의 차이는 문서 참고\n\n## 동시성이 필요한 이유\n\n- 실세계가 동시적이기 때문에\n\t- 프로그램은 좋든 싫든, 의도했든 안했든 실세계와 상호작용한다. 그 실세계가 동시적이므로 동시성이 필요하다.\n\t- 동시성이 없다면 파일을 받으며 마우스를 움직일 수 없다.\n- 더 나은 성능을 위해\n\t- 한 번에 하나의 요청만 처리할 수 있는 서버는 성능이 좋지 못하다.\n\t- 현대 프로그램에서는 I/O에서 버리는 시간이 많다.\n\t- 결과를 기다리는 동안 다른 일을 할 수 있다면 좋을 것이다.\n\t- 성능 향상을 보장하지는 않는다. 동시성을 실현하기 위한 비용이 더 클 수도 있다.\n\n## 동시성을 다루는 방법\n\n오늘날의 운영체제는 프로그램을 [[프로세스]] 단위로 실행하며 멀티태스킹한다.\n\n운영체제는 [[멀티태스킹#선점형 멀티태스킹|선점형 멀티태스킹]]으로 프로세스와 스레드를 스케줄한다. 선점형\n멀티태스킹에서는 제어권이 바뀌는 시점을 어플리케이션이 제어할 수 없다. 이로 인하여 공유 메모리에 서로 다른 제어 주체가\n의도치 않게 접근하여 예기치 못한 오류가 발생할 수 있다. 이를 [[동시성 관련 용어|경쟁 위험]]이라고 하며 경쟁 위험을 막기 위한\n여러 동시성 모델(*concurrency model*)이 있다.\n\n\"코딩을 지탱하는 기술\"에서는 경쟁 위험을 막기 위한 방법을 크게 세 가지로 구분한다:\n\n1. 공유하지 않기\n2. 변경하지 않기\n3. 끼어들지 않기\n\n### 공유하지 않기\n\n공유하지 않으면 문제될 것이 없다.\n\n- 운영체제는 [[#프로세스]]를 동시적으로 실행한다. 각 프로세스는 서로 메모리를 공유하지 않는다.\n- [[#액터]] 모델은 프로세스와 비슷하다. 한 프로세스 내에서 실행되는 여러 액터들은 서로 메모리를 공유하지 않는다.\n\t필요한 경우 메시지를 교환한다.\n- [[#CSP]]도 비슷하다. 메모리를 공유하지 않고 채널을 만들어 메시지로 보낸다.\n\n### 변경하지 않기\n\n변경하지 않으면 공유해도 문제가 없다.\n\n- 여러 함수형 언어에서 할당한 값은 기본적으로 불변이다. 값이 바뀌지 않으므로 공유해도 문제가 없다.\n\t하스켈, 엘릭서 등의 언어가 이에 해당한다.\n- 모든 값을 불변으로 다루는 것이 어렵다면, 적어도 불변을 장려한다. 러스트, 스칼라, 스위프트 등의 언어는\n\t그 전에 만들어진 언어들보다 불변 선언이 자연스럽도록 설계되었다.\n\n### 끼어들지 않기\n\n공유하고 변경하더라도 타이밍만 잘 맞다면 문제가 없다.\n\n- 운영체제가 아니라 애플리케이션 수준에서 직접 작업을 스케쥴링한다.\n\t[[#그린 스레드]], 파이버, 코루틴 등이 이에 해당한다.\n- 작업 중인 메모리에 작업 중이라고 표시하여 다른 작업이 끼어들지 않도록 한다. [[#락]], 뮤텍스, 세마포어, 싱크로나이즈, STM 등이 이에 해당한다.\n\n## 프로세스\n\n스레드\n\n[[프로세스 간 통신]]\n\n## 액터\n\n프로그램을 액터(*actor*)와 액터 사이의 의사소통으로 본다. 각 액터는 동시에 돌아가며 정보 공유는 메시지 전달을 통해 이루어진다.\n\n## 채널\n\nCSP는 순차 프로세스 통신(*communicating sequential process*)의 약어이다. 스레드 사이에서 메시지를 통해 값을 공유한다는 점에서 액터와 유사하다. 액터가 메시지를 주고 받는 주체인 액터에 초점을 맞춘 것에 비해, CSP는 메시지를 주고 받는 채널에 초점을 맞추었다.\n\n고 언어에서 언어 수준에서 지원하며 많은 주목을 받았다.\n\n\u003e Do not communicate by sharing memory; instead, share memory by communicating.\n\u003e \n\u003e 공유 메모리로 communication하지말자. communication하여 메모리를 공유하자.\n\u003e\n\u003e -- [Effective Go](https://go.dev/doc/effective_go#sharing)\n\n\n## 함수형 프로그래밍\n\n함수형 프로그래밍(*FP; functional programming*)에서는 불변 변수를 최대한 활용하고, [[부수 작용]]을 통제하는 프로그래밍 방법론이다.\n\n## 그린 스레드\n\n스레드와 비슷하게 쓸 수 있다. 프로그래밍 모델을 바꿀 필요가 없다. 스레드보다 오버헤드가 적어 많은 양의 그린 스레드를 만들 수 있다.\n\n## 스레드\n\n- 스레드는 이미 널리 쓰이는 개념이며 운영체제에서 지원한다.\n- 기존의 동기 코드나 라이브러리를 쉽게 이용할 수 있다.\n- 하지만 각 스레드를 서로 동기화 하는 것은 어렵고, 스레드를 생성하고 스위칭하는 비용도 비싸다. \n\n스레드 풀을 만들어 비용을 줄일 수도 있다.\n\n- 커널 스레드: 운영체제 커널이 스케줄링한다.\n- 유저 스레드: 프로세스가 직접 스레드를 스케줄링한다. 커널이 볼 때에는 일반적인 프로세스로 보인다.\n\n## 락\n\n교착 상태(*deadlock*)의 위험이 있다.\n\n### 교착 상태\n\n1.  상호 배제(*mutual exclusion*)\n2.  점유 상태로 대기 (Hold and wait)\n3.  선점 불가 (No preemption)\n4.  순환성 대기 (Circular wait)\n\n## STM\nSoftware transaction memory\nclojure.\n\n## 비동기 프로그래밍\nC#, rust, JS 등.\n\n비동기 프로그래밍은 오늘날 점점 더 많은 언어에서 지원하는 동시성 프로그래밍 모델이다. `async/await` 문법을 이용하여 코드가 동기적으로 보이도록 한다.\n\n적은 CPU, 메모리 오버헤드를 소모한다. 특히 서버나 DB 같은 많은 양의 IO 작업에 유리하다. 적은 수의 스레드를 런타임으로 활용하여 많고 비용이 적은 비동기 작업을 처리할 수 있다.\n\n## 이벤트 기반 설계\n이벤트 기반 설계(*event driven architecture*) 혹은 이벤트 루프는 성능이 우수하며 스레드 수가 적어도 데이터 흐름과 오류 전파를 따라가기 힘들다.\n\n자바스크립트에서 주로 사용한다.\n\n## observerable\nRxSwift, RxJs 등\n\n## 참고\n\n- 니시오 히로카즈, 코딩을 지탱하는 기술 : 원리로 깨우치는 프로그래밍 기법, 2013.\n- 폴 부처, 7가지 동시성 모델, 2016.\n- [Clojure Concurrency Tutorial for Beginners with Code Examples](https://ericnormand.me/guide/clojure-concurrency#threadsjvm)\n- [동시성 프로그래밍 하기 좋은 Clojure](https://www.slideshare.net/eunminn/clojure-68804824)\n- [[Track 1-2] 유인동 - ES6+ 비동기 프로그래밍과 실전 에러 핸들링](https://www.youtube.com/watch?v=o9JnT4sneAQ)\n- [[Track 2-2] 나석주 - 비동기를 우아하게 처리하기 위한 Observable](https://www.youtube.com/watch?v=oHF8PEkteq0)\n- [Why Async? - Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/01_getting_started/02_why_asy\u001b[\u003c43;66;8Mnc.html)\n- [데브시스터즈 서버 직군은 왜 코딩 면접을 볼까?](https://tech.devsisters.com/posts/server-position-coding-test/)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4":{"title":"동시성 관련 용어","content":"## 공유 자원\n\n시스템 안에서 여러 스레드나 프로세스가 함께 접근할 수 있는 자원을 공유 자원(*shared resource*)이라고 한다.\n\n## 임계 영역\n\n공유 자원에 접근하는 코드들을 임계 영역(*critical section*)이라고 한다.\n\n[[#상호 배제]] 등의 기법으로 임계 영역에 하나의 쓰레드만이 진입하도록 보장해야한다.\n\n임계 영역이 제대로 설정되지 않으면 아래와 같은 문제가 발생할 수 있다:\n- 입출금 문제\n\n## 경쟁 상태\n\n여러 스레드가 동시에 임계 영역에 접근하여 발생하는 문제를 경쟁 상태(*race condition*) 혹은 경쟁 위험(*race hazard*)라고 한다.\n\n## 상호 배제\n\n[[#임계 영역]]에 한 개의 프로세스만 진입할 수 있도록, 즉 원자적으로 실행할 수 있도록 하는 기법을 상호 배제(*mutual exclution*)라고 한다.\n\n임계 영역을 잠궈서 원자적으로 다룰 수 있다. 이를 락(*lock*)이라고 부르며 락을 구현한 자료구조나 스마트 포인터를 흔히 mutex라고 부른다.\n\n```rust\n// 상호 배제가 가능한 변수를 선언한다.\nlet m = Mutex::new(5);\n{\n    // 변수에 접근하기 전에 먼저 임계 영역을 잠근다.\n\tlet mut num = m.lock().unwrap();\n\t\n\t// 변수에 마음대로 접근할 수 있다.\n\t*num = 6;\n\n    // 러스트에서는 블록이 끝나면 자동으로 잠금을 푼다.\n}\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC":{"title":"딕셔너리","content":"\n검색, 삽입, 삭제 세 가지 연산을 지원하는 동적 집합을 딕셔너리라고 부른다.\n\n흔히 딕셔너리라고 하면 아래와 같이 키와 그에 대응하는 값들이 모인 키-값 쌍의 모음을 떠올린다:\n\n```python\ndic = {'alice': [1, 2, 3], 'bob': 42}\n## dic['alice'] = [1, 2, 3]\n```\n\nADT로서 정의하고자 하는 딕셔너리는 이보다 더 일반적이다. 파이썬의 딕셔너리도 검색, 삽입, 삭제가 가능하므로 딕셔너리 ADT의 구현체라고 할 수 있다. 더 넓게 보면 배열이나 연결 리스트와 같은 선형 리스트나 이진 탐색 트리도 마찬가지로 검색, 삽입, 삭제가 가능한 동적 집합이므로 딕셔너리이다.\n\n수많은 일반적인 데이터 처리는 딕셔너리의 연산으로 처리할 수 있다. 딕셔너리라는 ADT를 정의함으로서 일반적인 데이터 처리 알고리즘을 표현할 기준이 생기고, 또한 어떤 구현체가 해당 알고리즘에 효과적인지 손쉽게 분석할 수 있다.\n\n그래도 딕셔너리면 키-값 쌍이여야 하는 거 아니야? 선형 리스트면 키-값 쌍이 아니잖아? 라는 생각이 든다면 맘 편히 키값이 값과 같다고 생각해도 좋고, 키가 인덱스와 같다고 생각해도 좋다.\n\n```ruby\nlinear_list_0 = { 0 =\u003e '철수', 1 =\u003e '영희', 2 =\u003e '명수', 3 =\u003e '상수'}\nlinear_list_1 = { '철수' =\u003e '철수', '영희' =\u003e '영희', '명수' =\u003e '명수', '상수' =\u003e '상수'}\nlinear_list_2 = ['철수', '영희', '명수', '상수']\n```\n\n### 연산\n\n아래의 정의는 \"The Algorithm Design Manual\"과 \"Introduction to Algorithms\"을 참고하였다.\n\n- $\\operatorname{Search}(D, k)$: 딕셔너리 $D$에서 키 $k$에 대응하는 원소의 포인터를 반환한다.\n- $\\operatorname{Insert}(D, x)$: 딕셔너리 $D$의 집합에 포인터 $x$가 가리키는 원소를 추가한다.\n- $\\operatorname{Delete}(D, x)$: 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소를 삭제한다. (키값이 아닌 원소 $x$에 대한 포인터임에 유의한다.)\n- $\\operatorname{Min}(D)$: 딕셔너리 $D$에서 가장 키값이 작은 원소을 반환한다.\n- $\\operatorname{Max}(D)$: 딕셔너리 $D$에서 가장 키값이 큰 원소을 반환한다.\n- $\\operatorname{Successor}(D, x)$: 정렬된 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소의 다음 원소를 반환한다.\n- $\\operatorname{Predecessor}(D, x)$: 정렬된 딕셔너리 $D$에서 포인터 $x$가 가리키는 원소의 이전 원소를 반환한다.\n\n위의 연산은 딕셔너리의 내용을 바꾸는 수정연산($\\operatorname{Insert}$, $\\operatorname{Delete}$)과 내용을 바꾸지 않는 탐색연산($\\operatorname{Search}$, $\\operatorname{Max}$, $\\operatorname{Min}$, $\\operatorname{Successor}$, $\\operatorname{Predecessor}$)으로 나눌 수 있다.\n\n### 구현\n\n- 선형 리스트로 구현할 수 있다.\n- 이진 탐색 트리를 이용하여 구현할 수 있다.\n- 해시 테이블을 이용하여 구현할 수 있다.\n\n#### 선형 리스트\n\n선형 리스트로 구현한다면 정렬의 유무에 따라 효과적인 연산이 달라진다. 정렬하지 않을 경우 수정연산이 효과적이고, 정렬할 경우 탐색연산이 효과적이다.\n\n| 연산                                 | unsorted array | sorted array | unsorted linked list (s/d) | sorted linked list (s/d) |\n|------------------------------------|:--------------:|:------------:|:--------------------------:|:------------------------:|\n| $\\operatorname{Search}(D, k)$      |     $O(n)$     | $O(\\log n)$  |      $O(n)$ / $O(n)$       |     $O(n)$ / $O(n)$      |\n| $\\operatorname{Insert}(D, x)$      |     $O(1)$     |    $O(n)$    |      $O(1)$ / $O(1)$       |     $O(n)$ / $O(n)$      |\n| $\\operatorname{Delete}(D, x)$      |     $O(1)$     |    $O(n)$    |     $O(n)^*$ / $O(1)$      |    $O(n)^*$ / $O(1)$     |\n| $\\operatorname{Min}(D)$            |     $O(n)$     |    $O(1)$    |      $O(1)$ / $O(n)$       |     $O(1)$ / $O(1)$      |\n| $\\operatorname{Max}(D)$            |     $O(n)$     |    $O(1)$    |      $O(1)$ / $O(n)$       |    $O(1)^*$ / $O(1)$     |\n| $\\operatorname{Successor}(D, x)$   |     $O(n)$     |    $O(1)$    |      $O(n)$ / $O(n)$       |     $O(1)$ / $O(1)$      |\n| $\\operatorname{Predecessor}(D, x)$ |     $O(n)$     |    $O(1)$    |      $O(n)$ / $O(n)$       |    $O(n)^*$ / $O(1)$     |\n\n연결 리스트도 단순이냐, 이중이냐에 따라 연산의 비용이 달라진다. 단순일 경우 다음 노드를 찾기 쉬우나, 이전 노드를 찾기 위해서는 결국 순회해야 하므로 $O(n)$의 비용이 든다.\n이중 연결 리스트는 이전 노드에 대한 정보도 함께 갖고 있으므로 삭제 연산의 비용이 $O(1)$으로 줄어들며, 정렬되었을 경우 $\\operatorname{Predecessor}$ 연산도 $O(1)$으로 줄어든다.\n\n#### 이진 탐색 트리\n\n| 연산                                 | binary search tree |\n|------------------------------------|:------------------:|\n| $\\operatorname{Search}(D, k)$      |       $O(\\log n)$       |\n| $\\operatorname{Insert}(D, x)$      |       $O(\\log n)$       |\n| $\\operatorname{Delete}(D, x)$      |       $O(\\log n)$       |\n| $\\operatorname{Max}(D)$            |       $O(\\log n)$       |\n| $\\operatorname{Min}(D)$            |       $O(\\log n)$       |\n| $\\operatorname{Successor}(D, x)$   |       $O(\\log n)$       |\n| $\\operatorname{Predecessor}(D, x)$ |       $O(\\log n)$       |\n\n### 참고\n\n- Steven S.Skiena. \"The Algorithm Design Manual\" 2008.\n- Thomas H.Cormen et al. \"Introduction to Algorithms\" 2009.\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%9F%AC%EC%8A%A4%ED%8A%B8":{"title":"러스트","content":"\n\n[rfcs/0230-remove-runtime.md at master · rust-lang/rfcs · GitHub](https://github.com/rust-lang/rfcs/blob/master/text/0230-remove-runtime.md)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%9F%B0%ED%83%80%EC%9E%84":{"title":"런타임","content":"\n## C언어\n\n- [The C Runtime Initialization](https://www.embecosm.com/appnotes/ean9/html/ch05s02.html)\n\n## 러스트\n\n비용 없는 추상화, GC 없는 메모리 안전성을 목표로 하는 만큼 런타임이 굉장히 작으나 없지는 않다.\n\n언어 자체에는 최소한의 런타임만 구현되어있다. [레퍼런스](https://doc.rust-lang.org/reference/runtime.html)를 보면 \n\n[rfcs/0230](https://github.com/rust-lang/rfcs/blob/master/text/0230-remove-runtime.md)을 보면 예전에는 `librustrt`라는 이름의 런타임이 있었으나 현재는 완전 삭제되었다.\n\n시스템 프로그래밍 언어인 만큼 필요에 따라 런타임을 선택할 수 있다. 커뮤니티 레벨에서 다양한 런타임이 있다:\n\n- [tokio](https://tokio.rs/) 같은 비동기 런타임.\n- [actix](https://github.com/actix/actix) 같은 액터 런타임.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%A7%A5%EB%B6%81%EC%97%90%EC%96%B4-M1-2020":{"title":"맥북프로 에어 (M1, 2020)","content":"\n- [[macOS]] 참고","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%A7%A5-%EC%83%88%EB%A1%9C-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0":{"title":"맥 새로 설치하기","content":"\n\n## 백업하기\n\n### git으로 백업하기\n\n각종 dotfile을 [nyeong/.dotfiles](https://github.com/nyeong/.dotfiles) 저장소에서 관리하고 있으므로 변경사항이 있을 경우 커밋하고 푸시한다.\n\n### USB에 백업하기\n\n#### GPG키\n\nGPG 비밀키를 백업해둔다. `--export-secret-key` 옵션으로 백업할 수 있다.\n\n```bash\ngpg --export 08449CDA3E96702E455ED97665DB925EBFCD29EA \u003e public.key\ngpg --export-secret-key 08449CDA3E96702E455ED97665DB925EBFCD29EA \u003e private.key\n```\n\n#### SSH키\n    \n`~/.ssh` 디렉토리 자체를 백업하자.\n    \n#### Brewfile\n\nBrew로 깐 프로그램 일람. `brew bundle dump`로 생성할 수 있다.\n\n## 부팅 디스크 만들기\n\n부팅 디스크로 만들 USB를 꽂은 후 Disk Utility로 적당히 이름 짓고 포맷한 후 아래의 명령어로 부팅 디스크를 만든다:\n\n```bash\nsudo /Applications/Install\\\\ macOS\\\\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/installer\n```\n\n## 적당히 클린 인스톨\n\n1. Apple Silicon이 탑재된 맥북은 전원버튼을 꾹 누르면 세부 부팅 옵션이 나온다. 위에서 만든 부팅 디스크로 들어가자.\n2. Disk Utility 켜서 본래의 저장공간을 지운다.\n3. 지운 볼륨에 새로 설치한다.\n\n## 본격적으로 설정\n\n### 터미널 설정\n\n1.  기본 개발 도구 설치 (xcode command line tool)\n2.  패키지 매니저 설치 (brew)\n3.  기본 도구들 설치하고 dotfile 불러오기\n\n### 백업 가져오기\n\n#### SSH키\n그대로 `~/.ssh`에 가져다놓기\n\n#### GPG키\n`gpg --import private.key`    \n\n#### Brewfile\n`brew bundle --file`","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%A7%A5-%EC%9E%90%EC%9E%98%ED%95%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0":{"title":"맥 자잘한 설정하기","content":"\n\n## 런치패드\n\n기본앱 폴더 하나 만들어서 모조리 넣어버리자.\n\n## 독 조절하기\n\n-   독에 있는 모든 것을 없애기\n    아이콘을 밖으로 드래그하면 없앨 수 있다\n    \n-   시스템 설정 → 데스크탑 및 Dock에서\n    -   Dock에서 최근 사용한 응용 프로그램 보기 끄기\n\n## 미션 컨트롤\n\n시스템 설정 → 데스크탑 및 Dock에서\n-   Spaces를 최근 사용 내역에 따라 자동으로 재정렬 끄기\n\n## 시간\n\n시스템 설정 → 일반 → 날짜 및 시간에서 24시간제 켜기\n\n## 키보드\n\n시스템 설정 → 키보드에서\n\n-   키 반복 속도를 적당히 빠르게 설정\n-   반복 지연 시간을 적당히 짧게 설정\n-   키보드 탐색 켜기\n-   텍스트 입력 → 편집…에서\n    -   Caps Lock키로 ABC 입력 소스 전환 끄기\n    -   맞춤법 자동 수정 끄기\n    -   자동으로 단어를 대문자로 시작 끄기\n    -   스페이스를 두 번 눌러 마침표 추가 끄기\n    -   스마트 인용 부호 및 대시 사용 끄기\n    -   큰따옴표를 가장 마지막 것으로 변경\n    -   작은따옴표를 가장 마지막 것으로 변경\n-   키보드 단축키…에서\n    -   보조 키에서 Caps Lock을 Escape로\n\n## 트랙패드\n\n시스템 설정 → 트랙패드에서\n\n-   클릭을 가볍게로 바꾸기\n-   탭하여 클릭하기를 끄기\n\n[세 손가락으로 드래그하기](https://www.notion.so/898f816ac20e4ca5bd34f34fae71da50)\n\n시스템 설정 → 데스크탑 및 Dock에서 아래로 쭉 내려서 Mission Control에서 핫 코너…를 눌러서\n\n-   오른쪽 아래에 빠른 메모를 `-`로 바꾸기\n\n## 보안 관련\n\n시스템 설정 → 화면 잠금에서\n\n-   화면 보호기 시작 후 또는 디스플레이가 꺼진 후 암호 요구를 즉시로 바꾸기\n\n시스템 설정 → 네트워크 → 방화벽에서 방화벽 켜기\n\n## 호스트 이름 바꾸기\n\n시스템 설정 → 일반 → 공유에서\n\n가장 밑의 호스트 이름 → 편집… 눌러서 적당한 이름으로 변경\n\n## 파인더 설정\n\nFinder에서 커맨드+, 눌러서 설정 열어서\n\n-   새로운 Finder 윈도우에서 보기를 홈폴더로 변경 (계정명과 동일한 폴더)\n\nFinder 설정 고급에서\n\n-   모든 파일 확장자 보기 켜기\n-   iCloud Drive에서 제거하기 전에 경고 표시 끄기\n-   폴더 우선 정렬에서 윈도우에서와 데스크탑에서 모두 켜기","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9":{"title":"멀티태스킹","content":"\n\n스케줄링 방식에 있어, 제어권을 누가 갖느냐로 크게 둘로 나눈다.\n\n## 협력형 멀티태스킹\nCooperative multitasking. 혹은 비선점(*non-preemptive*) 멀티태스킹으로 부르기도 한다.\n\nWindows 3.1, Mac OS 9 등 고전 운영체제에서 사용했던 방법으로 운용프로그램이 자발적으로 제어권을 반환하는 방법. 운용프로그램이 제어권을 독점할 문제가 있다.\n\n## 선점형 멀티태스킹\nPreemptive multitasking.\n\n운영체제의 스케줄러에 의하여 제어권을 관리하는 방법. 상당히 짧은 시간에 한하여 제어권을 인계하고 도로 가져간다. 오늘날 대부분의 운영체제에서 사용한다.\n\n구현을 위하여 하드웨어 타이머, 스케줄러 등이 필요하다. 서로 다른 프로세스가 한 자원에 접근하려 하는 경우 [[동시성 관련 용어]]가 생길 수 있다.\n\nTODO: 시분할과는 무엇이 다른가\n\n## 용어에 대하여\n\n언뜻 보면 선점형 멀티태스킹은 먼저 제어권을 선점한 프로세스가 맘껏 연산장치를 쓸 수 있을 것처럼 보인다. 실은 스케줄러에 의해 제어권을 관리한다.\n\n일본어권에서는 선점형이라는 말보다는 preemptive multitasking을 그대로 음차하여 プリエンプティブマルチタスク라고 부르거나 非協調的(비협력적)이라고 부르는 듯하다.\n\n협력적 멀티태스킹을 疑似(의사) 멀티태스킹이라고 부르기도 한다.\n\n\u003e The term \"preemptive multitasking\" is sometimes mistakenly used when the intended meaning is more specific, referring instead to the class of scheduling policies known as _time-shared scheduling_, or _[time-sharing](https://en.wikipedia.org/wiki/Time-sharing \"Time-sharing\")_. - [Preemption (computing)](\u003chttps://en.wikipedia.org/wiki/Preemption_(computing)\u003e)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%AA%A8%EB%93%88-%EC%A7%80%EC%8B%9C%EC%9E%90":{"title":"모듈 지시자","content":"\n\nModule Directives. 모듈을 합성하기 때문에 composition이라고 부르기도 하는 듯.\n\n## alias\n\n모듈에 별칭을 붙일 때 쓴다.\n\n```elixir\ndefmodule Sangatsu.State do\n  def new, do: \"어쩌구\"\nend\n\n## 아무것도 없다면\nstate = Sangatsu.State.new()\n\n## alias를 쓴다면\nalias Sangatsu.State\nstate = State.new()\n\n## `as`와 함께 쓴다면\nalias Sangatsu.State, as: S\nstate = S.new()\n```\n\n## import\n\n다른 모듈의 함수와 매크로를 불러올 때 쓴다.\n\n```elixir\n## 다 불러오면\nimport Sangatsu.State\nstate = new()\n\n## 불러올 함수 선택하기\nimport Sangatsu.State, only: [new: 0]\nstate = new()\n\nimport Sangatsu.State, expect: [other: 1]\nstate = new()\n```\n\n기본적으로 `import` 하지 않아도 `List` 모듈의 함수를 쓰는 데에는 지장이 없음. 다만 `List.duplicate`처럼 모듈을 명시해주어야함.\n\n## require\n\n해당 모듈이 컴파일 된 후에 불러옴\n\n```elixir\nrequire Sangatsu.State\n## Sangatsu.State가 컴파일 된 후에 이 코드가 실행됨이 보장된다.\n```\n\n## use\n\n해당 모듈의 콜백을 사용. 클래스 상속같은 느낌으로 쓴다.\n\n```elixir\ndefmodule Sangatsu.State do\n  defmacro __using__(_opts) do\n    quote do\n      # 어쩌고\n    end\n  end\nend\n\ndefmodule MySangatsu.State do\n  use Sangatsu.State\n  # Sangatsu.State.__using__ 콜백이 실행되었음\nend\n```\n\n## 참고\n\n[Making Sense of Elixir Directives](https://github.com/rwdaigle/elixir-directives)\n[alias, require, and import -- elixir Getting Started](http://elixir-lang.org/getting-started/alias-require-and-import.html)\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%AF%B8%EB%B6%84":{"title":"미분","content":"\n$$\nf'(x)=\\lim_{h\\rightarrow0}\\frac{f(x+h)-f(x)}{h-0}\n$$\n\n## 의미\n\n- 함수 $f(x)$에 대해서\n\t-  $f'(x)$는 순간적인 기울기를 나타낸다.\n\t-  $0 \u003c f'(x)$이면 $f(x)$는 증가하며, $0 \u003e f'(x)$이면 $f(x)$는 감소한다.\n\t- $f''(x)$는 \u0008$f(x)$의 기울기가 증가세인지 감소세인지 나타낸다.\n- 함수의 최대, 최소값을 구할 수 있다.\n\n## 편미분\n\n- 변수가 하나인 함수에 대한 미분을 **상미분**이라고 한다.\n- 변수가 여러개인 다변수함수에 대한 미분을 **편미분**이라고 한다.\n- 여기서 $\\delta$는 델타이며 델 혹은 round d라고도 읽는다.\n\n벡터 $\\mathbf{x}$를 인자로 받는 함수 $f$를 기저 $\\mathbf{e}_i$에 대하여 미분.\n\n$$\n\\delta_{x_i} f(\\mathbf{x})=\\lim_{h\\rightarrow0}\\frac{f(\\mathbf{x}+h\\mathbf{e}_i)-f(\\mathbf{x})}{h}\n$$","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%B2%A0%EC%9D%B4%EC%A6%88-%EC%A0%95%EB%A6%AC":{"title":"베이즈 정리","content":"\n사건 $\\mathcal E$가 발생함에 따라 $P(\\theta)$가 어떻게 변화하는가에 대한 정리.\n\n$$\nP(\\theta|\\mathcal E) = \\frac{P(\\mathcal E|\\theta)P(\\theta)}{P(\\mathcal E)}\n$$\n- $P(\\theta|\\mathcal E)$ — 사후확률(posterior): 사건 $\\mathcal E$를 알고 난 후의 확률.\n- $P(\\mathcal E | \\theta)$ — 가능도(likelihood)\n- $P(\\theta)$ — 사전확률(prior): 사건 $\\mathcal E$를 알기 전의 확률.\n- $P(\\mathcal E)$ — 증거(evidence)\n\n`사후확률 = 가능도 × 사전확률 / 증거`로 쉽게 생각할 수 있다.\n\n새로운 데이터가 들어왔을 때, 기존의 사후확률을 사전확률로 활용하여 새롭게 사후확률을 갱신할 수 있다.\n\n\n## 증명\n\n$$\n\\begin{align}\n\tP(\\theta|\\mathcal E) \u0026= \\frac{P(\\theta \\cap \\mathcal E)}{P(\\mathcal E)}, \\text{if }P(\\mathcal E) \\neq 0 \\\\\n\tP(\\mathcal E | \\theta) \u0026= \\frac{P(\\theta \\cap \\mathcal E)}{P(\\theta)}, \\text{if }P(\\theta) \\neq 0 \\\\\n\tP(\\theta \\cap \\mathcal E) \u0026= P(\\mathcal E | \\theta)P(\\theta) \\\\\n\t\\therefore P(\\theta|\\mathcal E) \u0026= \\frac{P(\\mathcal E|\\theta)P(\\theta)}{P(\\mathcal E)}\n\\end{align}\n$$","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%B2%A1%ED%84%B0":{"title":"벡터","content":"\n해당 글은 벡터를 써먹기 위해 정리한 것으로, 엄밀하지 못하거나 다소 틀린 정의가 포함되어있을 수 있습니다.\n\n벡터는 수를 나열한 것이다.\n\n- 가로로 쓴 것을 행벡터 혹은 횡벡터\n- 세로로 쓴 것을 열벡터 혹은 종벡터\n\n$$\n\\mathbf{v} = \\begin{bmatrix}\n1 \\\\\n2 \\\\\n3\n\\end{bmatrix}\n\n\\mathbf{v}^T = \\begin{bmatrix}1, 2, 3\\end{bmatrix}\n$$\n## 의미\n\n- $n$개의 수의 나열.\n- $n$차원 공간에서 원점$O$로부터의 화살표.\n\t- 2~3차원만 다룰 것이 아니므로 특정 차원에 얽매이지 말아야 한다.\n\n## 표기\n\n굵은 소문자 쓰거나($\\mathbf{v}$) 소문자 위에 화살표를 그린다($\\vec{v}$).\n\nLaTex에서 성분을 표기할 때에는 `bmatrix`를 이용하여 표기한다.\n\n```latex\n\\mathbf{v}^T = \\begin{bmatrix}1, 2, 3\\end{bmatrix}\n```\n\n## 성분\n\n- $x_i$: 벡터를 구성하는 각각의\u001f수.\n- 차원: 성분의 개수.\n\n## 연산\n\n대부분의 연산이 차원이 같아야 정의된다.\n\n- $\\mathbf{x}^T$전치 (transpose)\n- $\\mathbf{x}\\pm\\mathbf{y}$: 차원이 같은 벡터끼리의 덧셈, 뺄셈.\n- $\\mathbf{x} \\circ \\mathbf{y}$: 성분곱(hadamard product)\n- $c\\mathbf{x}$: 정수배 (스칼라배)\n- $\\langle \\mathbf{x}, \\mathbf{y} \\rangle$: 내적(inner product)\n- 외적(outer product)\n\n### 전치\n\n횡벡터를 종벡터로, 종벡터를 횡벡터로 바꾼다.\n\n### 정수배\n\ndot product를 스칼라곱이라고 하는 경우가 있기에 스칼라**배**라고 부른다.\n\n$$\nc \\mathbf{v} = \\begin{bmatrix}ㅇcv_1\\\\ \\dots \\\\ cv_d\\end{bmatrix}\n$$\n\n### 덧셈, 뺄셈\n\n$$\n\\mathbf{x}\\pm \\mathbf{y}=\\begin{bmatrix}x_1\\pm y_1 \\\\ \\cdots \\\\ x_d \\pm y_d\\end{bmatrix}\n$$\n\n\n\n### 성분곱\n\n아다마르 곱이라고도 한다.\n\n$$\n\\mathbf{x} \\bigcirc \\mathbf{y}=\\begin{bmatrix}x_1y_1  \\\\ \\cdots \\\\ x_dy_d\\end{bmatrix}\n$$\n\n### 내적\n\ninner product. 대응하는 성분끼리 곱한 것을 모두 더한 것.\n\n결과가 스칼라이기 때문에 스칼라곱이라고도 부르고, 연산 기호로 $\\cdot$을 쓰기에 dot product라고도 부른다.\n\n\n$$\n\\begin{align}\n\\langle \\mathbf{x}, \\mathbf{y} \\rangle \u0026 = \\sum^{d}_{i=1}x_iy_i \\\\\n\t\u0026 = x_1y_1 + x_2y_2 + \\cdots + x_dy_d\n\\end{align}\n$$\n\n기하적으로는 두 벡터 사이의 각이 $\\theta$일 때 내적은 아래와 같으므로 이를 이용해 두 벡터 사이의 각을 구할 수 있다. 이때의 코사인값 $\\cos \\theta$를 **코사인 유사도**라고 부르며 $\\cos(\\mathbf{x}, \\mathbf{y})$라고 쓴다.\n\n$$\n\\begin{align}\n\t\\langle \\mathbf{x}, \\mathbf{y}\\rangle \u0026= \\|\\mathbf{x}\\|_2\\|\\mathbf{y}\\|_2\\cos \\theta \\\\\n\t\\cos(\\mathbf{x},\\mathbf{y})=\\cos \\theta \u0026= \\cfrac{\\langle \\mathbf{x}, \\mathbf{y}\\rangle}{\\|\\mathbf{x}\\|_2\\|\\mathbf{y}\\|_2}\n\\end{align}\n$$\n\n- $\\cos(\\mathbf{x}, \\mathbf{y})=0$이면 두 벡터는 직교한다.\n- $\\cos(\\mathbf{x}, \\mathbf{y})=1$이면 두 벡터는 같은 방향으로 평행하다.\n- $\\cos(\\mathbf{x}, \\mathbf{y})=-1$이면 두 벡터는 반대 방향으로 평행하다.\n- 코사인 유사도가 1에 가까울수록 두 벡터는 서로 유사하다고 볼 수 있다.__\n\n```elixir\ndefn angle(x, y) do\n  import Nx.LinAlg.norm\n  v = Nx.dot(x, y) / (norm(x) * norm(y))\n  Nx.acos(v)\nend\n```\n\n## 노름\n\n벡터의 크기를 측정하는 방법. 절댓값이 수의 크기를 측정하는 방법이라고 생각하고 대응하면 이해하기 편하다.\n\n$$\n\\|v\\|_p = (\\sum^{d}_{i=1}|v_i|^p)^{\\cfrac{1}{p}}\n$$\n- L1 노름: 절대값의 합.\n- L2 노름: $n$차원 공간에서의 길이.\n\n### L1 노름\n\n$$\n\\|v\\|_1 = \\sum^{d}_{i=1}|v_i|\n$$\n\n맨하탄 노름(manhattan norm)이라고도 한다.\n\nL1 노름을 거리로 정의하면 원은 ${x: \\|x\\|_1=1}$로 정의되는데 이는 아래처럼 생겼다.\n\n![[../assets/l1-norm-circle.webp]]\n\n### L2 노름\n\n$$\n\\|v\\|_1 = \\sqrt{\\sum^{d}_{i=1}|v_i|^2}\n$$\n\n유클리드 공간에서의 거리이므로 유클리드 거리라고도 한다.\n\n## 참고\n\n- 히라오카 카즈유키, *프로그래머를 위한 선형대수*. 길벗, 2017.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%B2%A1%ED%84%B0%EC%99%80-%EC%8A%A4%EC%B9%BC%EB%9D%BC":{"title":"벡터와 스칼라","content":"\n\n어떤 용어는 여러 학문을 드나들며 폭넓게, 그러나 조금 다르게 쓰이곤 한다. 벡터와 스칼라도 그렇다.\n\n## 수학에서\n\n아래와 같이 벡터끼리의 합과 스칼라 배가 잘 정의된 집합을 벡터공간이라고 하는데, 벡터공간의 원소를 벡터라고 한다.\n\n$u, v, w \\in V, a, b \\in F$라고 할 때:\n- 결합법칙이 성립해야한다.\n\t- $u + (v + w) = (u + v) + w$\n- 교환법칙이 성립해야한다.\n\t- $u + v = v + u$\n- 항등원이 있어야 한다.\n\t- $\\forall v \\in V$에 대하여 $v + 0 = 0$인 $0 \\in V$가 존재해야한다.\n- 역원이 있어야 한다.\n\t- $\\forall v \\in V$에 대하여 $v + (-v) = 0$인 $-v \\in V$가 존재해야한다.\n- 스칼라 배에 대해 분배법칙이 성립해야한다.\n\t- $a\\cdot\\left(u+v\\right)=a\\cdot u+a\\cdot v$\n\t- $(a+b)⋅v=a⋅v+b⋅v$\n- 스칼라 배에 대해 결합법칙이 성립해야한다.\n\t- $(ab) \\cdot v = a \\cdot (b \\cdot v)$\n- 스칼라 배에 대해 항등원이 있어야 한다.\n\t- $1\\cdot v = v$\n\n## 컴퓨터 과학에서\n\n- 스칼라: 산술 연산이 가능한 단일한 자료형\n- 벡터: 여러 값을 담을 수 있는 자료형\n\n벡터는 동적 배열을 뜻하는 용어로 널리 쓰이지만, 스칼라는 비교적 그렇지는 않다.\n\n### C에서\n\n[C11 표준](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf) 6.2.5절에서 다음과 같이 스칼라 타입을 정의한다.\n\n\u003e Arithmetic types and pointer types are collectively called scalar types. Array and structure types are collectively called aggregate types.\n\n### C++에서\n\n## 참고\n\n- [Vectors | Chapter 1, Essence of linear algebra - YouTube](https://www.youtube.com/watch?v=fNk_zzaMoSs)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%B6%80%EC%88%98-%EC%9E%91%EC%9A%A9":{"title":"부수 작용","content":"\nside effect. 보통은 부작용이라고 부른다. 부수 작용, 부수 효과, 부차 작용, 부차 효과로 부르기도 한다.\n\n본래 부작용은 副作用, 말 그대로 어떤 작용에 따라오는 부수적, 부차적인 작용을 일컫는다. 그러나 한글로 쓰면 “부”가 부(否)로 오해하기 쉬워 부정적 의미로 곡해된다. 즉 negative effect를 일컫는 것으로 오해하곤 하는데, negative effect는 부정 효과로 따로 불린다.\n\n컴퓨터 공학에서는 어떤 함수나 표현식 등이 책임 범위 밖의 상태를 변화하는 작용을 부수 작용이라고 부른다. *책임 범위 밖의 상태*는 밖에서 선언된 변수일 수도 있고, 전역 변수일 수도 있고, 파일을 읽거나 외부에 통신을 주고 받거나 마우스로 입력을 받는 등 아예 프로세스 밖과 소통하는 일이 될 수 있다.\n\n따라서 부수 작용 없이 유용한 프로그램을 짜기는 어려울 것이다. 하스켈 같은 언어에서는 타입을 이용하여 부수 작용이 있는 함수를 격리하고 명시한다. [왜 하스켈인가 - xtendo.org](https://xtendo.org/haskell/ko/why) 참고.\n\n부수 작용이 없는 함수나 식은 [[참조 투명성]]을 만족하며, 순수하다고 부른다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%9F%AC%EC%8A%A4%ED%8A%B8":{"title":"비동기 러스트","content":"\n## 채널\n\n러스트에서는 `std::sync::mpsc` 모듈로 채널이 내장되어있다. mpsc란 Multi-producer, single-consumer queue의 약어이다. 말 그대로 여러 곳에서 보낼 수 있으나 단 한 곳에서만 받을 수 있다. \n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    // mpsc::channel() 함수로 채널을 만들 수 있다.\n    // sender로 보내고 receiver로 받는다.\n    // 각각은 Sender\u003cT\u003e, Receiver\u003cT\u003e 타입이다.\n    // 송신자는 필요하면 `clone`할 수 있다.\n    let (sender, receiver) = mpsc::channel();\n\n    thread::spawn(move || {\n        sender.send(10).unwrap();\n    });\n\n    let recv = receiver.recv().unwrap();\n\n    println!(\"receive is {}\", recv);\n}\n```\n\n송신자가 모두 Drop되거나 수신자가 Drop되면 채널이 닫혔다(*closed*)고 본다. 채널이 닫히면 `send`와 `recv`는 에러를 반환하기 때문에 이들의 반환형은 `Result`이다.\n\n`recv`는 채널에서 값을 꺼내는데, 없으면 블록하고 값을 기다린다. `try_recv` 메소드는 블록하지 않으며 버퍼가 비었을 때에도 에러를 반환한다.\n\n`channel()`로 만든 송신자는 `Sender\u003cT\u003e`로, `send` 함수가 블록되지 않고 돌아간다. `sync_channel(usize)`로 버퍼가 있는 동기 채널을 만들 수 있는데, 이때의 송신자인 `SyncSender\u003cT\u003e`는 `send` 할 때 버퍼가 가득 차 있으면 보낼 수 있을 때까지 블록된다.\n\n### 소유권\n\n`send` 함수의 타입은 `send(\u0026self, t: T)`로 소유권을 가져간다.\n\n```rust\nthread::spawn(move || {\n    let s = String::new();\n    sender.send(s);\n    // `send`가 가져각기 때문에 여기서부터는 `s`를 쓸 수 없다.\n});\n```\n\n\n\n## 참고\n\n- [[동시성을 다루는 방법]]\n- [[식사하는 철학자 문제]]\n- [Rust without the async (hard) part | Lunatic](https://lunatic.solutions/blog/rust-without-the-async-hard-part/)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9":{"title":"서로소 집합","content":"\n그래프 추상 자료형. `union` 연산과 `find` 연산을 쓰기 때문에\n`union-find` 자료구조라고도 한다.\n\n## 연산\n\n- `union`: 두 오브젝트를 연결함.\n- `find`: 두 오브젝트가 연결 되었는지 질의함.\n\n`union`, 즉 연결에 대한 합의가 있어야 한다. 따라서 연결을 다음과 같이 정의한다.\n\n오브젝트 $p$가 다른 오브젝트 $p$에 연결되었음을 $p\\rightarrow p$라고 하자.\n\n- 반사적(*reflexive*)[^1]: $p \\rightarrow p$ 모든 객체는 자기 자신과 연결되어있다.\n- 대칭적(*symmetric*): $p \\rightarrow q$이면 $q \\rightarrow p$이다. 연결은 양방향이다.\n- 추이적(*transitive*): $p \\rightarrow q$이고 $q \\rightarrow r$이면 $p \\rightarrow r$이다.\n\n[^1]: 반사적, 대칭적, 추이적 용어는 이산수학에서 관계를 표현하는 용어를 그대로 썼다.\n\n연결되어 있는 가장 커다란 집합을 연결 요소(*connected component*)라고 부른다.\n아래의 그림에서는 0은 `{0}` 그 자체, 1, 4는 서로 연결되어 있으므로 `{1, 4}`,\n2, 3도 마찬가지로 `{2, 3}`이 연결 요소라고 볼 수 있다. 연결 요소를 이용하면\n`find` 연산을 오브젝트끼리 연결 되어있는지 확인하는 문제에서 하나의 연결 요소에\n포함되어있는지 확인하는 문제로 바꿀 수 있다.\n\n```\n 0 1 2-3\n   | \n   4\n```\n\n## 구현\n\n### Quick Find\n\n`find` 연산이 빠른 구현이다.\n\n선형 리스트를 이용하여 간단히 구현할 수 있다. 아래의 서로소 집합을 예로 보자:\n\n```\n0  1--2  3--4\n|     |  |  |\n5--6  7  8  9\n```\n\n이를 선형 리스트로 나타내면 아래와 같다. 각각의 원소를 인덱스로, 리스트의 값을\n연결 요소의 id로 표현한다. 같은 연결 요소에 있다면 같은 리스트 값을 가진다:\n\n```\nindex     0   1   2   3   4   5   6   7   8   9  \n        +---+---+---+---+---+---+---+---+---+---+\ncontent | 0 | 1 | 1 | 8 | 8 | 0 | 0 | 1 | 8 | 8 |\n        +---+---+---+---+---+---+---+---+---+---+\n```\n\n`0, 5, 6`은 같은 연결 요소에 있기 때문에 해당 인덱스의 리스트 값이 같다. \n\n`find` 구현은 쉽다. $p$와 $q$의 연결 요소가 같은지 확인하면 된다.\n\n`union`는 조금 번거롭다. 연결 할 때 같은 연결 요소의 원소 수만큼 그 내용을\n바꾸어주어야 한다. 위의 그림에서 0번 연결 요소(`{0, 5, 6}`)과 8번\n연결 요소(`{3, 4, 8, 9}`)를 `union`한다고 생각해보자. 0번의 원소를 8로 바꾸거나\n8번의 원소를 0으로 바꾸어주어야한다. 연결 요소 $C$의 원소를 별도로 저장하지 않는다면\n배열 전체를 순회하며 확인해야한다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%84%A0%ED%98%95-%EB%A6%AC%EC%8A%A4%ED%8A%B8":{"title":"선형 리스트","content":"\n\n선형 리스트(*linear list*)는 자료가 순서 있게 나열된 추상적 자료형(ADT)입니다.\n\n$$\n(a_0, a_1, a_2, \\cdots, a_{n-1})\n$$\n\n아래와 같은 예시를 생각해볼 수 있습니다:\n\n- `(폰, 룩, 퀸, 킹, 비숍, 나이트)`\n- `(월, 화, 수, 목, 금, 토, 일)`\n- `(1, 2, 3, 4, 5, ...)`\n- 그 외 순서 있게 나열할 수 있는 모든 것들\n\n## 구분\n\n선형 리스트에 포함된 자료의 타입이 모두 같다면 동형(*homogeneous*)이라고 합니다.\n아래는 러스트의 배열이며, 동형 선형 리스트입니다.\n\n```rust\nlet ages: [i32; 4] = [15, 26, 34, 42];\n```\n\n반대로 자료의 타입이 다를 수 있다면 이형(*heterogeneous*)이라고 합니다.\n아래는 엘릭서의 리스트이며, 이형 선형 리스트입니다.\n\n```elixir\ninputs = [:something, \"Hello\", 42]\n```\n\n## 연산\n\n- 길이 구하기\n- 모든 원소를 하나씩 방문하기\n- $k$번째 원소 구하기\n- $k$번째 원소 바꾸기\n- $k$번째 자리에 새 원소를 삽입하고 나머지 원소를 뒤로 밀기\n- $k$번째 원소를 삭제하고 나머지 원소를 앞으로 당기기\n- 서로 다른 두 리스트를 합치기\n\n## 구현\n\n### 배열\n\n배열(*array*)은 가장 기본적인 연속적 자료구조입니다.\n\n고정된 크기의 메모리에 각 원소가 순서에 맞게 연속적으로 저장됩니다.\n각 원소에 바로 접근할 수 있어 효율적이지만, 원소를 더하거나 뺄 때 형태를\n유지하기 위해 비용이 필요합니다.\n\n#### 장점\n\n- **랜덤 엑세스가 가능하다**: 시작 주소와 인덱스로 각 원소의 메모리 주소를 바로\n  알 수 있기 때문에 각 원소에 바로 접근할 수 있습니다.\n- **공간 효율성이 좋다**: 순수한 데이터의 나열이기 때문에 낭비되는 공간이 없습니다.\n- **메모리 지역성이 좋다**: 현대 컴퓨터는 캐시 메모리를 적극 이용하는데, 배열은\n  연관된 자료가 한 곳에 모여있으므로 캐시 적중률이 좋아서 실질적으로 더 빠릅니다.\n  \n#### 단점\n\n- 프로그램 실행 중 그 크기를 바꿀 수 없습니다.\n  - **동적 배열**로 해결할 수 있습니다.\n- 리스트를 쪼개고 합치거나, 앞에 자료를 추가하는것이 비효율적입니다.\n  - 리스트의 $n$개의 원소를 옮겨야하므로, $O(n)$의 비용이 듭니다.\n  \n#### 용례\n\n대부분의 프로그래밍 언어들이 동적 배열을 기본 선형 리스트로 사용합니다.\n\n효율이 중요한 시스템 프로그래밍 언어들은 배열\n\n\n### 연결 리스트\n\n연결 리스트(*linked list*)는 가장 기본적인 연결적 자료구조입니다.\n\n각각의 원소는 메모리 이곳저곳에 떨어져서 저장되고, 이들을 포인터로 논리적으로\n연결합니다. 각 원소가 논리적으로 연결되어 있기 때문에 중간에 값을 추가하거나\n자르거나 나누거나 합치는 등의 연산은 효율적이지만 랜덤 엑세스가 불가능하여\n특정 원소를 찾기 위해서는 대부분의 경우 앞에서부터 순차적으로 확인해야합니다.\n\n#### 장점\n\n- **쪼개고 잇는 연산이 효율적이다**: 배열은 수정을 위해서 배열 전체를 복사해야\n  하지만 연결 리스트는 그럴 필요가 없습니다. 해당 노드에서 다음 노드로의\n  연결 고리만 바꾸어주면 되기 때문에 상수시간($O(1)$)에 해결할 수 있습니다.\n  원소의 순서를 바꿔야할 필요가 있을 경우에도, 원소 자체를 옮기는 것보다는\n  포인터를 바꾸는 것이 훨씬 효율적입니다.\n- **성능이 일정하다**: 동적 배열의 경우 실행 중간에 크기가 커질 때에 한해\n  성능 저하가 일어나기 때문에 성능이 일정하지 않습니다.\n- **추가가 자유롭다**: 컴퓨터의 메모리가 부족하지 않는 이상 오버플로우 등의\n  문제를 겪을 일이 없습니다.\n  \n#### 단점\n\n- 최적화가 어렵습니다. 캐시 지역성(*cach locality*)이 좋지 않기 때문에 캐시\n  적중률이 낮으며, 반드시 포인터로 메모리 여기저기를 순회해야합니다.\n- 랜덤 엑세스가 불가능합니다. 리스트의 마지막 원소에 접근하려면 대부분의 경우\n  전체 리스트를 순회해야합니다.\n- 공간 효율성이 나쁩니다. 포인터를 활용하기 때문에 반드시 배열보다 많은 메모리를\n  사용합니다.\n\n#### 용례\n\n불변 자료구조를 적극 활용하는 프로그래밍 언어들이 연결 리스트를 기본 선형 리스트로\n자주 사용합니다. ex) 엘릭서의 `List`, 하스켈의 `[a]`\n\n이러한 언어들은 언어 차원에서 리스트를 쪼개고 잇는 연산을 쉽게 쓸 수 있도록 지원합니다.\n\n```elixir\nlist = [1, 2, 3, 5, 7]\n\n[_ | primes] = list\nassert primes == [2, 3, 5, 7]\n```\n\n이러한 언어들은 포인터로 잇는 연결적 자료구조의 특성을 적극 활용하여 성능을 높입니다.\n이를 영속적 자료 구조(*persistent data structure*)라고 합니다. \n예를 들어 아래와 같이 `1, 2, 3, 4`를 담은 연결 리스트 `list`가 있고, 이를 이용해\n`new_list`를 만들었다고 합시다:\n\n```elixir\nlist = [1, 2, 3, 4]\nnew_list = [0 | list]\n```\n\n연결 리스트의 특성을 활용하면 `1, 2, 3, 4`를 복사하지 않고도 이를 표현할 수 있습니다.\n\n```\n     /-\u003e [1, 2, 3, 4]\n[0, *]\n```\n\n그러나 위에서 언급한 단점으로 인하여 데이터를 저장하고 다룰 때에는 배열을 쓸 수\n있도록 지원하고 있습니다. ex) 엘릭서의 `:array`, `{}`, 하스켈의 `Data.Array` 등.\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%84%A0%ED%98%95-%ED%9A%8C%EA%B7%80":{"title":"선형 회귀","content":"\n선형회귀(linear regression)란 하나 이상의 목적변수를 하나 이상의 설명변수로 설명한 식이다.\n$w_1, \\cdots, w_k$를 가중치, $x_1, \\cdots, x_k$를 설명변수, $\\varepsilon$을 편향값(bias)이라고 할 때 목적변수 $y$를 설명하는 선형 회귀식은 아래와 같다:\n\n$$\ny = \\varepsilon + \\sum^l_{k=1}{w_kx_k}\n$$\n\n행렬을 이용해 표기한 식은 아래와 같다:\n\n- $\\mathbf y$: 설명변수가 담긴 열벡터\n- $X$: 확률변수가 담긴 행렬\n- $\\mathbf w$: 가중치가 담긴 열벡터\n- $\\mathbf \\varepsilon$: 편향값 열벡터\n\n$$\n\\mathbf{y} = X\\mathbf{w} + \\mathbf \\varepsilon\n$$\n\n\n## 가중치 구하기\n\n데이터를 잘 설명하는 모델을 만들기 위해서는 가중치 $\\mathbf w$를 잘 구해야 한다. 이를 잘 구하는 방법을 최적화 알고리즘(optimizer)라고 부른다.\n\n- 유사역행렬\n- 경사하강법(gradient descent)\n- 확률적 경사하강법(SGD; stochastic gradient descent)\n\t- 볼록하지 않은(non-convex) 목적식을 최적화할 수 있다.\n- 최소제곱법(least squared method)\n\t- 평균제곱오차(MSE)를 각각의 가중치에 대해 편미분한 값이 0이 되도록 연립방정식을 풀어 가중치를 구한다.\n\n### 최소제곱법\n\n아래와 같은 행렬식에서 적절한 가중치 $\\mathbf w$를 구해서 선형회귀를 완성하려고 한다. 이때 $\\mathbf y$의 각 원소 $y_i$는 아래와 같이 풀어진다.\n\n$$\n\\begin{align}\n\\mathbf y \u0026= X \\mathbf w + \\mathbf \\varepsilon \\\\\ny_i \u0026= w_1x_{i1} + \\cdots + w_mx_{im} + \\varepsilon_i\n\\end{align}\n$$\n\n원래 데이터의 값을 $f(x_{i1}, \\cdots, x_{im})$이라고 했을 때, 오차의 제곱합 $D$는 아래와 같다.\n\n$$\nD=\\sum^n_{i=1}\\{f(x_{i1},\\cdots,x_{im})-y_i\\}^2\n$$\n\nTODO","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%84%B8-%EC%86%90%EA%B0%80%EB%9D%BD%EC%9C%BC%EB%A1%9C-%EB%93%9C%EB%9E%98%EA%B7%B8%ED%95%98%EA%B8%B0":{"title":"세 손가락으로 드래그하기","content":"\n트랙패드로 드래그하려면 기본적으로 클릭을 해야 하는데 손에 힘들어가서 불편하다. 세 손가락으로 드래그하기를 켜면 그냥 손가락 세 개 올려놓고 슥 하면 드래그 된다.\n\n1.  시스템 설정 → 손쉬운 사용 → 포인트 제어기 → 트랙패드 옵션…\n    1.  드래그에 트랙패드 사용 켜기\n    2.  드래그 스타일에 세 손가락으로 드래그하기\n\n![](assets/세-손가락으로-드래그.png)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%86%8C%EC%9C%A0%EB%A1%9D":{"title":"소유록","content":"\n## 사용중\n\n- 📚 전자책 단말기 — [[오닉스 북스 리프2]]\n- 📱 휴대폰 — 아이폰 12 Pro\n- ⌨️ 개인용 서버 — ODROID H2\n- 💻 노트북 — [[맥북에어 (M1, 2020)]]\n- 📝 노트 — 로디아 웹노트 A5 dot grid","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0":{"title":"스마트 포인터","content":"\n\n![](rust-container-cheat-sheet.svg)\n\n## 포인터\n메모리 주소를 담고 있는 변수. 이 주소로 다른 주소를 **가리키고**있기 때문에 포인터(*pointer*)라고 부른다.\n\n흔히 **포인터**라고 콕 찝어 부를 때에는 아무 추상화가 없는 원시 포인터(*raw pointer*)를 의미한다. 러스트에서도 원시 포인터를 만들 수 있다. 불변은 `*const T`, 가변은 `*mut T`이다:\n\n```rust\nlet num = 5;\n\nlet pointer: *const i32 = \u0026num;\nlet pointer = \u0026num as *const i32;\n\nprintln!(\"{:?}\", pointer);\n// 0x16ee56ab4\n\nlet nullptr: *const i32 = std::ptr::null();\nprintln!(\"{:?}\", nullptr);\n// 0x0\n```\n\n포인터는 **역참조**(*dereference*)로 비로소 유용해진다. 포인터가 담고 있는 주소에 찾아가 그 값을 얻거나 도로 대입할 수 있다. 역참조는 `*`[^1] 연산자로 한다. 다만 러스트에서는 원시 포인터를 바로 역참조할 수 없다. 원시 포인터가 러스트의 빌림 규칙을 무시할 수 있기 때문이다. `unsafe` 블록 내에서는 가능하다.\n\n[^1]: 영어로는 /아스터리스크/라고 읽는다. 편하게 별표라고 읽자.\n\n```rust\nlet mut num = 21;\n\nlet ptr = \u0026mut num as *mut i32;\n\nunsafe {\n    // `ptr`이 가르키는 메모리 주소에 접근하여 대입하기\n\t*ptr *= 2;\n\t\n    println!(\"{}\", *ptr);\n    // 42\n}\n```\n\n## 참조자\n\n포인터는 그대로 쓰기에는 위험성이 크기에 기능을 제약한 참조자를 주로 쓴다. 러스트에서는 빌림 규칙으로 포인터를 제약하고, `\u0026T` 혹은 `\u0026mut T`로 표기한다.\n\n```rust\nlet mut num = 40;\n\n// ref: \u0026i32이다\nlet refer = \u0026mut num;\n\n// `\u0026mut i32`에 `+=` 연산자를 적용할 수 없어서 아래 코드는 에러가 난다:\nrefer += 2;\n\n// 역참조를 통해 `num`을 바꿀 수 있다.\n*refer += 2;\nprintln!(\"{}\", num);\n```\n\n## 스마트 포인터란\n\n포인터의 역할을 흉내내는 자료구조이다. 필요할 때 자동으로 값의 할당을 해제하는 등 자동으로 메모리 관리를 해주기 때문에 스마트 포인터라고 부른다.\n\n- 역참조가 가능해야 한다. `Deref` 트레잇으로 구현한다.\n- 할당을 해제할 수 있어야 한다. `Drop` 트레잇으로 구현한다.\n\n## 스마트 포인터의 종류\n\n![](assets/rust-memory-container-cs-1920x1080-light-back.png)\n[usgai/rust-memory-container-cs](https://github.com/usagi/rust-memory-container-cs)\n\n### Box\\\u003cT\\\u003e\n- 힙에 자료를 할당할 때\n- 컴파일 타임에 크기를 알 수 없을 때\n- 소유권이 옮겨질 때 복사하고 싶지 않을 때\n- 특정 트레잇을 구현한 타입들을 다루고 싶을 때\n\n### Rc\\\u003cT\\\u003e\nreference counting; 참조 카운팅. 단일 스레드에서 여러 소유권이 필요할 때 쓴다.\n\n### RefCell\\\u003cT\\\u003e\n소유권 검사를 컴파일 타임이 아닌 런타임으로 미루는 스마트 포인터. 실행시간에 안전한 것이 확인되었지만 컴파일 시간에 보장이 안 될 때 사용한다. 단일 스레드 환경에서 쓴다. `Rc\u003cRefCell\u003cT\u003e\u003e`의 형태로 다중 소유권과 내부 가변성을 한꺼번에 쓰기도 한다.\n\n### Mutex\\\u003cT\\\u003e\nmutual exclusion; 상호 배제.\n\n### Arc\\\u003cT\\\u003e\n\n## 참고\n\n- [Rust container cheat sheet](https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p)\n- [GitHub - usagi/rust-memory-container-cs: Rust Memory Container Cheat-sheet](https://github.com/usagi/rust-memory-container-cs)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%8A%A4%EC%BC%80%EC%9D%BC":{"title":"스케일","content":"\n음계. 음을 나열한 것.\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C":{"title":"식사하는 철학자 문제","content":"\n![](assets/dining-philosophers.jpg)\n\n다섯 명의 철학자가 원탁에 둘러 앉는다. 철학자들은 생각을 하다 이따금 스파게티를 먹는다. 철학자들 사이엔 포크가 놓여 있는데, 양쪽의 포크를 모두 사용하여 식사를 한다.\n\n1. 일정 시간 동안 생각을 한다.\n2. 왼쪽의 포크를 집어든다. 포크가 사용중이면 대기한다.\n3. 오른쪽의 포크를 집어든다. 포크가 사용중이면 대기한다.\n4. 양쪽의 포크를 잡았다면 일정 시간 동안 식사를 한다.\n5. 오른쪽 포크를 내려놓는다.\n6. 왼쪽 포크를 내려놓는다.\n7. 1번으로 돌아간다.\n\n## 교착상태\n\n이 문제는 1965년에 컴퓨터 과학자 에츠허르 데이크스트라(*Edsger W. Dijkstra*) 박사가 교착상태(*deadlock*)을 설명하기 위해 만든 것으로 알려져있다.\n\n어느 순간 모든 철학자가 왼쪽의 포크를 집어든 순간을 상상해보자. 모든 철학자는 이미 사용중인 자신의 오른쪽 포크를 기다리기만 하고 아무것도 하지 못하는 교착상태(*deadlock*)에 빠지게 된다.\n\n## 해결 방법\n\n1. 자원 위계 해결법\n\t- 적어도 한 명의 철학자는 다른 순서로 포크를 집도록 하여 순환 의존성을 없앤다.\n\t- 다섯 개의 뮤텍스가 필요하다.\n\t- 언뜻보면 손쉽고 좋은 해결책인 것 같으나 허점이 많은데, 가령 오른쪽 포크부터 집는 철학자는 생각이 길면 밥을 절대 먹을 수 없다.\n\t- 또한 자원의 갯수를 미리 알아야 해결할 수 있다.\n2. 타임아웃을 이용한 해결법\n\t- 일정 시간 동안 자원을 얻지 못하면 자원을 반환하고 처음부터 작업을 다시한다.\n\t- 근본적인 해결법은 아니나 빠르게 적용할 수 있는 임시방편이다.\n3. 중재자 해결법\n\t- 포크를 감독할 웨이터를 둔다. 포크를 감독하다 포크 하나만 남으면 왼손에 포크를 쥔 철학자에게만 포크를 준다.\n\t- 뮤텍스 하나만 있으면 된다.\n4. n-1 해결법\n\t- 철학자를 감독할 웨이터를 둔다. 적어도 한 명의 철학자를 기다리게 한다.\n\t- 뮤텍스 하나와 세마포어 하나가 있어야 한다. \n5. Chandy/Misra 해결법\n\t- 메시지 패싱을 이용한 해법.\n\t- 철학자가 서로 대화할 수 있을 경우의 해법이다. (메시지 패싱하므로)\n\t- MSPC를 이용하여 해결한다.\n\n## 참고\n\n- [데드락 (DeadLock, 교착 상태) | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98":{"title":"알고리즘","content":"\n\n- 정렬 알고리즘:\n\t- 퀵 정렬(quick-sort)\n\t- 병합 정렬\n\t- 힙 정렬\n- 검색 알고리즘:\n\t- 이진 검색\n- 그래프 탐색 알고리즘:\n\t- DFS\n\t- BFS\n\t- Prim\n\t- 다익스트라\n\n## 참고\n- [알고리즘 학습에 대한 조언 | 보통의 비망록](https://edykim.com/ko/post/advice-on-learning-algorithms/)\n- [[자료구조]]","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%97%98%EB%A6%AD%EC%84%9C":{"title":"엘릭서","content":"\n- [[프로세스 (엘릭서)]]","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EC%BD%94%EB%93%9C%EC%A7%84%ED%96%89":{"title":"여러가지 코드진행","content":"\n- ii\u003csup\u003e7\u003c/sup\u003e - V\u003csup\u003e7\u003c/sup\u003e — 투 파이브 코드 진행\n\t- ii\u003csup\u003e7\u003c/sup\u003e - V\u003csup\u003e7\u003c/sup\u003e - IV\u003csup\u003e7\u003c/sup\u003e — 투 파이브 원\n- IV\u003csup\u003e△7\u003c/sup\u003e - III\u003csup\u003e7\u003c/sup\u003e - vi\u003csup\u003e7\u003c/sup\u003e - v\u003csup\u003e7\u003c/sup\u003e - I\u003csup\u003e7\u003c/sup\u003e — [Just The Two Of Us](https://www.youtube.com/watch?v=Uw5OLnN7UvM) 진행\n\t- IV\u003csup\u003e△7\u003c/sup\u003e III\u003csup\u003e7\u003c/sup\u003e vi\u003csup\u003e7\u003c/sup\u003e I\u003csup\u003e7\u003c/sup\u003e\n\t- Bill Withers - Just The Two Of Us\n\t- 椎名林檎 - 丸の内ディスチック\n\t- yama - 春を告げる\n\t- れをる - 第六感\n- IV V iii vi — 왕도진행\n- I V vi iii IV I IV V\u003csup\u003e7\u003c/sup\u003e — 카논 코드\n\t- 요한 파헬벨 - [카논 라 장조](https://www.youtube.com/watch?v=JvNQLJ1_HQ0)\n- I V vi IV — [Pop-punk chord progression](https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression)\n\t- IV I V vi\n\t- V vi IV I\n\t- vi IV I V\n\t- IV I V vi\n- vi IV V I — 小室(코무로)진행\n\t- 작곡가 [코무로 테츠야](https://ja.wikipedia.org/wiki/%E5%B0%8F%E5%AE%A4%E5%93%B2%E5%93%89)가 많이 썼다고 하여 붙은 이름\n\t- King Gnu - 百日\n- IV V I\n- I V vi IV\n- i bIII bVII IV\n- ii V vi iii\n- vi IV I V\n\n## 참고\n\n- [【今知るべき】ヒット曲に使われるコード進行TOP5【ギターで弾こう】 - YouTube](https://youtu.be/am47Et8axbI)\n- [J-POPを席巻！定番コード進行5選をまとめて紹介～コード特徴、使用楽曲など～ - YouTube](https://www.youtube.com/watch?v=RdQC3A8RqPc)\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%97%B0%EC%82%B0%EC%9E%90-%ED%91%9C%EA%B8%B0%EB%B2%95":{"title":"연산자 표기법","content":"\n\n## 연산자\n\n컴퓨터 과학에서 \"연산자는 무엇이다\" 라고 명쾌하게 널리 받아들여지는 정의는 없는 것 같다.\n\n일반적인 인식으로는 연산자는 아래와 같은 것들을 칭한다:\n- 산술 연산자 (`+`, `*`, `-`, `/`, ...)\n- 비교 연산자 (`\u003c`, `\u003e`, ...)\n- 논리 연산자 (`\u0026\u0026`, `||`, `!`, ...)\n\n언어에 따라 다음과 같은 연산자가 있기도 하다:\n- 대입 연산자(`=`, `-=`, ...)\n- 증감 연산자(`++`, `--`, ...)\n- 비트 연산자(`\u0026`, `|`, ...)\n- 할당 연산자(`new`, `delete`, ...)\n\n이들의 특징은 아래와 같다:\n- 대부분의 언어에서 특별하게 취급한다.\n- 대부분의 언어에서 새로 정의할 수 없거나 제약이 있다.\n\n위키피디아에서 내린 연산자의 정의는 아래와 같다:\n\n\u003e 컴퓨터 과학에서 연산자란 프로그래밍 언어로부터 정의되어 함수처럼 동작하지만 구문적 또는 의미적으로 함수와 다른 제어구조이다. -- [Operator (comptuer programming)](\u003chttps://en.wikipedia.org/wiki/Operator_(computer_programming)\u003e)\n\n연산의 대상의 대상을 피연산자(*operand*)라고 한다.\n\n## 피연산자의 수에 따라서\n피연산자의 수를 항수(*arity*)라고 한다.\n\n### 단항 연산자\nunary. 항을 한 개만 취하는 연산자이다.\n\n```C++\nif (!user) { /* 뭔가 하기 */ }\n```\n\n### 이항 연산자\nbinary.\n\n흔히 연산자라고 생각하면 떠오르는 것들은 여기에 속한다.\n\n### 삼항 연산자\nternary.\n\n흔히 볼 수 있는 삼항 연산자로는 삼항 조건 연산자가 있다.\n\n```javascript\n// 조건문 ? 참의 표현식 : 거짓의 표현식\nfunction getFee(isMember) {\n  return (isMember ? '$2.00' : '$10.00');\n}\n\n// 아래와 같이 중첩할 수도 있다:\nfunction example(…) {\n    return condition1 ? value1\n         : condition2 ? value2\n         : condition3 ? value3\n         : value4;\n}\n```\n\n파이썬도 삼항 조건 연산자가 있는데, 아래와 같이 쓴다:\n\n```python\n참의 표현식 if 조건문 else 거짓의 표현식\n```\n\n러스트에서는 `if` 표현식과 기능적으로 동일하여 제거하였다. 따라서 아래와 같이 쓴다:\n```rust\nif 조건문 { 참의 표현식 } else 거짓의 표현식\n```\n\n- [Remove ternary operator#1698](https://github.com/rust-lang/rust/issues/1698)\n\n### 다항 연산자\nmultiary.\n\n### 가변 연산자\nvarying arity.\n\n## 위치에 따라서\n### 중위 표기법\ninfix.\n\n사람에게 가장 익숙한 표기법이다.\n\n### 전위 표기법\nprefix.\n\n함수도 연산자로 보자면, 대부분의 언어들은 함수 호출에 대해서 전위 표기법을 사용한다.\n\nLISP 계열의 언어가 전위 표기법을 사용한다.\n\n```clojure\n(and (number? 10) (\u003c 10 20))\n```\n\n### 후위 표기법\npostfix.\n\n포스 계열의 스택 기반 언어가 후위 표기법을 사용한다.\n\n```factor\n{ 4 8 15 16 23 42 } [ 2 * ] map .\n```\n\n## 우선순위와 결합법칙\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%98%A4%EB%8A%98%EC%9D%80-%EB%AA%87-%EC%A3%BC%EC%B0%A8":{"title":"오늘은 몇 주차","content":"\n\n[오늘은 몇 주차](https://annyeong.me/nth-week-today/)\n\n## '주'란 무엇인가?\n\n**주**란 과연 무엇일까요? 주에 대해 자세히 생각해보면 이런 저런 의문이 듭니다.\n\n- *한 주의 시작*은 월요일일까, 일요일일까? \n- 365.25일을 7로 나누면 약 52.178이다. 즉 1년은 평균 52.178주이다?\n- 올해(2022년)의 첫날은 토요일이다. 그렇다면 올해의 첫주는 1월 1일을 포함할까?\n\n세상에는 혼돈을 줄이기 위하여 별에 별 것들에 대해 표준이 있습니다. 날짜와 시간과 관련된 데이터에 대한 국제 표준으로 [ISO 8601](https://ko.wikipedia.org/wiki/ISO_8601)이 있으며, 이에 대응하는 국내 표준으로 [KS X ISO8601](https://www.standard.go.kr/KSCI/standardIntro/getStandardSearchView.do?menuId=503\u0026topMenuId=502\u0026ksNo=KSXISO8601\u0026tmprKsNo=KSXISO8601)이 있습니다. 표준이력사항을 읽어보면 국내산업에서 개정의 요구가 없어 국제 표준과 동일한 내용으로 국내에 적용하고 있는 것을 확인할 수 있습니다.\n\n해당 표준 내용을 정리하면 아래와 같습니다.\n\n- 한 주는 7일로 이루어져있다.\n- 한 주는 월요일로 시작하여 일요일로 끝난다.\n- 1년은 52주 또는 53주이다. (즉 364일 또는 371일이다.)\n- 1년의 첫번째 주는 해당 해의 **첫번째 목요일**이 포함된 주이다.\n- 1년의 마지막 주는 해당 해의 **마지막 목요일**이 포함된 주이다.\n- 주를 표현할 때에는 **2018-W12** 혹은 날짜를 포함하여 **2018-W12-4**처럼 한다. 이 경우 2018년의 13번째 주의 4번째 날이므로 2018년 03월 22일이 된다.\n\n요약하면, 한 주의 시작은 월요일, 끝은 일요일이지만, **주차에 대한 판단 기준은 목요일**에 있습니다.\n\n예시를 들어보면 아래와 같다. 아래처럼 첫해의 첫 목요일이 포함된 주가 그 해의 첫번째 주가 됩니다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W01** | 01  | 02  | 03  | **04** | 05  | 06  | 07  |\n\n만약 첫 목요일이 아래와 같이 되어 있다면 해당 연도의 1월 1일부터 1월 3일은 그 해의 첫주가 아니라, *그 전 해의 마지막 주*가 됩니다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W53** |     |     |     |        | 01  | 02  | 03  |\n| **W01** | 04  | 05  | 06  | **07** | 08  | 09  | 10  |\n\n## Week Number 계산하기\n\n주차를 직접 계산해봅시다. 깔끔하게 `week_number(date: Date) -\u003e i32` 같은 함수가 나오는 것이 목표입니다. 주차란 올해의 첫번째 주로부터 몇 주가 지났는지를 의미합니다. 오늘이 올해의 몇 번째 날인지만 알면 7로 나누어 알아낼 수 있습니다. 오늘이 올해의 몇번째 날인지를 $\\text{ordinal}(\\text{date})$라고 하겠습니다. 이는 컴퓨터로는 오늘에서 1월 1일을 빼면 알 수 있고, 손으로는 오늘 날짜와 지나간 월들의 날을 모두 합하여 알아낼 수 있습니다.\n\n가장 간단하게 1월 1일이 월요일인 해를 가정해봅시다. 다음은 해당 해의 첫주이므로 $\\text{week}(1)$부터 $\\text{week}(7)$까지의 값이 1로 같아야합니다. \n\n|Week   |Mon|Tue|Wed| *Thu* |Fri|Sat|Sun|\n|-------|---|---|---|-------|---|---|---|\n|**W01**| 01| 02| 03| **04**| 05| 06| 07|\n\n다음과 같이 6을 더하고 버림 함수를 사용하면 이 구간에서는 의도한 대로 나옵니다.\n\n$$\n\\text{week}(\\text{date}) =\n\\left\\lfloor\\frac{\\text{ordinal}(\\text{date}) + 6}{7} \\right\\rfloor\n$$\n\n다른 예시를 살펴봅시다. 1일이 작년으로 넘어가면 올바른 결과가 나오지 않습니다. 해가 금요일부터 시작하여 1월 1일이 W01이 아닌 예를 봅시다.\n\n| Week    | Mon | Tue | Wed | *Thu*  | Fri | Sat | Sun |\n| ------- | --- | --- | --- | ------ | --- | --- | --- |\n| **W53** |     |     |     |        | 01  | 02  | 03  |\n| **W01** | 04  | 05  | 06  | **07** | 08  | 09  | 10  |\n\n$\\text{week}(1)=52$, $\\text{week}(4)=1$이 되어야 하지만, 위의 식을 적용하면, 둘 다 1이 되어버립니다.\n\n주의 시작이 월~목일 때와 이를 넘어갈 때를 구분할 방법이 필요하다. 오늘 날짜에서 요일을 빼면 가능할 것 같다. ISO 8601에 요일을 수로 표현할 때는 월요일을 1로, 일요일을 7로 하여 나열한다고 나와있다. (이를 *week day*라고 한다.) 이렇게 하면 같은 주의 $\\text{ordinal}(\\text{date}) - \\text{weekday}(\\text{date})$의 값은 일정해진다.\n\n값을 명확히 보기 위해 바닥함수는 제외하고 `wN = (date) =\u003e (ordinal(date) - weekday(date) + 6) / 7`이라고 하자. 1월 1일이 월요일일 때와 금요일일 때의 `wN`값을 확인해보자\n\n| Week    | Mon    | Tue    | Wed    | *Thu*  | Fri    | Sat    | Sun    |\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| 요일    | 01     | 02     | 03     | 04     | 05     | 06     | 07     |\n| **W01** | 01     | 02     | 03     | **04** | 05     | 06     | 07     |\n| `wN`    | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` | `0.86` |\n| **W53** |        |        |        |        | 01     | 02     | 03     |\n| `wN`    |        |        |        |        | `0.29` | `0.29` | `0.29` |\n| **W01** | 04     | 05     | 06     | **07** | 08     | 09     | 10     |\n| `wN`    | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` | `1.29` |\n\n`wN`이 1보다 작은 경우는 전년도의 마지막 주로 처리하면 깔끔할 것 같다. 그런데 1월 1일이 월요일일 경우 `wN`이 1.0을 넘지 않는다. 위에서 주었던 보정값 `+6` 대신 다른 상수를 더해서 해결해보자.\n\n$$\\text{week}(\\text{date}) =\n\\left\\lfloor\\frac{\\text{ordinal}(\\text{date}) - \\text{weekday}(\\text{date}) + C}{7} \\right\\rfloor$$\n\n- 1월 1일이 **월요일**이라면 이날은 **첫번째 주**이므로 $1-1+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 화요일이라면 이날은 첫번째 주이므로 $1-2+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 수요일이라면 이날은 첫번째 주이므로 $1-3+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 목요일이라면 이날은 첫번째 주이므로 $1-4+C$가 구간 $[7, 14)$ 안에 있어야 한다.\n- 1월 1일이 **금요일**이라면 이날은 **마지막 주**이므로 $1-5+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n- 1월 1일이 토요일이라면 이날은 마지막 주이므로 $1-6+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n- 1월 1일이 일요일이라면 이날은 마지막 주이므로 $1-7+C$가 구간 $[0, 7)$ 안에 있어야 한다.\n\n위의 조건에 만족하려면 $C=10$이여야한다.\n\n상수가 바뀌었으니 새로운 보정값에 맞춰 `wN`을 계산해보자. 이때 `wN = (date) =\u003e (ordinal(date) - weekday(date) + 10) / 7`이다.\n\n| Week    | Mon    | Tue    | Wed    | *Thu*  | Fri    | Sat    | Sun    |\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| **W53** | 28     | 29     | 30     | **31** | 01     | 02     | 03     |\n| `wN`    | `53`   | `53`   | `53`   | `53`   | `0.86` | `0.86` | `0.86` |\n| **W01** | 04     | 05     | 06     | **07** | 08     | 09     | 10     |\n| `wN`    | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` | `1.86` |\n\n따라서 오늘의 날짜를 알고 있다면 위의 공식으로 오늘의 *주수*(week number)를 알 수 있습니다.\n\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%98%A4%EB%8B%89%EC%8A%A4-%EB%B6%81%EC%8A%A4-%EB%A6%AC%ED%94%842":{"title":"오닉스 북스 리프2","content":"\n- 설치한 앱\n\t- 리디 — 주로 이용\n\t- Kindle — 일본 서적\n\t- 밀리의서재\n\t- 전자도서관See\n\t- Bitwarden — 비밀번호 관리용\n\t- Multiling O Keyboard — 무이 단모음 키보드\n\t- Gboard — 일본어 키보드\n- 설정\n\t- Side key settings\n\t\t- Side key direction — Combination 1\n\t\t- 위 버튼 길게 누르기 — 스크린 캡처\n\t\t- 아래 버튼 길게 누르기 — 전체 새로고침","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C":{"title":"운영체제","content":"\n“운영체제: 아주 쉬운 세 가지 이야기”에서는 운영체제의 근간을 세 가지 개념으로 나눈다.\n\n1. 가상화\n2. 동시성 (번역본에서는 병행성으로 번역되었다.)\n3. 영속성\n\n- [[프로세스]]\n- [[멀티태스킹]]\n- [[동시성을 다루는 방법]]\n\n## 참고\n\n- [리눅스 및 커널프로그래밍 - 금오공과대학교 | KOCW 공개 강의](http://www.kocw.net/home/search/kemView.do?kemId=1266434)\n- [국민대학교 OCW](https://ocw.kookmin.ac.kr/course/230)\n- 반효경, [운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323), 이화여자대학교, 2014\n- [ostep-translations/korean at master · remzi-arpacidusseau/ostep-translations · GitHub](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9C%A0%EB%8B%89%EC%8A%A4-%EC%8B%A0%ED%98%B8":{"title":"유닉스 신호","content":"\n\n유닉스 신호를 사용하는 리눅스, macOS, BSD 계열 OS에 한정한 이야기이다.\n\n각각의 프로세스들은 서로와, 그리고 운영체제와 **유닉스 신호**(*unix signal*)을\n이용하여 소통한다. CLI에서 프로그램을 쓰다가 `Ctrl+C`를 눌러 종료할 때에도\n유닉스 신호가 전달된다.\n\n아래의 C 프로그램은 `SIGINT` 신호를 받을 때까지 대기하고, 받으면 종료한다.\n일반적으로는 프로그램이 실행되고 있을 때 `Ctrl-C`를 눌러 신호를 보낼 수 있다.\n\n```c\n##include \u003csignal.h\u003e // signal function\n##include \u003cstdio.h\u003e  // printf function\n##include \u003cunistd.h\u003e // sleep function\n##include \u003cstdlib.h\u003e // exit function\n\nvoid handle_sigint(int signum) {\n  printf(\"%d: SIGINT catched.\\n\", signum);\n  exit(0);\n}\n\nint main() {\n  signal(SIGINT, handle_sigint);\n\n  while (1) {\n    sleep(1);\n  }\n  \n  return 0;\n}\n```\n\n```bash\n$ clang test.c\n$ ./a.out\n^C2: SIGINT catched.\n```\n\n신호는 기본적으로 프로세스를 인터럽트한다. 위의 C 예시에서 프로세스는\n`while`문을 실행하고 있겠지만, 유닉스 신호를 받는 순간\n`void handle_sigint(int)` 콜백부터 처리한다.\n\n### 신호 보내기\n\n유닉스 신호 전체는 `man signal`로 볼 수 있다.\n\n주로 쓰는 유닉스 신호와 신호 번호(*signum*), 매핑된 단축키는 아래와 같다.\n번호는 유닉스의 [macOS signal 메뉴얼][macos-signal]을 참고하였는데, 리눅스의\n그것과 다를 수도 있다.\n\n[macos-signal]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/signal.3.html\n\n| 신호이름  | 번호 | 단축키 | 설명                           | 기본동작      |\n| --------- | ---- | ------ | ------------------------------ | ------------- |\n| `SIGHUP`  | 1    | 없음   | 신호 끊김(hang up)             | 프로세스 종료 |\n| `SIGINT`  | 2    | Ctrl-C | 프로세스 인터럽트              | 프로세스 종료 |\n| `SIGQUIT` | 3    | Ctrl-\\ | 프로세스 종료                  | 코어 덤프     |\n| `SIGKILL` | 9    | 없음   | 프로세스 강제종료              | 코어 덤프     |\n| `SIGSTOP` | 17   | 없음   | 프로세스 멈춤 (무시할 수 없음) | 프로세스 멈춤 |\n| `SIGTSTP` | 18   | Ctrl-Z | 프로세스 멈춤 (키보드로 발생)  | 프로세스 멈춤 |\n| `SIGCONT` | 19   | 없음   | 프로세스 재개                  | 신호 무시     |\n| `SIGCHLD` | 20   | 없음   | 자식 프로세스의 상태가 바뀜    | 신호 무시     |\n| `SIGUSR1` | 30   | 없음   | 프로세스 재개                  | 신호 무시     |\n\n- 프로세스 종료(*terminate*): 프로세스의 작동을 멈추고 종료한다.\n- 프로세스 멈춤(*stop*): 프로세스를 정지시킨다. `SIGCONT`로 다시 실행시킬 수\n  있다.\n- 코어 덤프(*create core image*): 프로세스를 종료(*terminate*)하고 메모리\n  상태를 기록한다. 프로그램이 종료되었을 때 상태를 확인하고 재현할 수 있도록\n  하기 위함이다.\n  \n### `SIGHUP`?\n\n**sig**nal **h**ang **up**의 약어이다. *hang up*이 전화를 끊다라는 뜻인데,\n전화선으로 \n\n프로세스를 실행하고 있는 터미널이 종료되면 프로세스에게 `SIGHUP` 신호가\n전달된다. 기본 동작은 종료이기 때문에 터미널을 종료하면 켜놓았던 프로세스는\n다 종료된다. 이를 막으려면 `nohup` 명령어를 사용하면 된다.\n\n#### `SIGQUIT`과 `SIGKILL`의 차이\n\n`SIGQUIT`은 프로세스에 멈춤 신호를 보내어 자식 프로세스나 메모리를 정리하도록\n한다. 반면 `SIGKILL`은 강제로 종료해버린다. 그래서 문제가 생긴 프로세스를\n강제 종료할 때에는 아래와 같이 `kill -9`으로 `SIGKILL` 신호를 보내어 강제로\n종료한다.\n\n```bash\n$ kill -9 [pid]\n```\n\n### `SIGSTOP`과 `SIGTSTP`의 차이\n\n둘 다 프로세스에 멈추라는 신호를 보낸다. `SIGTSTP`은 주로 `tty`를 통하여\n키보드로 보내며 (보통 `ctrl-z`) 프로그램이 무시할 수 있는 반면 `SIGSTOP`은 \n`kill`등의 명령어와 조합하여 신호를 보내며 무시할 수 없다.\n\n프로세스가 멈추면 종료되는 것과는 다르게 일시중지된 상태로 현재 세션에\n남아있는다.\n\n```\n## \u003cc-z\u003e를 눌러 SIGTSTP 신호 보내기\n$ ruby test.rb\n^Z\nzsh: suspended  ruby test.rb\n\n## `kill` 명령어를 이용하여 SIGSTOP 신호 보내기\n$ ruby test.rb \u0026\n[2] 69330\n$ kill -17 69330\n[2]  + suspended (signal)  ruby test.rb\n\n## 일시 중지된 작업 보기\n$ jobs\n[1]  - suspended  ruby test.rb\n[2]  + suspended (signal)  ruby test.rb\n```\n\n이렇게 일시 중지된 작업들은 `fg` 명령어로 포어그라운드에서, `bg` 명령어로 \n백그라운드에서 작업을 재개할 수 있다. 이대로 종료하고 싶다면 `kill` 명령어로\n`SIGINT` 등의 신호를 보내면 된다.\n\n## 프로그래밍 언어에서\n\n## 러스트에서\n\n러스트에서는 표준 라이브러리만으로는 유닉스 신호를 처리하기 힘들다.\n표준 라이브러리로 `std::io::signal`이 있었으나, 처리를 위하여 운영체제에 의존한\n런타임 라이브러리가 필요해서 삭제된 것 같다.[^1] [CtrlC]와 같은  외부\n라이브러리를 이용하면 처리할 수 있다.\n\n[^1]: https://github.com/rust-lang/rust/pull/17673\n[CtrlC]: https://crates.io/crates/ctrlc\n\n## 참고\n\n- [Signal handling](https://rust-cli.github.io/book/in-depth/signals.html)\n- [signal(7) - Linux manual page][unix-signal]\n\n[unix-signal]: https://man7.org/linux/man-pages/man7/signal.7.html\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9D%8C%EC%95%85":{"title":"음악","content":"\n## 음악의 3요소\n\n- 멜로디 - 스케일, 릭, 아르페지오, …\n- 화음 - 컴핑, 보이스\n- 리듬 - 스윙\n\n## 코드이론\n\n- [[스케일]]\n- [[다이어토닉 코드]]\n- [[3화음]]\n- [[7화음]]\n- [[텐션]]\n- [[화성학 표기]]\n- [[여러가지 코드진행]]\n- [[귀카피 하는 법]]\n\n## 기타 주법\n\n- [[6번줄이 근음인 코드폼]]\n\n## 참고\n\n- 요우후 타카시, 기타로 배우는 음악이론.\n- 박터틀, [재즈의 시작! 워킹베이스를 배워야하는 이유!](https://www.youtube.com/watch?v=teUNGla32go\u0026list=PLz2DZwpMv5DJ0QN6uIudh-Wp_jRA7tuhP\u0026index=7). 2022.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9D%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC":{"title":"이 사이트에 대하여","content":"\n\n이 사이트(혹은 저장소)는 제가 배운 것을 스스로를 위하여 정리하기 위하여 만들었습니다. 글을 읽으시거나 인용하시는 경우 아래를 유의하셔야겠습니다:\n\n- 글의 내용이 옮지 않을 수 있습니다.\n- 글의 주소가 영구하지 않을 수 있습니다.\n- 과거의 저의 생각에 지금의 제가 동의하지 않을 수 있습니다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%8A%94-%EB%AA%87%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C":{"title":"인덱스는 몇부터 시작해야할까","content":"\n## 1부터 시작하는 언어\n\n## 0부터 시작하는 언어\n왜 0부터 시작하는가?\n\n## 그 외의 언어","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0":{"title":"자료구조","content":"\n\n\u003e 나쁜 프로그래머는 코드를 신경씁니다. 훌륭한 프로그래머는 자료구조와 자료구조 사이의 관계를 신경씁니다. —  [리누스 토르발즈, 2006](https://lwn.net/Articles/193245/)\n\n\u003e 올바른 자료구조로 구성했다면 알고리즘은 언제나 자명합니다. 알고리즘이 아니라 자료구조가 프로그래밍의 핵심입니다. —  [롭 파이크, 1989](http://doc.cat-v.org/bell_labs/pikestyle)\n\n## 추상 자료형\n\n- [[추상 자료형]]\n- [[선형 리스트]] -- 배열, 동적배열, 선형리스트\n- 스택\n- 큐\n- [[딕셔너리]]\n- 우선 순위 큐\n- [[서로소 집합]]\n- 이진 검색 트리\n- [[최소 신장 트리]]\n\n## 알고리즘을 개발하기 위한 단계\n\n1. 문제를 모델링하기\n2. 문제를 해결하기 위한 알고리즘을 찾아 써보기\n3. 효율적인지 확인하기\n4. 다른 방법이 더 있는지 확인하고 개선하기\n\n## 참고\n\n- [[알고리즘]]\n- [2015-2017 가을학기 자료구조 및 실습 - YouTube](https://www.youtube.com/playlist?list=PL52K_8WQO5oXIATx2vcTvqwxXxoGxxsIz)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%9E%91%EB%AA%85-5%EA%B0%9C%ED%95%AD":{"title":"작명 5개항","content":"\n1. 상황\n\t- 아상황\n\t- 적상황\n2. 임무\n3. 실시\n4. 전투 및 지원\n5. 지휘 및 통신","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%A0%90%EC%A7%84%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91":{"title":"점진적 타이핑","content":"\nGradual typing.\n\n어떤 타입이나 표현식은 컴파일 타임에, 어떤 표현식은 런타임에 검증하는 타입 시스템.\n정적 언어의 컴파일 타임 검증과 동적 언어의 빠른 이터레이션을 둘 다 누릴 수 있다.\nTypeScript, Python처럼 동적 언어에서 정적 타이핑 도구를 도입하며 각광 받기 시작했다.\n\n## 참고\n\n- [What is Gradual Typing](https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)\n- [漸進的型付けとは何か](https://qiita.com/t2y/items/0a604384e18db0944398)\n- [Gradual typing](https://en.m.wikipedia.org/wiki/Gradual_typing)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84":{"title":"제어의 역전","content":"\nInversion of Control","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%A0%9C2%EC%9D%98-%EB%87%8C":{"title":"제2의 뇌","content":"\n\n## 참고\n\n- Tiago Forte, [BUILDING A SECOND BRAIN](https://www.buildingasecondbrain.com/course)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%B0%B8%EA%B3%A0":{"title":"참고","content":"\n오류를 줄이기 위하여 신뢰 있는 출처에 근거하여 글을 적고 참고하였음을 기재하자.\n\n- 각주는 `[^1]` 처럼 표기한다.\n\t- 글의 아래의 아래와 같이 남긴다.\n\t- `[^1]: 저자명, *제목*, 쪽수.`\n- 글 마지막에 `H2` 참고 헤더를 만들어서 참고 자료를 적는다.\n\t- 목록으로 아래와 같이 남긴다.\n\t- `저자명, *제목*. 출판사, 년도.`\n\t- 웹 페이지면 링크를 남긴다.\n\n## 참고\n\n- [카피킬러 출처표기법 가이드](https://citation.sawoo.com/ref/guide/chicago)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1":{"title":"참조 투명성","content":"\n어떤 표현식이나 함수가, 그에 대응하는 값으로 바꾸었을 때 프로그램의 동작이 바뀌지 않으면, 참조 투명성(*referential transparency*)을 만족한다고 할 수 있다. 참조 투명성을 만족하려면 [[부수 작용]]이 없어야 한다. 다른 말로 순수해야한다.\n\n예를 들어 아래의 코드는 참조 투명하다. `x == y` 일 경우 `increse(x) == increse(y)`이다.\n\n```rb\ndef increse(x) = x + 1\n```\n\n아래의 코드는 반대로 참조 불투명하다. `increse()`를 호출할 때마다 반환값이 달라지며, 변수 `@counter`의 상태도 변한다. `increse()`가 부수 효과가 있는 함수이기 때문이다.\n\n```ruby\n@counter = 0\ndef increse = @counter += 1\n```\n\n참조 투명성을 만족하는 함수는 인간이든 기계든 분석하기 쉽다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC":{"title":"최소 신장 트리","content":"\n\nMST; minimum spanning tree\n\n그래프 $G = (V, E)$가 있을 때\n\n- **트리**란, 사이클이 없는 연결 그래프이다.\n- **$G$의 신장 트리**란, $G$의 부분 그래프로서 $G$의 모든 정점을 포함하는 트리이다.\n- **$G$의 최소 신장 트리**란, $G$의 신장 트리 중 가중치의 합이 최소가 되도록 하는 트리이다.\n\n최소 신장 트리를 구하는 알고리즘으로는 대표적으로 kruskal's algorithm과 prim's algorithm이 있다. 둘 다 한 번 한 결정을 번복하지 않는 욕심쟁이(greedy) 알고리즘이다.\n\n## Kruskal's Algorithm\n\n희소한 그래프에 유리하다.\n\n1. 비용이 가장 적은 간선을 찾는다.\n2. 해당 간선을 추가해도 사이클이 생기지 않으면 이를 추가한다.\n3. 모든 정점이 연결될 때까지 이를 반복한다.\n\n### 증명\n\n두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지. 먼저 신장 트리가 되는지 확인하자. 신장 트리가 되려면 다음의 세 조건을 만족해야한다.\n\n1. 사이클이 없어야 하고\n2. 연결 그래프여야 하고\n3. 모든 정점을 포함해야한다.\n\n귀류법으로 확인해보자. 가중치가 있는 연결 그래프 $G$에서 Kruskal 알고리즘으로 최소 신장 트리 $K$를 구했다고 하자.\n\n$K$에는 사이클이 없다. 간선을 추가할 때 사이클이 생기는지 확인하고 추가하니까 당연하다.\n\n$K$는 연결 그래프이다. $G$가 이미 연결 그래프이기 때문에 $K$가 연결 그래프가 아니려면 $G$의 특정 간선을 추가하지 않았어야 한다. 그 간선을 추가하지 않으려면 간선을 추가함으로써 사이클이 생긴다는 건데, 사이클이 있다는건 이미 연결된 상태라는 소리니까 말도 안 되는 소리다.\n\n$K$는 $G$의 모든 정점을 포함한다. $G$가 이미 연결 그래프이기 때문에 $K$에 사이클이 없고 끝까지 돈다면 모든 정점을 포함할 수 밖에 없다.\n\n따라서 kruskal 알고리즘으로 만든 $K$는 신장 트리이긴 하다. 그렇다면 가중치의 합이 최소가 되긴 하는가?\n\n최소 신장 트리가 존재하긴 할테다. 최소 신장 트리의 간선의 집합을 $T_{mst}$라고 라고, kruskal 알고리즘으로 만든 트리의 간선의 집합을 $T_k$라고 하자. 이 둘이 다르다고 가정하고 모순을 찾아보자. 귀류법이다.\n\n처음에는 $T_k$에 아무것도 없을 테니 $T_k \\subset T_{mst}$이다. 그런데 어느 순간에 $T_{mst}$에는 없는 간선 $\\{u, v\\}$가 추가되어 $T_k \\not\\subset T_{mst}$가 된다.\n\n$T_{mst}$에는 왜 $\\{u, v\\}$가 없을까? $u$와 $v$가 간접적으로 연결되어 있기 때문에 추가하는 순간 사이클이 생기기 때문일 것이다.\n\n그런데 말입니다. $T_k$와 $T_{mst}$ 둘 다 신장 트리의 간선의 집합이기 때문에 그 크기가 같다. 즉 $T_{mst}$는 $u$와 $v$를 연결하기 위해 다른 간선을 썼다는 뜻이다. 허나 kruskal 알고리즘은 간선을 비용이 낮은 순으로 연결하기 때문에 $T_{mst}$가 $\\{u, v\\}$ 대신 고른 간선보다 비용이 작거나 같다. $T_{mst}$가 최소 신장 트리라고 했으니 더 작을 수는 없고 같을 것이다. 따라서 $T_{mst}$의 비용과 $T_k$ 비용이 같으므로 $T_k$도 최소 신장 트리이다.\n\n### 구현\n\n구현의 핵심은 두 가지이다. 첫째, 간선들을 어떻게 정렬할 것인가? 둘째, 사이클이 있는지는 어떻게 확인할 것인가?\n\n간선 정렬은 그냥 정렬해도 되지만 최소 힙을 사용하여 해결할 수도 있다.\n\n사이클이 있는지는 DFS나 BFS를 이용하여 확인할 수도 있지만 그보다 UnionFind 자료구조를 이용하는 편이 효율적이다.\n\n위키피디아에 예쁜 의사코드가 있다.\n\n``` text\nKRUSKAL(G):\n  A = ∅\n  foreach v ∈ G.V:\n    MAKE-SET(v)\n  foreach (u, v) in G.E ordered by weight(u, v), increasing:\n    if FIND-SET(u) ≠ FIND-SET(v):\n      A = A ∪ {(u, v)}\n      UNION(u, v)\n  return A\n```\n\n### 시간 복잡도\n\n$O(E \\log E)$\n\n## Prim's Algorithm\n\n밀집 그래프에 유리\n\n1. 정점 v를 고른다. (이거다 싶은거 아무거나 고른다)\n1. 정점 v의 간선 중 비용이 가장 적은 간선을 추가한다. 이젠 정점이 두 개다.\n1. 두 정점의 간선 중 (서로를 연결하는거 말고) 비용이 가장 적은 간선을 추가한다.\n1. ...\n1. PROFIT!!\n\n### 증명\n\n마찬가지로 두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지.\n\n먼저 신장 트리가 되는지는 Kruskal 알고리즘과 같은 이유이다.\n\n그렇다면 가중치의 합이 최소가 되는가? 아까와 같은 방법으로 해보자. 그래프 $G$에 대해 어딘가 어떤 형태로든 존재하는 최소 신장 트리의 간선의 집합을 $T_{mst}$라고 하고, Prim 알고리즘으로 만들어낸 간선의 리스트를 $T_p$라고 하자. 처음에는 $T_p \\subset T_{mst}$인데 $T_p$에 $\\{u, v\\}$가 추가되는 순간 $T_p \\not\\subset T_{mst}$가 되었다고 하자. 왜 $T_{mst}$에는 간선 $\\{u, v\\}$가 없을까? $T_{mst}$는 신장 트리, 즉 연결 그래프이기 때문에 이미 정점 $u$와 $v$는 연결되어 있다. 따라서 간선 $\\{u, v\\}$를 추가하면 사이클이 생기게 된다.\n\n둘 다 신장 트리이므로 간선의 수는 같다. $\\{u, v\\}$ 대신 다른 간선이 그 역할을 하고 있다는 뜻이다. 그런데 Prim 알고리즘은 가중치가 작은 순으로 간선을 추가하므로 간선 $\\{u, v\\}$는 그 다른 간선보다 비용이 같거나 더 작다. $T_{mst}$가 최소 신장 트리라고 했으므로 더 작을 수는 없고 같을 것이다. $\\therefore T_p$는 최소 신장 트리이다.\n\n### 시간 복잡도\n\n$O(V^2+E) → O(E \\log V)$\n\n## 참고자료\n\n- [네이버캐스트/최소 비용 신장 트리 알고리즘: 가장 적은 비용으로 연결하려면?](https://terms.naver.com/entry.nhn?docId=3579408\u0026cid=59086\u0026categoryId=59093)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%B6%94%EC%83%81-%EC%9E%90%EB%A3%8C%ED%98%95":{"title":"추상 자료형","content":"\nADT; abstract data type. 한국어로는 추상 자료형이라고 한다. 자료형에 대한\n수학적 정의이다.\n\n추상 자료형은 두 가지로 정의한다.\n\n1. 무엇에 대한 자료형인가?\n2. 어떤 연산을 할 수 있는가?\n\n자료에 대한 표현이나 연산에 대한 구현은 생각하지 않는다.\n\n하나의 추상 자료형에 대해 여러 실제 구현이 있을 수 있다. 내가 사용하는 알고리즘이\n어떤 추상 자료형을 사용하고, 그 추상 자료형에 대해 여러 자료 구조 구현이 있으며,\n각 구현이 옳은 구현임이 확실하다면 내가 필요한 연산을 효율적으로 하는 자료구조를\n쉽게 고를 수 있다.\n\n추상 자료형으로 정의된 바와 실제 구현된 자료구조의 API는 구현자의 의도와 목적에\n따라 다소 다를 수 있다.\n\n예를 들어 일반적으로 연결 리스트는 선형 리스트의 구현체이다.\n선형 리스트가 표현하고자 하는 자료를 저장할 수 있고, 필요한 연산을 구현할 수 있다.\n그러나 연결 리스트의 특성상 인덱싱, 길이 구하기 등 연산이 비효율적이기 때문에\n구현할 때 API에서 이를 배제하기도 한다.\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%9D%B4%EB%A1%A0":{"title":"카테고리 이론","content":"\n\n**Category Theory for Programmers**를 읽고 정리합니다.\n\n- [[합성과 프로그래밍]]\n- [[타입은 집합이다]]\n\n## 참고자료\n\n- [Category Theory for Programmers -- Bartosz Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)\n- [hmemcpy/milewski-ctfp-pdf](https://github.com/hmemcpy/milewski-ctfp-pdf)\n- [Category Theory in Life - Eugenia Cheng](https://www.youtube.com/watch?v=ho7oagHeqNc)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B3%BC%ED%95%99":{"title":"컴퓨터 과학","content":"\n\n\u003e 컴퓨터 과학에서 컴퓨터란, 천문학에서의 망원경 이상의 것이 아니다. -- 에츠허르 다익스트라\n\nTODO: 컴퓨터 과학과 공학의 차이가 뭘까?\n\n- 수학\n\t- [[이산수학]]\n\t- [[카테고리 이론]]\n\t- [[알고리즘]]\n\t- [[자료구조]]\n\t- [[선형대수학]]\n- [[컴퓨터 구조]]\n- [[운영체제]]\n- [[컴퓨터 네트워크]]\n- [[데이터베이스]]\n- [[프로그래밍 언어]]\n- 미디어 처리\n- 인공지능\n\n\n\n## 참고\n\n- https://computationalthinking.mit.edu/Spring21/\n- [GitHub - ossu/computer-science: Path to a free self-taught education in Computer Science!](https://github.com/ossu/computer-science)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0":{"title":"컴퓨터 구조","content":"\nsometihng","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC":{"title":"컴퓨터 네트워크","content":"\n## 참고\n\n[컴퓨터네트워크 - 한양대학교 | KOCW 공개 강의](http://www.kocw.net/home/search/kemView.do?kemId=1312397)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%EC%BD%94%EB%93%9C-%ED%91%9C%EA%B8%B0":{"title":"코드 표기","content":"\n\n## 특정 코드를 표기할 때\n- 근음 - 3 - 5 - 7 순으로 표기한다.\n- 3도: 메이저일 경우 표기하지 않는다. 마이너일 경우 m으로 표기한다.\n- 5도: \n\n## 코드 진행을 표기할 때\n\n- 해당 조에서 몇 번째 화음인지를 로마자로 표기한다.\n\t- C장조에서 I는 C이다.\n- 메이저는 대문자, 마이너는 소문자로 표기한다.\n\t- ii V I는 C장조에서 Dm, G, C이다.\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%82%A4-%EC%9E%85%EB%A0%A5-%EC%BB%A4%EC%8A%A4%ED%85%80%ED%95%98%EA%B8%B0":{"title":"키 입력 커스텀하기","content":"\n\n## Karabiner-Elements\n\n```bash\nbrew install karabiner-elements\n```\n\n내장 키보드를 쓸 때 아래와 같이 커스텀하자:\n\n-   캡슬락(\u003ckbd\u003e한/A\u003c/kbd\u003e) 버튼을 짧게 누르면 ESC로 동작\n-   캡슬락(\u003ckbd\u003e한/A\u003c/kbd\u003e) 버튼을 누르고 있으면\n    -   \u003ckbd\u003eH\u003c/kbd\u003e, \u003ckbd\u003eJ\u003c/kbd\u003e, \u003ckbd\u003eK\u003c/kbd\u003e, \u003ckbd\u003eL\u003c/kbd\u003e 키가 좌, 하, 상, 우로 동작\n    -   백스페이스가 \u003ckbd\u003edelete\u003c/kbd\u003e로 동작\n\n[macOS에서 Vim 방향키 사용하기 | 하나씩](https://annyeong.me/notes/dev-env/use-vim-arrow-in-macos)\n\n## Hammerspoon\n\n```bash\nbrew install hammerspoon\n```\n\n기본 설정 파일 위치가 `~/.hammerspoon`인데, `XDG_CONFIG` 디렉토리를 쓰고 싶다면 아래의 명령어로 `~/.config/hammerspoon`으로 바꾸면 된다.\n\n```bash\ndefaults write org.hammerspoon.Hammerspoon MJConfigFile \"~/.config/hammerspoon/init.lua\"\n```\n\n바꾸고 아래의 설정파일을 심볼릭 링크\n\n[.dotfiles/hammerspoon at main · nyeong/.dotfiles](https://github.com/nyeong/.dotfiles/tree/main/hammerspoon)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%83%80%EC%9E%85%EC%9D%80-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%8B%A4":{"title":"타입은 집합이다","content":"\n\n타입을 집합으로 생각해보자.\n\n정수 타입 `i32`를 생각해보자. 보통 이 타입은 구간 $[-2^{31},2^{31} - 1]$에 속한\n정수를 표현할 수 있다. 구간 내의 정수를 원소로, 타입 `i32`를 집합으로 볼 수\n있다.\n\n$$\n\\text{i32} = \\{x\\mid -2^{31}, \\cdots, -1, 0, 1, \\cdots, 2^{31} - 1\\}\n$$\n\n`i32`를 인자로 취하는 함수를 생각해보자. 아래의 함수 `i32`는 수를 제곱해준다.\n따라서 반환 타입도 `i32`이다.\n\n```rust\nfn square(n: i32) -\u003e i32 { n * n }\n```\n\n이를 집합으로 생각해보자. 함수 $\\operatorname{square}$는 $\\text{i32}$를 취하여\n$\\text{i32}$를 반환하는 함수이다.\n\n$$\n\\operatorname{square}: \\text{i32} \\rightarrow \\text{i32}\n$$\n\n타입을 집합으로 생각하면 아래처럼 볼 수 있다:\n\n- 값은 원소이다.\n- 타입은 가능한 값들의 집합이다.\n- 함수는... 함수이다. 집합의 함수가 그러하듯 어떤 타입을 다른 타입과 이어준다.\n\n## 사실 집합은 아니다\n\n그러나 프로그래밍 언어는 컴퓨터에 내리는 명령이고, 정의만으로 끝나는 것이 아니라\n실제로 수행하는 작업의 나열이다. 어떤 때에는 작업이 끝나지 않을 수도 있다.\n그리고 작업이 끝나지 않는 것을 미리 알 수 있는 방법은 없다.[^1]\n\n[^1]: https://en.wikipedia.org/wiki/Halting_problem\n\n```rust\nfn some_function(arg: bool) -\u003e bool;\n// 이 함수가 정상적으로 `bool`을 반환하지 않을 수도 있다.\n```\n\n위의 함수가 정상적으로 `bool`을 반환한다는 것은 보장할 수 없다.\n무한 루프에 빠질 수도 있고, 무한 재귀에 빠질 수도 있고, 예외가 발생할 수도\n있고, 에러가 날 수도 있고, 프로그램이 강제 종료 될 수도 있다.\n아니면 결과가 나오기 전에 컴퓨터가 폭발하여 사라질 수도 있다.\n\n\n따라서 끝나지 않는 작업(*non-terminating computation*)을 표현하기 위하여\n*bottom*이라는 값이 도입되었다. $\\bot$으로 표기한다.\n모든 타입은 `⊥`을 값으로 갖는다. 특정 타입을 반환할 때만 안전하리라는 보장이\n없기 때문이다. 따라서 `bool` 타입은 `true`, `false`, `⊥`을 값으로 취한다.\n\n`⊥`도 `bool` 타입이기 때문에 아래의 코드는 정상적으로 컴파일된다.\n그리고 의도대로 `true`도 `false`도 아닌 `⊥`을 반환할 것이다.\n\n```rust\nfn some_function(_arg: bool) -\u003e bool {\n    panic!()\n}\n```\n\n`⊥`의 존재로 프로그래밍 언어의 타입은 엄밀히 말하여 집합은 아니다. 그러나\n`⊥`만 제외한다면 집합과 유사하기 때문에 집합으로 생각하여도 괜찮다.\n\n## 타입은 집합이다\n\n타입을 집합이라고 생각해도 괜찮다. 타입을 집합으로 생각하면 프로그램을 분석하기\n쉬워진다.\n\n프로그램이 옳은지 분석하고 검증하는 것은 어려운 일이다. 프로그램을 함수의\n결합(*composition*)으로 생각하고, 유효한 결합인지 검증하는 것은 훨씬 쉽다.\n또한 프로그래밍 언어는 각 언어 설계자의 취향과 의도에 따라 서로 다른 용어를\n사용하는데, 이를 집합으로 봄으로써 동일한 언어와 용어로 분석할 수 있다.\n\n### 공집합\n\n공집합(*empty set*)은 아무런 원소가 없는 집합이다. $\\varnothing$ 혹은 $\\{\\}$로\n표기한다. 공집합에 대응하는 타입을 상상해보자.\n\n```rust\nenum EmptySet {}\nlet some_value: EmptySet = ???;\n```\n\n`EmptySet`이라는 타입은 존재하지만 그 타입에 속하는 값이 존재하지 않는다.\n`EmptySet`을 인자로 취하는 함수를 상상해보자.\n\n```rust\nfn absurd(arg: EmptySet) -\u003e T;\n```\n\n위 함수를 호출할 수 있을까? `EmptySet`을 인자로 취하기 때문에 값을 넘겨주어야\n하지만 `EmptySet` 타입인 값은 존재하지 않는다. 따라서 위의 함수는 호출할 수 없다.\n\n```rust\nabsurd(???); // 인자로 넘겨줄 값이 존재하지 않다.\n```\n\n`EmptySet`을 반환하는 함수는 만들 수 있을까? 얼핏보아서는 불가능할 것 같다.\n반환하면 `EmptySet`의 원소를 메모리에 표현해야하는데, 존재하지 않는 것을 메모리에\n표현할 수는 없다.\n\n그럼에도 `EmptySet`을 반환하는 함수를 정의하고 실행할 수 있다. 말장난 같지만 \n끝나지 않는 작업을 $\\bot$이라는 값으로 정의하였고, 모든 타입은 $\\bot$을 원소로\n갖기 때문에 공타입 `enum EmptySet {}` 또한 $\\bot$을 원소로 취한다.\n\n따라서 아래 함수는 정의할 수 있고, 컴파일되고, 실행할 수 있다.\n아래가 바로 공타입을 반환하는 함수이다. 정말 대단해.\n\n```rust\nfn some_function() -\u003e EmptySet {\n    loop {}\n}\n```\n\n러스트에서는 원시타입으로 [never](https://doc.rust-lang.org/std/primitive.never.html)가 정의되어 있으며 `!`[^1]로 표기하기 때문에\n*bang-type*이라고도 부른다. 위의 `EmptySet`은 `!`로 대체할 수 있다.\n\n대체 이걸 어디다 써먹는단 말인가? 위에서 보았듯이 공타입은 오로지 $\\bot$, 즉\n**반환이 없음**만을 그 값으로 취할 수 있다. 따라서 이를 표현하는 타입으로 활용할 수 있다. \n문제가 있는 경우를 타입으로 표기함으로써 이를 타입 시스템에서 파악할 수 있다.\n\n현재 프로세스를 종료하는 러스트 표준 함수 `std::process::exit`의 타입은 아래와 같다:\n\n```rust title=\"std::process\"\npub fn exit(code: i32) -\u003e !\n```\n\n반환형이 `!`이기 때문에 이 함수가 실행되면 다음 작업을 실행할 수 없음을 알 수 있다.\n덕분에 컴파일러가 아래처럼 실행 전에 미리 경고해줄 수 있다.\n\n```rust\nfn main() {\n    std::process::exit(0);\n//  --------------------- any code following this expression is unreachable\n    println!(\"Hello, World!\");\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n}\n```\n\n[^1]: https://rust-lang.github.io/rfcs/1216-bang-type.html\n\n\n### 단위 집합\n\n단위 집합(*unit set*)은 단 하나의 원소만을 갖고 있는 집합이다.\n원소가 하나니까 싱글톤(*singleton*)이라고도 불리운다. 싱글톤 패턴의 그 싱글톤 맞다.\n\n싱글톤 패턴은 어떤 클래스에 대한 인스턴스가 오직 단 하나만 존재하도록 하는\n디자인 패턴이다. 아래의 예시에서 변수 `x`, `y`, `z` 모두 같은 싱글톤 인스턴스를\n가리키고 있다. 인스턴스가 단 하나이기 때문에 싱글톤이라는 이름이 붙었다:\n\n```java\nclass Singleton {\n    private static Singleton instance = null;\n    private Singleton() { /* initiating Singleton object */ }\n    public static Singleton getInstance() {\n        if (instance == null)\n            instance = new Singleton();\n        return instance;\n    }\n}\n\n// in other methods...\nSingleton x = Singleton.getInstance();\nSingleton y = Singleton.getInstance();\nSingleton z = Singleton.getInstance();\n```\n\n어떤 언어에서는 특별한 값을 나타내기 위해 단위 타입을 사용한다.\n루비의 `true`, `false`, `nil` 등의 값은 `TrueClass`, `FalseClass`, `NilClass`의\n유일한 값이다. 따라서 이들은 단위 타입이다.\n\n```ruby\nirb\u003e true\n=\u003e true\nirb\u003e true.class\nTrueClass\n```\n\n`TrueClass`의 원소는 ($\\bot$을 제외하면) `true` 말고는 없다.\n\n$$\n\\text{TrueClass} = \\{\\text{true}\\}\n$$\n\n단위 타입은 사실 암묵적으로 정말 많이 쓰이고 있다. 아래의 예시를 통해 알아보자.\n아래의 함수 `hello_world`는 아무 인자를 취하지 않고 `String`을 반환하고 있다.\n아무것도 아닌 것을 인자로 취하는 공타입과는 구별된다.\n\n```rust\n// 인자를 취하지 아니함\nfn hello_world() -\u003e String { /* ... */ }\n// 인자를 넘기지 않아도 실행된다\nlet hi = hello_world();\n\n// 아무것도 아닌 것을 인자로 취하는 공타입과는 다르다\nfn hello_world(arg: !) -\u003e String { /* ... */ }\n// 아무것도 아닌 것을 인자로 넘길 수는 없다...\nlet hi = hello_world(???);\n```\n\n정말 아무것도 취하지 않고 `String`을 반환한다면 사실상 `String`과\n동일해야 한다. 그러나 `hello_world`는 `String`은 아니다.\n아래의 예시는 타입 에러가 난다:\n\n```rust\nfn hello_world() -\u003e String { /* ... */ }\nlet hello_string: String;\n\nfn print_it(arg: \u0026String);\nprint_it(\u0026hello_world);  // mismatched types\nprint_it(\u0026hello_string); // 문제 없음\n```\n\n`hello_world`는 그냥 `String`인 것이 아니라 **아무것도 아닌 무언가를 `String`으로\n바꿔주는 함수**이다. 아무것도 아닌 무언가의 역할을 할 것이 있어야 하는데 이\n암묵적인 역할을 단위 타입이 맡는다. 러스트에서는 이를 [`()`](https://doc.rust-lang.org/stable/std/primitive.unit.html)으로 표기하고\n유닛이라고 읽는다. `hello_world` 함수를 인자로 받는 함수는 아래와 같다:\n\n```rust\nfn print_it(arg: dyn \u0026Fn() -\u003e String);\nprint_it(\u0026hello_world);\n```\n\n아무것도 반환하지 않는 함수도 사실은 아무것도 아닌 무언가를 반환하고 있다.\n아래의 셋은 동일하다:\n\n```rust\nfn main() { /* ... */ }\nfn main() -\u003e () { /* ... */ }\nfn main() { return (); } // () 타입은 그 값도 ()로 표기한다.\n```\n\nC계열 언어에서는 반환값이 없는 함수를 표현할 때에 `void`로 선언하기 때문에\n좀 더 명시적으로 확인할 수 있다.\n\n```c\nvoid function_no_return() { /* ... */ }\n```\n\n단위 타입을 이용함으로써 아무것도 아님을 표현할 수 있다.\n\n어떤 타입 `T`를 받아 단위 타입을 반환하는 함수는 타입 별로 딱 하나만 존재한다.\n예를 들어 `bool -\u003e ()`인 함수는 아래의 함수 외에는 존재할 수 없다.\n\n```rust\nfn unit(_: bool) -\u003e () { return (); } \n```\n\n반대로 단위 타입을 받아 어떤 타입 `T`를 반환하려면, 타입 `T`의 원소 수만큼\n함수를 만들 수 있다. 예를 들어 `() -\u003e bool`인 함수는 아래의 두 함수가 있다.\n\n```rust\nfn true() -\u003e bool { true }\nfn false() -\u003e bool { false }\n```\n\n### 원소가 둘인 집합\n\n원소가 둘인 집합은 그 값이 이거 아니면 저거인 집합이다.\n\n```rust\nenum Boolean {\n    True,\n    False,\n}\n```\n\n우리에게 친숙한 원소가 둘인 집합은 바로 `bool`이다. `0`, `1`도 좋고\n`true`, `false`도 좋다. 어쨌든 원소는 둘뿐이어야한다.\n\n$$\n\\text{bool} = \\{\\text{true}, \\text{false}\\}\n$$\n\n`bool`을 취하여 `bool`을 반환하는 함수는 몇 개나 있을까? 집합 $F$의 갯수를\n생각해보자.\n\n$$\nF = \\{ f \\mid f : \\text{bool} \\rightarrow \\text{bool} \\}\n$$\n\n아래와 같이 항등함수 두 개(`always`, `never`), 단위함수 하나(`id`), `not` 함수까지\n총 네 개를 생각할 수 있다.\n\n```rust\nfn always(_: bool) -\u003e { true }\nfn never(_: bool) -\u003e { false }\nfn id(b: bool) -\u003e { b }\nfn not(b: bool) -\u003e {\n    match b {\n        true -\u003e false,\n        false -\u003e true,\n    }\n}\n```\n\n우리가 흔히 쓰는 \"boolean 타입\"과 완벽히 대응함을 알 수 있다.\n\n### 합집합\n\n두 집합 A, B가 있을 때, 두 집합의 모든 원소를 가지고 새로운 집합을 만들\n수 있다. 새로운 집합 $A \\cup B$의 원소는 본래 $A$의 원소이거나 $B$의 원소이다.\n이를 합집합(*union*)이라 부르고 아래처럼 정의한다:\n\n$$\nA \\cup B = \\{ x \\mid x \\in A \\lor x \\in B \\}\n$$\n\n합집합에 대응하는 타입은 합타입(*union type* 혹은 *sum type*)이다.\n합타입을 이용하면 타입을 확장할 수 있다.\n아래의 예시에서 `Number`의 원소는 `i64`의 원소이거나 `f64`의 원소이다:\n\n```rust\nenum Number {\n    Int(i64),\n    Float(f64),\n}\nlet a: Number = Int(3);\nlet b: Number = Float(1.1);\n```\n\n어떤 언어는 다음처럼 쉽게 합집합을 표현할 수 있도록 한다. \n\n```typescript\nfunction padLeft(value: string, padding: string | number);\n```\n\n위의 `enum`으로 표현한 합타입과 밑의 `|`로 표현한 합타입은 무슨 차이가 있을까?\n같은 타입을 합쳤을 경우를 살펴보자:\n\n```typescript\nlet bnb = boolean | boolean;\n```\n\n`|`로 같은 타입을 합집합을 만들 경우 본래의 타입과 다를 바가 없다. 같은 집합의\n원소를 모으면 본래의 집합과 동일하다.\n\n$$\n\\begin{aligned}\n\\text{BnB} \u0026= \\{ x \\mid x \\in \\text{boolean} \\lor x \\in \\text{boolean} \\}\\\\\n\u0026= \\{ x \\mid x \\in \\text{boolean} \\}\\\\\n\u0026= \\{\\text{true}, \\text{false}\\}\n\\end{aligned}\n$$\n\n```rust\nenum BnB {\n    B1(bool),\n    B2(bool),\n}\n```\n\n타입 생성자(위의 `B1`, `B2`)와 함께 정의한 경우 그냥 합집합이 아니라 서로소\n합집합(*disjoint union*)이 된다. `B1`으로 정의하는 `bool`과 `B2`로 정의하는\n`bool`은 서로 다른 타입이다. 값도 동일하지 않다. `B1(true)`과 `B2(true)`는\n다른 값이다. 따라서 타입 `BnB`의 가능한 값은 총 네 가지이다.\n\n$$\n\\begin{aligned}\n\\text{BnB}\n \u0026= \\{x \\mid x \\in \\text{bool}_1 \\lor x \\in \\text{bool}_2 \\}\\\\\n \u0026= \\{\\text{true}_1, \\text{false}_1, \\text{true}_2, \\text{false}_2\\}\n\\end{aligned}\n$$\n\n### 교집합\n\n합집합이 있으므로 교집합도 있지 않을까?\n$A \\cap B$는 $A$의 원소이면서 동시에 $B$의 원소인 값들의 집합이다.\n\n$$\nA \\cap B = \\{x \\mid x \\in A \\land x \\in B\\}\n$$\n\n### 곱집합\n\n집합을 합할 수 있으므로 곱할수도 있다. 곱집합(*product set*)은 두 집합의 원소로\n만들 수 있는 가능한 모든 쌍의 집합으로 정의한다.\n\n$$\nA \\times B = \\{(a, b) \\mid a \\in A \\land b \\in B \\}\n$$\n\n곱타입은 구조체(*struct*) 혹은 튜플로 정의할 수 있다. 이를 이용하면\n타입을 조합할 수 있다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%85%90%EC%85%98":{"title":"텐션","content":"\n코드 위에 더 쌓은 음. \n\nC\u003csup\u003e△7(9, 13)\u003c/sup\u003e\n\n표기할 때에는 위처럼 9도, 11도, 13도로 표기한다.\n\n- 코드: R부터 시작하여 3도씩 쌓은 3~4화음 (1 - 3 - 5 - 7)\n- 텐션: 화음 위로 3도씩 쌓은 추가음 (9 - 11 - 13)\n\n실제로 옥타브 위의 음을 연주할 필요는 없기에, 2, 4, 6음으로 생각해도 좋다.\n\n메이저 다이아토닉 코드별로 사용 가능한 텐션은 아래와 같다.\n\n| 코드          | I\u003csup\u003e7(9, 13)\u003c/sup\u003e | ii\u003csup\u003e7(9, 11)\u003c/sup\u003e | iii\u003csup\u003e7(11)\u003c/sup\u003e | IV\u003csup\u003e7(9, #11, 13)\u003c/sup\u003e | V\u003csup\u003e7(9, 13)\u003c/sup\u003e | vi\u003csup\u003e7(9, 11)\u003c/sup\u003e | vii\u003csup\u003e7(b5, 11, b13)\u003c/sup\u003e |\n| ------------- | -------------------- | --------------------- | ------------------- | -------------------------- | -------------------- | --------------------- | ---------------------------- |\n| 텐션          | 9, 13                | 9, 11                 | 11                  | 9, #11, 13                 | 9, 13                | 9, 11                 | 11, b13                      |\n| 어보이드 노트 | 11                   | 13                    | b9, b13             |                            | 11                   | b13                   | b9                             |\n","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%8C%8C%EC%9D%B8%EB%8D%94-%ED%83%80%EC%9D%B4%ED%8B%80%EB%B0%94-%EC%95%84%EC%9D%B4%EC%BD%98-%EB%94%9C%EB%A0%88%EC%9D%B4-%EC%A1%B0%EC%A0%88":{"title":"파인더 타이틀바 아이콘 딜레이 조절","content":"\n\n![](assets/title-view-rollover.mov)\n\nmacOS Big Sur부터 타이틀바의 아이콘은 기본적으로 숨겨져 있고, 마우스를 올려야 나온다.\n\n타이틀바에 아이콘을 계속 표시하려면 아래의 명령어를 Terminal에 입력한다:\n\n```bash\ndefaults write com.apple.Preview NSWindowSupportsAutomaticInlineTitle -bool false \u0026\u0026 killall Finder\n```\n\n계속 표시하지는 않되, 마우스를 올리면 딜레이 없이 바로 나오게 하고자 하면 아래의 명령어를 입력한다:\n\n```bash\ndefaults write NSGlobalDomain \"NSToolbarTitleViewRolloverDelay\" -float \"0\" \u0026\u0026 killall Finder\n```","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%8F%AC%EA%B4%84%EC%A0%81-%EC%9D%B4%EB%A6%84-%EC%A7%93%EA%B8%B0":{"title":"포괄적 이름 짓기","content":"\n- [Inclusive Naming Initiative](https://inclusivenaming.org/)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4":{"title":"프로그래밍 언어","content":"\n프로그래밍 언어를 배울 때 알아야 하는 것들\n\n- 기본 도구와 생태계\n- 수를 다루는 방법\n  - 산술연산\n  - 논리연산\n- 문자열을 다루는 방법\n- 자료구조\n  - 리스트 등 내장 컨테이너\n  - 합타입, 곱타입\n- 제어구조\n  - 논리제어, 반복제어, 패턴매칭 등\n- 함수\n  - 익명함수, 클로저\n- 모듈과 파일 관리\n- 문서화\n- 예외를 처리하는 방법\n- [[다형성을 달성하는 방법]]\n- [[동시성을 다루는 방법]]\n- 해당 언어의 특징적인 부분\n  - [[프로그래밍 패러다임]]에 의존하는 것들\n- [[런타임]]에서 제공하는 기능들\n- 커뮤니티에서 권장하는 것들\n  - 스타일 가이드\n  - 커뮤니티 라이브러리\n\n## 참고\n- 코딩을 지탱하는 기술 -- 니시오 히로카츠\n- 컴퓨터과학이 여는 세계 -- 이광근","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84":{"title":"프로그래밍 패러다임","content":"- [합성으로 연결되는 함수형과 객체지향](https://twinstae.github.io/composable/)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4":{"title":"프로세스","content":"\n\n프로세스(*process*)는 하나 이상의 스레드로 돌아가는 컴퓨터 프로그램의 인스턴스이다.\n\n## 프로세스 문맥\n프로세스 문맥(*process context*)은 프로세스가 어떤 상태인지 알기 위해 필요한 정보이다.\n\n운영체제는 CPU 제어권을 서로 다른 프로세스에게 나눠주기 위해서 문맥을 효율적으로 교환(*context switch*)해야한다.\n\n## 프로세스 상태\n프로세스 상태(*process state*)는 \n\n- 실행(*running*)은 CPU 제어권을 얻어 작업을 실행하는 상태이다.\n- 준비(*ready*)는 CPU 제어권을 얻으면 작업을 바로 실행할 수 있는 상태이다.\n- 블록(*blocked*, *wait*, *sleep*)은 CPU 제어권을 얻어도 작업을 진행할 수 없는 상태이다. 디스크 I/O를 기다리는 상황 등이 이에 해당한다.\n- 멈춤(*suspended*)는 외부적인 이유로 프로세스가 멈춘 상태이다. 앞의 세 상태와는 다르게 외부에서 재개(*remuse*)해야한다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0":{"title":"프로세스 간 통신","content":"\n프로세스 간 통신(*interprocess communication*)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%97%98%EB%A6%AD%EC%84%9C":{"title":"프로세스 (엘릭서)","content":"\n액터 모델의 액터에 해당하는 단위를 엘릭서와 얼랭에서는 프로세스로 부른다.\n\n## 생성\n\n```elixir\n@spec spawn(module, atom, list) :: pid\n```\n\n`module`과 `atom`은 실행할 함수를, `list`는 넘길 인자 리스트를 의미한다.\n반환값인 `pid`는 프로세스 식별자이다.\n\n```elixir\niex\u003e spawn(SpawnBasic, :greet, [])\n```\n\n## 메시지 주고 받기\n\n`send/2` 함수와 `receive` 매크로로 프로세스끼리 메시지를 주고 받을 수 있다.\n\n### 보낼 때\n\n`send/2` 함수를 이용하여 보낸다. 첫 인수는 `pid`, 메시지를 받을 프로세스이다.\n두번째 인수는 `term()`으로 아무 값이나 보내도 된다.\n\n```elixir\niex\u003e pid = spawn(Module, :function, [])\niex\u003e send pid, {:ok, message}\n```\n\n### 받을 때\n\n`receive` 매크로로 해당 프로세스에 도착한 메시지를 받아본다.\n패턴매칭을 이용하여 메시지가 매칭되는 절을 실행한다.\n\n```elixir\nreceive do\n  {:ok, message} -\u003e\n    IO.puts message\nend\n```\n\n`receive` 매크로는 기본적으로 메시지를 받을 때까지 블록된다. 이를 원치 않으면\n`after` 절을 써서 타임아웃되도록 한다.\n\n```elixir\nreceive do\n  {:ok, message} -\u003e\n    IO.puts \"do something with #{message}\"\n  after 500 -\u003e\n    IO.puts \"timeout\"\nend\n```\n\n또한 기본적으로 한 번에 하나의 메시지만 처리하므로, 여러 메시지를 처리하기\n원한다면 재귀를 써야 한다.\n\n```elixir\ndef loop do\n  receive do\n    {:ok, message} -\u003e\n      IO.puts \"do something with #{message}\"\n  end\n  loop\nend\n```\n\n### 주고 받기\n\n메시지는 비동기적으로 전달된다. 보내는 쪽에서는 보내기만 할 뿐 별도로 응답을 받지 않는데, 필요한 경우 받는 쪽에서 도로 보내도록 하여서 응답을 받을 수 있다.\n\n`make_ref/0`는 고유한 레퍼런스를 하나 만든다. 처리 순서가 바뀌더라도 `ref` 값과 비교하여 받기 때문에 안전하다.\n\n```elixir\ndef print(content) do\n  ref = make_ref()\n  send(printer, {:print, content, self(), ref})\n  receive do\n    {:ok, ^ref, content} -\u003e content\n    {:error, reason} -\u003e # handle error\n  end\nend\n\n# printer에서...\ndef loop do\n  receive do\n    {:print, content, sender, ref} -\u003e\n      # print it\n      send(sender, {:ok, ref, content})\n  end\nend\n```\n\n프로세스는 엘릭서에서 상태를 다루는 방법 중 하나이다. 프로세스가 루프의 인자로\n상태를 들고 있으면, 다른 프로세스에서 활용할 수 있다.\n\n```elixir\n## a loop for stack process\ndef loop([h | l] = state) do\n  receive do\n    {:push, elem} -\u003e\n      loop([elem | state])\n\n    {:pop, caller} -\u003e\n      send caller, h\n      loop(l)\n  end\nend\n\niex\u003e send stack, {:push, 1}\niex\u003e send stack, {:pop, self()}\n```\n\n## 상태 다루기\n\n프로세서는 살아(*alive*)있을 수도, 에러로 인하여 죽어있을 수도 있다. 프로세스의 상태는 `Process.info/1`로 알 수 있다. 가능한 상태는 아래와 같다:\n\n- `:exiting`\n- `:garbage_collecting`\n- `:waiting`\n- `:running`\n- `:runnable`\n- `:suspended`\n\n```elixir\niex\u003e boom = fn -\u003e\n...\u003e   :timer.sleep 500\n...\u003e   exit :boom\n...\u003e end\niex\u003e pid = spawn(boom)\niex\u003e Process.info(pid, status) # 프로세스가 살아있어서 상태를 반환한다.\n{:status, :runnable}\niex\u003e Process.info(pid, status) # 프로세스가 죽어서 `nil`이 반환된다.\nnil\n```\n\n`Process.link/1` 함수로 현재 프로세스와 다른 프로세스를 링크할 수 있다. 프로세스를 링크하면 \n`spawn_link` 함수를 쓰면 생성과 링크를 한 번에 할 수 있다.\n\n```\niex\u003e spawn boom      # 아무 일도 일어나지 않는다\niex\u003e spawn_link boom # spawn한 프로세스가 `exit` 되므로 현재 프로세스도 종료된다.\n** (EXIT from #PID\u003c0.105.0\u003e) shell process exited with reason: :boom\n```\n\n`Process.monitor/1` 함수나 `spawn_monitor` 함수를 사용하면 단방향으로 프로세스를 연결할 수 있다.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%95%98%EB%82%98%EC%94%A9":{"title":"하나씩","content":"\n\n공부한 것을 하나씩 정리하기. 일종의 디지털 가든 혹은 [[제2의 뇌]](*second brain*).\n\n- 저장소: [nyeong/hanassig](https://github.com/nyeong/hanassig)\n\n이 문서에는 이 저장소를 어떻게 구성할 것인가에 대해 설명한다.\n\n## 목표\n\n중요한 순으로 작성하였다:\n\n1. 제텔카스텐 방법론 따르기.\n2. 로컬 먼저. 내 환경에서 먼저 편하게 쓸 수 있어야한다.\n\t1. obsidian과 helix 섞어쓰기.\n3. 잘 정돈된 한국어 용어로 쓰자.\n4. [[참고]]한 자료를 잘 적자.\n5. 웹에 게시할 수 있어야 한다.\n\n## 어떻게 할까\n\n- 디렉토리 구성\n\t- 단일 저장소로 웹 게시를 위한 구현과 무관하게 글만 다루자.\n\t- 나중에 jekyll을 쓰든, gatsby를 쓰든 이 저장소를 클론 뜨면 되도록 만들자.\n\t- 글의 구성을 철저하게 유지해야 나중에 일괄 처리가 쉽다.\n\t- 모든 글은 `notes/` 밑에 저장하자.\n\t- 모든 이미지는 `assets/` 밑에 저장하자.\n- 노트 구성\n\t- 파일 이름이 곧 글의 제목이 되도록 하자. 띄어쓰기도 허용하자.\n\t- frontmatter는 최소한으로 하자.\n\t\t- `title`로 글 제목\n\t\t- `tags`로 글 주제\n\t\t\t- tags의 각 요소는 띄어쓰기 대신 언더바(`_`)\n\t\t- 쓴 시간, 최근 수정한 시간은 필요할 듯.\n\t- 계층 구조는 굳이 하지 말자. 필요해지면 그때 고민하자.\n\t- 헤더는 `h1` 없이 `h2`로 시작한다. 제목은 파일 이름과 frontmatter로 보자.\n\t- `h2`부터 `h4`까지 쓰자. `h5`, `h6`이 필요한 순간이 되면 구성이 잘못된 것이다.\n\t- 같은 제목이 필요해질 경우 괄호나 계층으로 구분하자.\n\t\t- 예: 운영체제의 프로세스와 엘릭서의 프로세스\n- 링크\n\t- 외부 링크는 `[보여질 글](https://어쩌구.저쩌구)` 구문을 쓰자.\n\t- 내부 링크는 `[[파일 이름]]` 구문을 쓰자.\n\t\t- 파일 이름은 띄어쓰기를 허용하고 `notes/` 디렉토리를 기준으로 상대 경로로 하자.\n\t\t- `.md` 파일은 확장자를 생략하자.\n\t- 보여질 글을 바꾸고 싶으면 `[[파일 이름|보여질 글]]` 구문을 쓰자.\n\t- 헤더에 링크를 걸려면 `[[#헤더 이름]]` 구문을 쓰자.\n\t\t- 다른 글의 헤더에 걸려면 `[[파일 이름#헤더 이름]]`\n\t\t- 굳이 보여질 글을 바꾸려면 `[[파일 이름#헤더 이름|보여질 글]]`\n\t- 옵시디언의 아래 기능은 일단 쓰지 않는다:\n\t\t- `[[wikilink#^]]`으로 블록 링크하기\n\t\t- `![[wikilink]]`로 노트, 헤더, 블락 임베드하기\n\t\t- `#tag`로 태깅하기\n\t- 대부분의 글 마지막에 `## 참고`로 참고한 문헌 등 출처를 달자.\n\n### 디렉토리 구성\n\n```\n./\n├── bin/\n├── assets/\n│  └── 이미지 이름.jpg\n├── notes/\n│  └── 노트 이름.md\n└── README.md\n```\n\n`bin` 디렉토리는 나중에 스크립팅을 위해 예약해둠. frontmatter 체킹 등으로 활용할 수 있을 듯.\n\n## 발행하기\n\n- 현재는 아래의 방법으로 웹에 발행중.\n\t- URL: [annyeong.me](https://annyeong.me)\n\t- 저장소: [nyeong/nyeong.github.io](https://github.com/nyeong/nyeong.github.io)\n\t- 플랫폼: [jackyzha0/quartz](https://github.com/jackyzha0/quartz) (obsidian-hugo, hugo)\n- 좋은 점\n\t- 그래프 지원\n- 아쉬운 점\n\t- 그래프 동작이 가끔 이상함.\n\t\t- 없는 링크가 있다고 보여줌.\n\t\t- 글 제목 앞에 `/`를 붙여줄 때가 있음.\n\t\t- 링크는 잘 보여주는데 클릭 시 다른 곳으로 보내버림.\n\t- 헤더 링크(`[[#헤더]]`)에 대한 처리가 이상함.\n\t\t- 인식은 하는데 텍스트를 비워서 처리함 (`\u003ca href=\"..\"\u003e\u003c/a\u003e`)\n\n## 후속과제\n\n- lint가 필요하다.\n\t- 죽은 링크 검사하기.\n\t- 맞춤법 검사하기.\n\t- frontmatter 규칙 검사하기.\n- frontmatter를 자동으로 수정해줬으면 좋겠다.\n\t- 글 생성 시 `title` 자동으로 입력하기.\n\t- 수정한 시간, 만든 시간은 자동으로 업데이트 해줬으면.\n- 외톨이 글을 다룰 방법이 필요하다.\n\n## 참고하기\n\n- [MaggieAppleton/digital-gardeners](https://github.com/MaggieAppleton/digital-gardeners)\n- [TuanManhCao/digital-garden](https://github.com/TuanManhCao/digital-garden) ","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%95%A8%EC%88%98%ED%98%95-%EC%96%B8%EC%96%B4":{"title":"함수형 언어","content":"\n## 함수형 언어란\n\n- 순 함수로만 이루어져야하는가?\n- 함수를 1급 객체로 취급해야하는가?\n- 불변성을 지녀야하는가?\n- 지연 연산을 지원해야하는가?","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%95%A9%EC%84%B1%EA%B3%BC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D":{"title":"합성과 프로그래밍","content":"\n\n## 카테고리\n\n```\n+----------+  f  +----------+  g  +----------+\n| object a |----\u003e| object b |----\u003e| object c |\n+----------+     +----------+     +----------+\n     |               g∘f               ^\n     +---------------------------------+\n```\n\n카테고리는 대상(*object*)와 사상(*morphism*)의 모음이다.\n위 그림에서 네모는 대상, 화살표는 사상이다.\n위의 사상 $f$는 아래와 같이 표기한다. 대상 $a$에서 대상 $b$로 가는 사상이라는\n뜻이다.\n\n$$\nf: a \\rightarrow b\n$$\n\n위의 그림에서 사상 $f$와 $g$를 순서대로 따라가면 대상 $a$에서 대상 $c$로 도달할\n수 있다. 이를 합성(*composition*)이라고 하며 $g \\circ f$라고 쓴다. \n\n- 합성은 결합법칙(*associativitiy*)이 성립한다. 무엇을 먼저 합성하든 결과가 같아야한다.\n  $a \\xrightarrow f b \\xrightarrow g c \\xrightarrow h d$에 대하여 아래가\n  만족한다:\n  $$\n  h \\circ (g \\circ f) = (h \\circ g) \\circ f\n  $$\n\n- 모든 대상에 대해 항등 사상(*identity morphism*)이 존재한다. 항등 사상은\n  $id_a: a \\rightarrow a$와 같은 꼴이며 따라서 모든 사상 $f$에 대해 아래가 성립한다:\n  $$\n  id_b \\circ f = f \\circ id_a = f\n  $$\n\n위의 조건을 만족하기만 하면 무엇이든 대상과 사상, 즉 카테고리로 볼 수 있다. \n\n## 카테고리로서의 프로그래밍 언어\n\n프로그래밍 언어에서는 타입을 대상으로, 함수를 사상으로 볼 수 있다.\n아래의 하스켈, 엘릭서 코드의 함수 `f`를 위의 사상 $f$로 볼 수 있다.\n\n```haskell\nf :: a -\u003e b\n```\n\n```elixir\n@spec f(a) :: b\n````\n\n프로그래밍 언어를 카테고리로 보려면 합성이 가능해야하고, 합성에 대해 결합법칙과\n항등사상이 존재해야한다.\n\n먼저 합성이다. 이미 존재하는 $f$, $g$를 합성하여 새로운 함수를 만들고 이름을\n붙일 수 있다.\n\n```rust\nfn f(obj: A) -\u003e B;\nfn g(obj: B) -\u003e C;\nfn g_after_f(obj: A) -\u003e C {\n  g(f(obj))\n}\n```\n\n하스켈 같은 일부 언어는 언어 자체에서 함수의 합성을 지원한다. 아래의 두 줄은\n동일하다:\n\n```haskell\ng . f object\ng(f(object))\n```\n\n실제로 동작할 때에는 가장 오른쪽의 `f`부터 연산을 시작하기 때문에 시각적으로\n헷갈릴 수 있다. 이에 엘릭서 같은 일부 언어는 아래와 같은 함수의 합성을 지원한다.\n보통은 `pipe operator` 라는 이름으로 지원한다.\n\n```elixir\nf(object) |\u003e g()\n```\n\n프로그램의 합성을 상상해도 좋다. git 디렉토리에서 커밋 목록을 출력하는 프로그램\n`git log`와 문자열에서 줄 수를 세는 프로그램 `wc -l`을 합성하여 커밋의 수를\n출력하는 프로그램으로 바꿀 수 있다:\n\n```bash\ngit log --oneline | wc -l\n```\n\n프로그램의 함수의 합성도 결합법칙을 만족한다. 합성을 할 때에 무얼 먼저 합성하든\n결과는 동일하다:\n\n```haskell\nf :: a -\u003e b\ng :: b -\u003e c\nh :: c -\u003e d\n-- f, g, h에 대하여 아래의 두 합성은 동일하다.\nh . (g . f)\n(h . g) . f\n```\n\n```elixir\n@spec f(a) :: b\n@spec g(b) :: c\n@spec h(c) :: d\n\n## f, g, h에 대하여 아래의 두 합성은 동일하다.\n(f(a) |\u003e g()) |\u003e h()\nf(a) |\u003e (g() |\u003e h())\n```\n\n모든 대상에 대한 항등사상도 쉽게 만들 수 있다. 동적 언어의 경우 받은 값을 그대로\n돌려주기만 하면 된다.[^1]\n\n[^1]: https://hexdocs.pm/elixir/main/Function.html#identity/1\n\n```elixir\n@spec identity(value) :: value when value: var\ndef identity(value), do: value\n```\n\n제네릭을 지원하는 언어는 이를 이용하여 만들 수 있다[^2]:\n\n[^2]: https://doc.rust-lang.org/std/convert/fn.identity.html\n\n```rust\npub const fn identity\u003cT\u003e(x: T) -\u003e T {\n  x\n}\n```\n\n당연히 하스켈에서도 쉽게 정의할 수 있다. [^3]\n\n[^3]: https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:id\n\n```\nid :: a -\u003e a\nid x = x\n\nf . id == f\n```","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%96%89%EB%A0%AC":{"title":"행렬","content":"\nmatrix. 벡터를 나열한 것.\n\n$$\nX = \\begin{bmatrix}\nx_{1,1} \u0026 x_{1,2} \u0026 \\cdots \u0026 x_{1,n} \\\\\nx_{2,1} \u0026 x_{2,2} \u0026 \\cdots \u0026 x_{2,n} \\\\\n\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\nx_{m,1} \u0026 x_{m,2} \u0026 \\cdots \u0026 x_{m,n}\n\\end{bmatrix}\n$$\n\n## 성분\n\n- $x_{i,j}$: $i$행 $j$열의 수\n\n## 의미\n\n- 행벡터 혹은 열벡터의 모음으로 볼 수 있다.\n\t- 행벡터가 열만큼 모임\n\t- 열벡터가 행만큼 모임\n- 벡터와 벡터를 사상하는 함수로 볼 수 있다.\n\t- $m\\times n$인 행렬 $A$가 있다면 $\\mathbf{y}=A\\mathbf{x}$는 $n$차원 벡터 $\\mathbf{x}$를 $n$차원으로 보내는 연산이다.\n\n## 연산\n\n- $X^T$: 전치행렬\n- $X\\pm Y$: 같은 모양의 행렬끼리의 덧셈과 뺄셈\n- $X \\circ Y$: 성분곱\n- $cX$: 스칼라배\n- $XY$: 행렬곱\n\t- $XX^{-1}=X^{-1}X=I$\n\n### 행렬곱\n\n- 결합법칙이 성립한다.\n- 교환법칙이 성립하지 않는다.\n- $m \\times n$인 행렬 $A$와 $n \\times r$인 행렬 $B$의 곱 $AB$는 $m \\times r$ 행렬이다.\n\n## 여러가지 행렬\n\n- 단위행렬 $I$\n\t- $XX^{-1}=X^{-1}X=I$\n- 역행렬 $X^{-1}$\n\t- 행과 열이 같고, 행렬식이 0이 아니여야 역행렬이 존재한다.\n- 유사역행렬 $X^+$\n\t- $n \\ge m$일 때, $A^+ = (A^TA)^{-1}A^T$이고 $A^+A=I$\n\t- $n \\le m$일 때, $A^+ = A^T(AA^T)^{-1}$이고  $AA^+=I$\n\n## 활용\n\n- 연립방정식의 해 구하기\n- [[선형 회귀]]분석: 데이터를 최선의 선형 모델로 해석하기\n\n## 참고\n\n- 히라오카 카즈유키, *프로그래머를 위한 선형대수*. 길벗, 2017.","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/%ED%99%94%EC%84%B1%ED%95%99-%ED%91%9C%EA%B8%B0":{"title":"화성학 표기","content":"\n해당 페이지에 적힌 정보는 정확한 정보가 아닙니다. 적확한 레퍼런스 없이 독자적으로 관찰한 결과이므로 자료로서 부적합합니다.\n\n## 음 표기\n\n### 음의 상대 이름\n\n- 도, 레, 미, 파, 솔, 라, 시\n- 상대음이름법, 상대음고라고도 부르는 듯\n\n### 음의 절대 이름\n\n- C, D, E, F, G, A, B\n- 고정음이름법, 절대음고라고도 부르는 듯\n- 음가(=주파수) 그 자체를 부르는 이름이다.\n- 일반적으로는 A=440MHz를 기준으로 부른다.\n\n## 음정\n\n- 두 음이 얼만큼 차이가 나는가에 대한 표기\n- 화음을 설명할 때 편하다\n\t- 어그먼트 코드(증3화음) = 근음 + 장3도 + 증5도\n\t- R+ = R + 3 + #5\n\t- C+ = C + D + \\#F\n\n| 반음 거리 | C와 비교하면 | 음정    | 약식표기 |\n| --------- | ----- | ------- | -------- |\n| 0         | C     | 완전1도 | R        |\n| 1         | C#    | 단2도   | b2         | \n| 2         | D     | 장2도   |  2        |\n| 3         | D#    | 단3도   |  b3        |\n| 4         | E     | 장3도   |   3       |\n| 5         | F     | 완전4도 |     4     |\n| 6         | F#    |  증4도, 감5도       | #4, b5         |\n| 7         | G     | 완전5도 |      5    |\n| 8         | G#    | 단6도, 증5도   | #5, b6         |\n| 9         | A     | 장6도   |      6    |\n| 10        | A#    | 단7도   | b7         |\n| 11        | B     | 장7도   |       7   |\n| 12        | C     |         |       R   |\n\n## 화음\n\n### 화음의 상대 이름\n\n- Ⅰ, Ⅱ, Ⅲ, Ⅳ, Ⅴ, Ⅵ, Ⅶ, Ⅷ\n- 로마 숫자로 표기하고 ‘도’를 붙여서 읽는다. \n\t- 1도, 2도, 3도, …\n- 메이저는 대문자, 마이너는 소문자로 표기한다.\n- 디미니쉬(감3화음)는 º를 붙인다.\n- 어그먼트(증3화음)는 +를 붙인다.\n- 7화음에는 7을 붙인다.\n\n### 화음의 절대 이름\n\n- C, Dm, F+ 등\n- [[3화음]]\n- [[7화음]]\n- [[텐션]]코드\n\n## 참고\n\n- [악보를 200% 효과적으로 읽는 방법 - YouTube](https://www.youtube.com/watch?v=cUIYH1gDIh8\u0026list=PLz2DZwpMv5DJ0QN6uIudh-Wp_jRA7tuhP\u0026index=6)","lastmodified":"2023-02-05T06:08:11.427465401Z","tags":null},"/notes/-%EB%8C%80%EC%8B%A0-%EB%B0%B1%ED%8B%B1-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B8%B0":{"title":"₩ 대신 백틱 입력하기","content":"\n\n`~/Library/KeyBindings/DefaultkeyBinding.dict` 만들고 아래의 내용을 추가한다:\n\n```python\n{\n  \"₩\" = (\"insertText:\", \"`\");\n}\n```\n\n완료 후 재부팅한다.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/6%EB%B2%88%EC%A4%84%EC%9D%B4-%EA%B7%BC%EC%9D%8C%EC%9D%B8-%EC%BD%94%EB%93%9C%ED%8F%BC":{"title":"6번줄이 근음인 코드폼","content":"\n\n## 3화음\n\n\n\n## 7화음","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/7%ED%99%94%EC%9D%8C":{"title":"7화음","content":"\n[[3화음]]에 7음을 붙여 만든 화음. R + 3 + 5 + 7로 구성된다.\n\n| 표기 | 근음 | 3음 | 5음 | 7음 | 이름 |\n|------|------|-----|-----|-----|------|\n| R△7  | R    |  3  | 5   | 7   | 메이저 세븐스                                 |\n| R7   | R    |  3  | 5   | b7  | 도미넌트 세븐스                               |\n| Rm7  | R    |  b3 | 5   | b7  | 마이너 세븐스                                 |\n| RmM7 | R    |  b3 | 5   | 7   | 마이너-메이저 세븐스                          |\n| R\u003csup\u003eo7\u003c/sup\u003e  | R    |  b3 | b5  | 6   | 디미니시 세븐스                               |\n| Rø7  | R    |  b3 | b5  | b7  | 하프 디미니시 세븐스. Rm7b5로도 표기하곤한다. |\n| R+7  | R    |  3  | #5  | b7  | 어거먼트 세븐스.                              |\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/Corne-Keyboard":{"title":"Corne Keyboard","content":"\n3x6 사이즈 + 3 엄지 세로 스테거 스플릿 키보드\n\n![corne keyboard 사진](assets/crkbd.jpeg)\n\n[footsan/crkbd](https://github.com/foostan/crkbd)\n\n- 키캡: 까먹었다\n- 스위치: 게이트론 저소음 갈축\n  - 나중에 그냥 갈축으로 바꿔야지\n- MCU: ELITE-C, nice!nano\n- 케이스: 3D printed\n- 펌웨어: QMK, ZMK\n- 보드: crkbd cherry v2, crkbd choco v3\n- 배열: [[miryoku]] flip inverted T 변형\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/DIY":{"title":"DIY","content":"\n직접 만들어서 쓰는 것들.\n\n- 키보드 — [[Corne Keyboard]]\n- 라우터 — [[uirouter]]\n- 개인 서버 — [[UiBox]]\n- 디지털 가드닝 — [[하나씩]]","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/JWT":{"title":"JWT","content":"\nJWT; JSON Web Token은 인증, 허가 수단 등을 암호화하여 JSON 구조로 주고 받을 수 있는 웹 표준이다. 디지털 서명되어 신뢰성이 높은 것이 특징이다.\n\n표준인 [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)에 따르면 “jot”라고 읽는다.\n\n## 특징\n\n- 검증에 상태가 필요하지 않기 때문에 무상태 통신과 어울린다.\n- 토큰의 내용 자체는 암호화 되지 않는다. 암호화는 신뢰성을 담보할 뿐이다.\n- 담는 정보의 양에 따라 토큰의 크기가 커진다.\n\n## 흐름\n\n```mermaid\nsequenceDiagram\n\tparticipant 클라이언트\n\tparticipant 인증 서버\n\tparticipant 자원 서버\n\t클라이언트-\u003e\u003e인증 서버: 1. 토큰 요청\n\tactivate 인증 서버\n\t인증 서버-\u003e\u003e클라이언트: 2. 토큰 발급\n\tdeactivate 인증 서버\n\t클라이언트-\u003e\u003e자원 서버: 3. 자원 요청\n```\n\n### 토큰 요청\n\n클라이언트가 인증 서버에게 인증에 필요한 정보를 넘겨 토큰을 요청한다. 인증 수단으로 활용하는 경우, username과 password를 넘겨 인증 토큰을 발급받을 수 있다.\n\n### 토큰 발급\n\n클라이언트의 요청을 검증하여 유효한 경우 토큰을 발급한다.\n\n토큰은 header, payload, signature로 이루어져있는 문자열이다.\n\n- header — 암호화 알고리즘의 종류와 토큰의 종류 명시한다.\n- payload — 토큰에 담을 데이터\n- signature — 전자서명\n\nheader와 payload는 JSON이며, signature는 이를 명시된 해시 알고리즘으로 암호화한 것이다. 이에 대한 자세한 설명은 아래 [[#구현]] 참고.\n\n토큰은 최종적으로 base64로 인코딩되어 아래와 같은 문자열이 되어 클라이언트에게 보내진다. `.`을 구분자로 `header.payload.signature` 형태로 이루어져있다. 아래는 그 예시이다:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkhlbGxvIiwiaWF0IjoxNTE2MjM5MDIyfQ.r49ULQib9F6NVK7ReufLCEanG0m9rm76M2I5Ivjhb5c\n```\n\n### 자원 요청\n\n클라이언트는 발급받은 토큰을 이용하여 자원 서버에 원하는 자원을 요청한다. 아래처럼 HTTP 헤더에 `Authorization` 필드를 이용하여 토큰을 전달한다.\n\n```\nAuthorization: Bearer \u003ctoken\u003e\n```\n\n## 구현\n\n### Header\n\n헤더는 토큰의 타입과 암호화 알고리즘이 담는 JSON이다.\n\n```elixir\nheader = %{\n  alg: \"ES256\",\n  typ: \"JWT\"\n}\n\nencoded_header = header\n  |\u003e Jason.encode!()\n  |\u003e Base.url_encode64(padding: false)\n```\n\n이 암호화 알고리즘을 JWA; JSON Web Algorithms라고 부르며 [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)로 표준화되어있으며, 해당 문서 3.1절에 `alg` 값이 정의되어 있다.\n\n`HS256`은 구현체가 기본적으로 구현해야하는 알고리즘이며 대칭키 방식이다. `RS256`과 `ES256`은 구현에서 권장하는 알고리즘이며 비대칭 암호화 방식이다.\n\n비대칭 암호화 방식을 이용할 경우, 토큰을 발급할 때에는 비밀키로 암호화하고 발급한 토큰을 검증할 때에는 공개키로 복호화 하면 된다. 자세한 내용은 아래의 [[#Signature]] 참고.\n\n- `HS256`: HMAC + SHA-256\n- `RS256`: RSASSA-PKCS1-v1_5 + SHA-256\n- `ES256`: ECDSA + P-256 + SHA-256\n\n### Payload\n\n페이로드는 사용자 데이터, 권한 등을 담는 JSON이다. 각 데이터를 클레임(claim)이라 부른다. 일부 클레임은 표준에서 특별한 용도로 쓰기 위하여 예약되어있다. 이를 registered claim이라고 부른다. 발행자를 표기하기 위한 `iss`, 유효기간을 표기하기 위한 `exp` 등이 이에 해당한다.\n\n토큰에는 이를 base64로 인코딩한 값을 쓴다.\n\n```elixir\npayload = %{\n  hey: \"hello\"\n}\n\nencoded_payload = payload\n  |\u003e Jason.encode!()\n  |\u003e Base.url_encode64(padding: false)\n```\n\n### Signature\n\n시그니처는 인코딩한 header와 payload를 해싱한 후 header에서 정의한 방식으로 암호화 한 것이다. \n\n먼저 사용하는 JWA이 `ES256`이므로 ECDSA + P-256을 이용하여 비대칭키 쌍을 발급한다.\n\n```bash\nopenssl ecparam -genkey -name secp256r1 -noout -out ec.key\nopenssl ec -in ec.key -pubout -out ec.pub\n# priv: ec.key, pub: ec.pub\n```\n\n```elixir\nprivkey = File.read!(\"ec.key\")\n  |\u003e :public_key.pem_decode() |\u003e hd\n  |\u003e :public_key.pem_entry_decode()\n\nencoded_header \u003c\u003e \".\" \u003c\u003e encoded_payload\n  |\u003e :public_key.sign(:sha256, privkey)\n  |\u003e Base.url_encode64(padding: false)\n```\n\n## 참고\n\n- [RFC 7519 - JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)\n- [JSON Web Token Introduction - jwt.io](https://jwt.io/introduction)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/METT-TC":{"title":"METT-TC","content":"\n\n- **M**: mission\n- **E**: enemy\n- **T**: terran and weather\n- **T**: troops\n- **T**: time\n- **C**: civilian\n[[작명 5개항]]도 참고\n\n#군사학","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/PostgreSQL":{"title":"PostgreSQL","content":"\n[PostgreSQL: The world's most advanced open source database](https://www.postgresql.org/)\n\nPostgreSQL 설치와 기본 사용법 정리.\n\n- [[ROLE 관리하기]]\n\n## 설치\n\n세 가지 선택지가 있다:\n\n- 직접 빌드한다\n- 컨테이너로 깐다\n- 패키지 매니저로 깐다\n\n### macOS\n\nbrew로 깔고 brew services로 돌린다. 버전명이 붙은 formula이기 때문에 아래처럼 PATH를 등록해주어야 `psql`이나 `createdb`와 같은 명령어를 쓸 수 있다.\n\n```\nbrew install postgresql@15\necho 'export PATH=\"/opt/homebrew/opt/postgresql@15/bin:$PATH\"' \u003e\u003e ~/.zshrc\nbrew services start postgresql@15\n```\n\n## 참고\n\n- Stephan Schmidt, [Just Use Postgres for Everything](https://www.amazingcto.com/postgres-for-everything/).\n- [PostgreSQL 13.3 문서](https://www.postgresql.kr/docs/13/) – 자습서 최신 번역본","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/ROLE-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0":{"title":"ROLE 관리하기","content":"\n\u003e 수퍼유저는 아니지만 `CREATEDB` 및 `CREATEROLE` 권한이 있는 role을 생성하고, 데이터베이스와 role의 모든 루틴 관리에 대해 이 role을 사용하는 것이 좋다. 이러한 방법으로 실제로 수퍼유저 권한이 불필요한 작업을 수퍼유저로 실행하는 위험이 방지된다.\n\n```sql\nCREATE ROLE name LOGIN CREATEDB CREATEROLE PASSWORLD 'password';\n```\n\n## USER와 ROLE의 차이\n\n- TODO: LOGIN 권한이 없는 ROLE은 왜 있는 걸까?\n- LOGIN 권한이 있는 ROLE이 USER.\n- `CREATE USER name`는 `CREATE ROLE name LOGIN`과 같다.\n\n## 참고\n\n- [PostgreSQL: Documentation: 15: 22.2. Role Attributes](https://www.postgresql.org/docs/current/role-attributes.html)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/UiBox":{"title":"UiBox","content":"\n\n![UiBox 사진](assets/uibox.jpeg)\n\n작고 조용한 SFF 서버 제작\n\n## 구성\n\n- UiBox: 서버\n- UiRouter: 라우터\n\n## 목표\n\n- [ ] 비밀번호 관리 (vaultwarden)\n- [ ] NAS\n  - [x] samba\n  - [ ] Nextcloud\n- [ ] HomeAssistant\n- [ ] 개발 서버\n  - [ ] CI 서버 (Jenkins? GitHub Actions?)\n  - [ ] 원격으로 접속하여 쓸 수 있는 개발환경\n- [ ] 웹 서버\n- [ ] 윈도우 (게임 및 금융용)\n\n### 비밀번호 관리\n\n[bitwarden](https://bitwarden.com/)\n\n오픈소스 비밀번호 관리 도구. 개인 사용자용으로 기본 기능은 무료이고, 유료로 추가 기능을 사용하거나 상업용으로 사용할 수 있다. 서버를 직접 호스팅하여 쓸 수도 있다. 서버에 설치하여 내 비밀번호를 내 서버에 저장해보자.\n\n- [danci-garcia/vaultwarden](https://github.com/dani-garcia/vaultwarden)\n\n### NAS 서버\n\n대학 공부 자료, PDF, 전자책 뿐 아니라 친구, 가족과 찍은 사진도 저장한다.\n\nTrueNAS나 OMV 같은 나스용 OS가 필요한지는... 고민해보자.\n\n- nextcloud\n\n### IoT 관리\n\n[Home Assistant](https://www.home-assistant.io/installation/)\n\nIoT 관리를 위한 경량 서버를 설치하여 집의 스마트 전구를 관리하자.\n\n### 개발 서버\n\ngit, CI를 물려두고 푸쉬 훅을 돌리거나, x86 리눅스가 필요할 때 요긴하게 사용하자.\n\n예로, 키보드를 만들때 QMK 개발환경을 M1 macOS에 구축하는게 번거로운데, 서버에서 작업하고 펌웨어를 내려받으면 된다.\n\n### 웹 서버, 메일 서버\n\n할 필요는 없지만 할 수 있는데 안 할 이유도 없다!\n\n### 윈도우\n\n가끔 금융 등 환경에서 필요한 경우가 있는데, VM으로 해결 가능한지 도전\n\nGPU passthrough하여 간단한 스팀 게임 집에서 돌리기.\n\n## 구성\n\n### 하드웨어\n\n- CPU: Intel Celeron J4105 (4) @ 2.5GHz\n- GPU: Intel GeminiLake [UHD Graphics 600]\n- RAM: 8GB\n- MBD: ODROID-H2\n- Storage:\n\t- OS Storage:  SAMSUNG PM981 M.2 NVMe SSD 256GB\n\t- Data Storage: HDD\n\n### 소프트웨어 레이어\n\n- Proxmox VE\n  - Windoes VM\n  - HomeAssistant VM\n  - NAS VM: Nextcloud, vaultwarden\n  - DevServer CT\n  - WebServer CT\n\n## 참고\n\n- [Proxmox VE Wiki](https://pve.proxmox.com/wiki/Main_Page)\n- [The Perfect Home Server Build! 18TB, 10Gbit LAN, Quiet \u0026 Compact](https://www.youtube.com/watch?v=qACTvCW_yDc)\n- [awesome-selfhosted](https://github.com/awesome-selfhosted/awesome-selfhosted)\n- [홈 서버 만들기 -- Varins](https://varins.com/library/server/)\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/bitstrings":{"title":"bitstrings","content":"\n\n[[elixir]]는 메모리의 비트열을 [bitstring]이라는 단위로 다룬다.\n\n[bitstring]: https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#bitstrings\n\n## 기본 표기\n\n`bitstring` 리터럴은 기본적으로 8비트, 즉 1바이트 단위로 값을 표기한다.\n\n```elixir\niex\u003e \u003c\u003c255\u003e\u003e\n\u003c\u003c255\u003e\u003e\niex\u003e \u003c\u003c256\u003e\u003e\n0\n```\n\n그 외의 단위로 값을 표기하고 싶다면 `::size`를 붙여주면 된다.\n\n```elixir\niex\u003e \u003c\u003c4::8\u003e\u003e\n\u003c\u003c4\u003e\u003e\niex\u003e \u003c\u003c4::4\u003e\u003e\n\u003c\u003c4::size(4)\u003e\u003e\niex\u003e \u003c\u003c15::4\u003e\u003e\n\u003c\u003c15::size(4)\u003e\u003e\niex\u003e \u003c\u003c16::4\u003e\u003e\n\u003c\u003c0::size(0)\u003e\u003e\n```\n\n패턴매칭도 된다.\n\n```elixir\niex\u003e \u003c\u003ca::1, b::1, c::1, d::1\u003e\u003e = \u003c\u003c4::4\u003e\u003e\n\u003c\u003c4::size(4)\u003e\u003e\niex\u003e [a, b, c, d]\n[0, 1, 0, 0]\n```\n\n```elixir\niex\u003e \u003c\u003cn::32\u003e\u003e = \u003c\u003c0, 255, 255, 255\u003e\u003e\n\u003c\u003c0, 255, 255, 255\u003e\u003e\niex\u003e n\n16777215\n```\n\n```elixir\niex\u003e \u003c\u003c255, 255, 255\u003e\u003e = \u003c\u003c0xFF, 0xFF, 0xFF\u003e\u003e\n\u003c\u003c255, 255, 255\u003e\u003e\niex\u003e Base.encode16(\u003c\u003c255, 255, 255\u003e\u003e)\n\"FFFFFF\"\n```\n\n## 타입\n\n- `\u003c\u003c\u003e\u003e`\n- `binary()` = `\u003c\u003c_::_*8\u003e\u003e`\n- `bitstring()` = `\u003c\u003c_::_*1\u003e\u003e`\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/dbdiagram":{"title":"dbdiagram","content":"\n[dbdiagram.io](https://dbdiagram.io/home) 테이블 관계를 도식화 할 수 있는 도구.\n\n## 테이블 선언\n\n```dbdiagram\nTable tablename {\n  field1 type [attributes]\n}\n```\n\n### 속성\n\n- `pk` – primary key\n- `unique`\n- `not null`\n- `default: 'now()'\n- `note: 'description'` 말 그대로 노트\n\n## 인덱스 선언\n\n```\nIndexes {\n  (field1, field2) [attribute]\n}\n```\n\n## 관계 설정하기\n\n```\n// 1:다 관계\nRef: table1.field \u003e table2.field\n\n// 다:다 관계\nRef: table1.field \u003c\u003e table2.field\n\nTable table1 {\n  table2_id table2 [ref: \u003c table2.id]\n}\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/dialyxir":{"title":"dialyxir","content":"\n\nmix 프로젝트에서 `mix.exs`를 열고 `deps/0`에 다음을 추가한다.\n\n```elixir\ndefp deps do\n  [\n  # highlight-next-line\n    {:dialyxir, \"~\u003e 1.0\", only: :dev, runtime: false}\n  ]\nend\n```\n\n이후 `mix dialyzer`로 타입 검사를 할 수 있다.\n\n```bash\n$ mix do deps.get, deps.compile\n$ mix dialyzer\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/frontmatter-git-hook":{"title":"frontmatter git hook","content":"\nfrontmatter를 자동으로 추가해주는 git hook을 작성하였다.\n\n현재 이 저장소는 [옵시디언](https://obsidian.md)으로 작성하고 [quartz](https://quartz.jzhao.xyz/)로\n퍼블리싱하고 있다.\n\n이 둘 때문에 각 문서(`.md` 파일)이 아래의 형태를 취하고 있다:\n\n1. 파일의 이름을 문서의 제목으로 삼고 있다. (옵시디언 때문에)\n2. frontmatter가 있어야 하고 그 안에 `title`이 있어야 한다. (quartz 때문에)\n\n제목이 두 곳에 동시에 들어가야 하는 상황이다. 이름이 없는 파일이 없으니 1번을\n까먹는 일은 없는데, 2번을 하는 게 여간 귀찮은 것이 아니다. `---`으로 블록을 만들고 파일 이름으로 적었던 것을\n굳이 또 적어야 한다.\n\n귀찮아서 방치하고 있다가 옛날에 git hook에 대해 들은 것이 불현듯 기억나 허겁지겁 짜보았다.\n\n## 고칠 대상 찾기\n\n고쳐야 하는 대상은 크게 세 가지이다.\n\n1. frontmatter 자체가 없거나.\n2. frontmatter는 있는데 안에 title이 없거나.\n3. 잘못 눌러서 만들어진 빈 문서이거나.\n\n셋 모두 `grep`으로 쉽게 확인할 수 있다.\n\n1번의 경우, `^---$` 정규식으로 검사하여서 통과하지 못하면 frontmatter가 없는 문서이다.\n\n2번은 `^---$` 정규식을 통과하였는데, `^title:` 정규식을 통과하지 못한 경우에 해당한다.\n\n3번은 비어있거나 공백만 있는 문서이므로 `[^[:space:]]`를 만족할 것이다.\n\n## sed로 고치기\n\nfrontmatter 자체가 없는 경우엔 파일의 최상단에 frontmatter를 추가하면 된다. `sed` 명령어로\n인라인으로 편집할 수 있다.\n\n```bash\n  sed -i '' \"1i\\\\\n---\\\\\ntitle: ${filename%.md}\\\\\ntags: []\\\\\n---\\\\\n\\\\\n\" \"$filename\"\n```\n\n- `-i ''` -- 옵션으로 임시 파일을 만들지 않고 파일을 제자리바꿈(*in-place replace*) 할 수 있다.\n- `1i` -- i는 삽입 명령어이다. 다음에 오는 내용을 파일의 첫줄에 삽입할 수 있다.\n- `\\\\\\` -- 줄바꿈을 넣기 위한 이스케이핑. 특이하게 `1i` 다음 바로 줄바꿈이 필요하다. 이 부분이 GNU와 POSIX의 sed가\n  동작이 다르다.\n- `${filename%.md}` -- 변수 `$filename`의 내용을 가져오되, 끝의 `.md`는 뺀다.\n\nfrontmatter는 있지만 title만 없는 경우에는 frontmatter 블록(`---`) 중 젤 위의 블록을\n`title`이 있는 것으로 대체하면 된다.\n\n```bash\n  sed -i '' \"1s/^---$/---\\\\\ntitle: ${filename%.md}/\" \"$filename\"\n```\n\n## git hook으로 만들기\n\n위의 내용을 `bin/add-frontmatter.sh`로 스크립트 파일로 만들었다. hook으로도 쓰고\n그냥도 쓰고 싶어서 별도의 스크립트로 만들었다. 둘의 동작이 미묘하게 달라야 하는데:\n\n1. 그냥 실행할 경우에는 `notes`를 검사하여 frontmatter를 고친다.\n2. 훅으로 돌릴 경우에는 커밋 전 커밋 대상의 frontmatter들을 고쳐준다.\n\nbash에서 `while read` 문을 쓰면 표준입력으로 들어온 내용을 줄마다 반복문으로 돌릴 수 있다.\n이를 이용하면 스크립트는 바꾸지 않고 파이프로 던질 내용만 바꾸어서 쓸 수 있다:\n\n```bash\n# 그냥 돌릴 때에는 아래처럼\nfind notes -name '*.md' | ./bin/add-frontmatter.sh\n\n# 훅으로 돌릴 때에는 아래처럼 스테이징 된 `*.md`만 가져온다.\ngit diff --exit-code --name-only --cached -- \"*.md\" | ./bin/add-frontmatter.sh\n```\n\ngit hook은 git 프로젝트 폴더의 `.git/hooks` 디렉토리에 넣으면 된다. 여러 훅이 있는데\n`.sample` 확장자로 샘플이 미리 준비되어 있다. 이중 `pre-commit`이 제일 적절하다고 판단하여\n`pre-commit` 스크립트를 짰다.\n\n```bash\napplypatch-msg.sample*\ncommit-msg.sample*\nfsmonitor-watchman.sample*\npost-update.sample*\npre-applypatch.sample*\npre-commit.sample*\npre-merge-commit.sample*\npre-push.sample*\npre-rebase.sample*\npre-receive.sample*\nprepare-commit-msg.sample*\npush-to-checkout.sample*\nupdate.sample*\n```\n\n말 그대로 커밋 전에 실행되므로 스테이징 된 파일을 대상으로 수정이 이루어질 경우\n수정에 대한 `git add` 혹은 `git rm`을 해주어야 한다.\n\n스크립트에서 표준 출력으로 처리한 파일을 뺸 후 다시 처리해도 되지만 그렇게까지 하긴 싫어서...\n간편하게 `--pre-commit` 옵션을 넘기면 `git add`도 하도록 처리했다.\n\n최종적인 `.git/hooks/pre-commit` 파일은 아래와 같다:\n\n```bash\n#!/bin/bash\n\ngit diff --exit-code --name-only --cached -- \"*.md\" | ./bin/add-frontmatter.sh --pre-commit\n```\n\n## 끝\n\n별 작업 아니었지만 `sed`와 이스케이핑 등이 macOS(POSIX)와 리눅스가 달라 고생했고, bash 스크립트를 별로 쓴 경험이 없어서\n괜히 시간이 걸렸다.\n\n이미 있는 도구를 조합하여 간단히 자동화 할 수 있는 건 분명 강력하지만 적절한 테스트 방법을 찾지 못해서 나중에 애먹을 듯\n싶다.\n\n## 참고\n\n- [hanassig/bin/add-frontmatter.sh](https://github.com/nyeong/hanassig/blob/7b9744cbee24cd3341c6665a07bdf9358afaa41f/bin/add-frontmatter.sh)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/git":{"title":"git","content":"\n## 치트시트\n\n### 파일 복구하기\n\n파일을 삭제하고 커밋 후 복구하기\n\n```bash\n# 먼저 파일이 살아있는 커밋을 찾는다.\ngit log -- filename\ngit log -p -- filename\ngit show -- filename\n\n# 커밋에서 파일을 가져온다\ngit checkout commit -- filename\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/helix":{"title":"helix","content":"\n\u003e A post-modern text editor.\n\nhttps://helix-editor.com/\n\n## 특장점\n\n터미널에서 돌아가는 선택 기반 모달 에디터이다.\n\n- 모달 에디터라 vim이나 emacs처럼 모드를 바꿔가며 쓴다.\n\t- 마우스나 방향키가 필요 없어 손이 키보드를 떠날 필요가 적다.\n\t- 다양한 명령어를 간편한 단축키로 쓸 수 있다.\n- 선택 기반 모달 에디터이다.\n\t- vim은 명령 → 선택 순서로 명령어를 입력하여, 명령이 영향을 끼치는 범위가 눈에 보이지 않는다.\n\t- helix는 선택 → 명령 순서로 입력하여 선택된 영역이 눈으로 보여 익히기 쉽다.\n- 터미널에서 TUI로 돌아간다.\n\t- SSH에서도 쓸 수 있다.\n\t- 메모리도 적게 먹는다.\n- 여러 기능이 내장되어 있다.\n\t- 다중선택, LSP, tree-sitter, fuzzy finder 등등\n\n\n아직 플러그인을 지원하지 않는 것이 큰 단점이다.\n\n## 관련\n\n- [[helix에서 하이라이팅 안 될 때]]\n- [[helix에서 마크다운 편집하기]]\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/helix%EC%97%90%EC%84%9C-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8C%85-%EC%95%88-%EB%90%A0-%EB%95%8C":{"title":"helix에서 하이라이팅 안 될 때","content":"\nhelix 에디터는 tree-sitter를 이용해서 하이라이팅을 한다. `language.toml` 파일에 `[[grammar]]` 부문에 아래와 같이 정의가 되어 있다:\n\n```toml\n[[grammar]]\nname = \"rust\"\nsource = { git = \"https://github.com/tree-sitter/tree-sitter-rust\", rev = \"0431a2c60828731f27491ee9fdefe25e250ce9c9\" }\n```\n\n`git`은 저장소 주소, `rev`는 커밋 이름이다. 혹시 하이라이팅이 깨졌을 경우 저장소 주소와 커밋 이름을 다시 확인하고 아래 명령어로 트리시터를 업데이트한다:\n\n```bash\nhx --grammar fetch\nhx --grammar build\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/macOS":{"title":"macOS","content":"\n\n- [[맥 새로 설치하기]]\n- [[맥 자잘한 설정하기]]\n\n## 꿀팁\n\n- [[세 손가락으로 드래그하기]]\n- [[shift-space로 한영전환하기]]\n- [[₩ 대신 백틱 입력하기]]\n- [[파인더 타이틀바 아이콘 딜레이 조절]]\n- [[키 입력 커스텀하기]]","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/miryoku":{"title":"miryoku","content":"\n\n36개의 키만으로 구현 가능한 키배열. home-row mod와 엄지키를 이용한 레이아웃\n활용이 특징이다.\n\n[manna-harbour/miryoku](https://github.com/manna-harbour/miryoku)\n\n[[Corne Keyboard]]에 miryoku flip inverted T 배열을 변형하여 쿼티 기반으로\n[사용중](https://github.com/nyeong/zmk-config/commit/50526193a33168c58b006f9b6b8ef15e95ee08b3) (2022-03-31)\n\n\n## 레이아웃\n\n### home-row mods\n\n컨트롤, 알트, GUI 등 모드 키를 손이 기본 위치하는 2열(A, S, D, F, J, K, L, ;)에 두자는 생각이다.\n\n짧게 누를 경우 원래 키(A, S 등...)가 입력되고, 길게 누를 경우 설정한 모드키가 동작한다.\n\n길게 누르는 시간을 0.15초 정도로 설정해주면 굳이 의식하지 않아도 누르고 조합할 키를 누르면 모드키로 동작한다.\n\n```\n그냥 누르면:\n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  | \n\n길게 누르면:\n|  _  | CTL | OPT | CMD | SHF |  _  |        |  _  | SHF | CMD | OPT | CTL |  _  | \n```\n\n예를 들어 복사를 위해 `\u003ccmd\u003e-c`를 누르려면 그냥 `k`를 꾹 누른 채로 `c`를 누르면 된다.\n`kc`를 입력하려면 평범하게 `k`를 누르고 `c`를 누르면 된다.\n\nhome-row mods로 할당한 키는 원래키를 길게 눌러도 연속입력이 안 되는게 단점이다.\n\n## 레이아웃\n\nhome-row mods와 마찬가지로, 아래의 키는 짧게 누르면 원래의 키로 입력되고, 길게 누르면 모드가 바뀐다.\n\n- `ESC` -\u003e function 레이아웃\n- `SPC` -\u003e 숫자 레이아웃\n- `TAB` -\u003e 기호 레이아웃\n- `ENT` -\u003e 마우스 레이아웃\n- `BSP` -\u003e 방향키 레이아웃\n- `DEL` -\u003e 시스템 레이아웃\n\n```\n그냥 누르면:\n| ESC  | SPC  | TAB  |        |  ENT   |  BSP   |  DEL   |\n길게 누르면:\n| 펑션 | 숫자 | 기호 |        | 마우스 | 방향키 | 시스템 |\n```\n\n\n### 일반 레이아웃\n\nhome row mods가 적용되어 있어서 A, S, D, F, J, K, L, ;은 위에 기술된 대로 MODS키로 동작한다.\n\n```\n|  _  |  Q  |  W  |  E  |  R  |  T  |        |  Y  |  U  |  I  |  O  |  P  |  _  | \n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  | \n|  _  |  Z  |  X  |  C  |  V  |  B  |        |  N  |  M  |  ,  |  .  |  /  |  _  | \n                  | ESC | SPC | TAB |        | ENT | BSP | DEL |            \n```\n\n### 펑션 레이아웃\n\n```\n|  _  |     |     |     |     |     |        |     | F7  | F8  | F9  | F12 |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  =  | F4  | F5  | F6  | F11 |  _  | \n|  _  |     |     |     |     |     |        |  +  | F1  | F2  | F3  | F10 |  _  | \n                  | *** | SPC | TAB |        | ENT | BSP | DEL |            \n```\n\n### 숫자 레이아웃\n\n우측 키보드를 키패드처럼 쓸 수 있다. 따옴표(\", ', `)는 모두 오른쪽 새끼손가락으로 입력할 수 있다.\n\n```\n|  _  |     |     |     |     |     |        |     |  7  |  8  |  9  |  \"  |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  =  |  4  |  5  |  6  |  '  |  _  | \n|  _  |     |     |     |     |     |        |  +  |  1  |  2  |  3  |  `  |  _  | \n                  |     | *** |     |        |  -  |  0  |  .  |            \n```\n\n### 기호 레이아웃\n\n```\n|  _  |     |     |     |     |     |        |  (  |  \u0026  |  *  |  ~  |  )  |  _  | \n|  _  | CTL | OPT | CMD | SHF |     |        |  {  |  $  |  %  |  ^  |  }  |  _  | \n|  _  |     |     |     |     |     |        |  [  |  !  |  @  |  #  |  ]  |  _  | \n                  |     |     | *** |        |  _  |  |  |  \\  |            \n```\n\n### 마우스 레이아웃\n\nZMK 펌웨어에서는 아직 마우스 키를 지원하지 않기 때문에 이 부분은 비워두었다.\n\n### 네비게이션 레이아웃\n\n방향키, HOME, END, PG UP, PG DN 등 네비게이션과 관련된 버튼을 모아둔 레이아웃\n\n```\n|  _  |     |HOME |  ↑  | END |PG UP|        |     |     |     |     |     |  _  | \n|  _  |     |  ←  |  ↓  |  →  |PG DN|        |     | SHF | CMD | OPT | CTL |  _  | \n|  _  |     |     |     |     |     |        |     |     |     |     |     |  _  | \n                  | ESC | SPC | TAB |        |     | *** |     |            \n```\n\n### 시스템 레이아웃\n\n블루투스, 화면 밝기, 미디어 재생, 볼륨 조절 등 버튼을 모아놓은 레이아웃\n\n```\n|  _  |BR UP|REWND|PAUSE|FA FO|VL UP|        |     |     |     |     |     |  _  | \n|  _  |BR DN|PREV |PLAY |NEXT |VL DN|        |     | SHF | CMD | OPT | CTL |  _  | \n|  _  |BR AT|BTCLR|BTOFF|BT ON|MUTE |        |     |     |     |     |     |  _  | \n                  | BT0 | BT1 | BT2 |        |     |     | *** |            \n```\n\n## 개선 여지\n\n- home row mod로 할당된 키들은 꾹 눌러서 입력이 불가능하다\n  - 양손 검지로 누르는 안쪽열 키(`g`, `k`)를 누르고 있으면 home row mod가 풀리도록?\n- 한 손으로 할 수 있는 것들이 적다.\n- 매크로 등 편의기능\n  - 여는 괄호(`(`, `{`, `[`) 입력시 닫는 괄호와 왼쪽 방향키를 입력하여 바로 괄호 속에서 입력 가능하도록\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/otp":{"title":"otp","content":"\n\nOTP; Open Telecom Platform. 옛날에는 전화 교환기, 스위치를 만드는 데에 쓰여서 이름이 저렇다.\n얼랭, 엘릭서 생태계에서 거대한 시스템을 관리하기 위한 범용 도구이다.\n\n엘릭서 프로그램을 개발할 때 [[프로세스 (엘릭서)]]를 직접 쓰기보다는 OTP에서 제공하는 도구를 쓰는 편이 낫다.\n\n- Task: 작업을 백그라운드에서 하고 싶을 때 쓴다.\n- Agent: 상태를 관리하고 싶을 때 쓴다.\n- GenServer: 범용적인 상황에서 쓸 수 있는 만능 구현.\n\n### Task\n\n무언가를 백그라운드에서 돌리고 싶을 때 쓴다.\n\n```elixir\niex\u003e worker = Task.async(fn -\u003e 오래_걸리는_작업() end)\niex\u003e # do something else\niex\u003e result = Task.await(worker)\n```\n\n익명 함수를 취하는 `Task.async/1`과 이름 있는 함수를 취하는 `Task.async/3`이 있다.\n\n### Agent\n\n상태를 관리하는 백그라운드 프로세스이다.\n\n```elixir\niex\u003e {:ok, count} = Agent.start(fn -\u003e 2 end)\niex\u003e Agent.get(count, \u0026Function.identity/1)\n2\niex\u003e Agent.update(count, \u0026(\u00261 * \u00261))\n:ok\niex\u003e Agent.get(count, \u0026Function.identity/1)\n4\n```\n\n### GenServer\n\n여러 상황에 쓰일 수 있는 범용 서버이다.\n`init/1`, `handle_call/3`, `handle_cast/2` 등의 콜백을 구현하여 사용한다.\n\n#### init\n\nGenServer를 초기화한다.\n\n```elixir\ndef init(start_args) do\n  {:ok, state}\nend\n```\n\n```elixir\niex\u003e {:ok, server} = GenServer.start_link(MyServer, args)\n```\n\n#### handle_call/3\n\n`GenServer.call/3`을 통해 호출된 동기 메시지를 다룬다.\n\n```elixir\ndef handle_call(request, _from, state) do\n  {:reply, return, new_state}\nend\n```\n\n인자는 `request, from, state` 꼴이다. `request`는 `call/3`에 의해 호출된 메시지를, `from`은 누가 호출했는지를,\n`state`는 서버의 현재 상태를 나타낸다.\n\n반환은 `{:reply, return, new_state}` 꼴이다. 반환값이 필요 없다면 `{:noreply, new_state}` 꼴로 반환하면 된다.\n\n보통은 `request`를 튜플로 하여 인자를 함께 넘긴다.\n\n```elixir\niex\u003e GenServer.call(MyServer, {:call_name, call_args})\n```\n\n#### handle_cast/2\n\n`cast/2`를 통해 호출된 비동기 메시지를 다룬다.\n\n인자는 `request, state` 꼴이다. `request`는 `cast/2`에 의해 호출된 메시지를,`state`는 서버의 현재 상태를 나타낸다.\n\n```elixir\ndef handle_cast(request, state) do\n  {:noreply, new_state}\nend\n```\n\n아래와 같이 쓸 수 있다.\n\n```elixir\niex\u003e GenServer.cast(MyServer, {:call_name, call_args})\n```\n\n반환값이 필요 없다면 `{:noreply, new_state}` 꼴로 반환하면 된다.\n\n#### 구현 감싸기\n\n```elixir\ndef start_link(start_args) do\n  GenServer.start_link(__MODULE__, current_number, name: __MODULE__)\nend\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/rust":{"title":"rust","content":"\n\n- [[스마트 포인터]]\n\n## 참고\n- [Rust Language Cheat Sheet](https://cheats.rs/)\n- [Getting Started - Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/sed":{"title":"sed","content":"\nCLI에서 파일을 편집하는 도구.\n\n기본적으로는 표준입출력으로 반환된다.\n\n##  캡처 그룹\n\n`\\( \\)` 구문을 이용하여 캡처 그룹을 만들고, `\\1` 구문으로 가져온다.\n\n```bash\necho capture this | sed 's/\\(capture\\) this/\\1 that/'\n```\n\n## 예시\n\n마크다운 파일의 헤더를 한 단계씩 더 들여쓰기\n\n```bash\nrg '^#' -l | tr '\\n' '\\0' | xargs -0 sed -i '' -E 's/^#/##/g'\n```\n\n마크다운 파일에 파일 제목으로 `h1` 헤더 추가하기\n\n```sh\nfd -e \"md\" --exec sed -i '' '1s/^/# {/.}\\n\\n/' \"{}\"\n```\n\n마크다운 파일에 frontmatter 추가하기\n\n```sh\nfd -e 'md' --exec zsh -c 'sed -i \"\" \"1s/^/---\\ntitle: \\\"{/.}\\\"\\n---\\n/\" \"{}\" | head -n 5'\n```\n\n### wikilink 스타일을 마크다운 링크로 바꾸기\n\n문제 정의\n\n- 마크다운 파일 내의 `[[fine name]]`을 `[file name](file path)`로 바꾸기.\n- 다행히 파일 이름이 곧 문서 이름이다.\n- 더 정확히는 이런 종류들이 있음\n\t- `![[image name]]` 구문의 이미지 이름\n\t- 글 내용 중 설명을 위하여 백틱( \\` )으로 둘러 싼 링크 구문도 있다.\n\t- 글 내의 헤더에 링크를 걸기 위하여 `[[#header name]]`\n\t- 링크와 보여지는 이름을 다르게 하기 위하여 `[[file name|shown name]]`\n\t- 위의 두 경우가 함께 있는 링크 `[[file name#header name|shown name]]`\n- \n\n## 참고\n\n- [Introduction | Introduction](https://mug896.github.io/sed-stream-editor/)\n- 이종립, [새로 입사한 개발자가 프로젝트에 기여하는 방법 한 가지](https://helloworld.kurly.com/blog/fix-style-with-command/), 2020\n- [Fetching Title#uf3k](https://catonmat.net/proof-that-sed-is-turing-complete)","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/shift-space%EB%A1%9C-%ED%95%9C%EC%98%81%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0":{"title":"shift-space로 한영전환하기","content":"\n\n언제부턴가 한/영 전환에 shift-space가 설정 안 되게 바뀌었다. 아래의 방법으로 강제로 가능하다.\n\n1.  시스템 설의 키보드 \u003e 단축키 \u003e 이전 입력 소스를 더클클릭하고 아무 키나 입력한다. 수정하지 않으면 plist 에 수정할 값이 보이지 않기 때문이다.\n2. [PlistEdit](https://www.fatcatsoftware.com/plisteditpro/PlistEditPro.zip) 를 다운로드해서 설치 한다. Xcode 가 설치되어 있으면 Xcode 로 열 수 있다.\n    \n3.  파인더에서 사용자 폴더 아래의 라이브러리 폴더를 연다. 라이브러리 폴더는 숨김 처리되어 있다. 파인더 메뉴바의 ‘이동 메뉴’를 Option 키를 누른 상태에서 클릭하면 ‘라이브러리’ 폴더가 표시된다.\n    \n4.  라이브러리 풀더 아래 Preferences 안에서 다음 plist 파일을 PlistEdit Pro 로 연다./Users/\u003c사용자\u003e/Library/Preferences/com.apple.symbolichotkeys.plist\n    \n5.  Property List 에서 60을 찾는다. 맨 아래에 있을 것이다.\n    \n6.  `60/value/parameters/2`를 `131072`로 바꿔준다. ![](assets/image.png)\n7. 이후 재부팅하면 적용된다.","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/uirouter":{"title":"UiRouter","content":"\nipTIME AX2004M + OpenWrt\n\nOpenWrt를 활용하여 집 공유기를 보다 다목적으로 사용해보자.\n\n## OpenWrt\n\n[OpenWrt](https://openwrt.org/)는 임베디드 기기를 위한 리눅스이다. 주로 라우터에 사용된다.\n온전한 리눅스 배포판이므로 일반 공유기에 OpenWrt를 설치하여 라즈베리 파이처럼 임베디드 컴퓨터로서 다룰 수 있다.\n\n## 활용\n\n1. VPN 서버 - [[install-wireguard]]\n2. 웹 프록시 서버\n3. 홈 네트워크용 DNS 서버\n\n그 외 아래의 용도로도 활용할 수 있다고 하나 내 목표가 아닌 것들:\n\n1. 외장 드라이브를 연결하여 NAS처럼 활용하기\n2. 토렌트 클라이언트를 설치하여 다운로드 서버로 활용하기\n3. 네트워크 프린터 만들기\n4. QoS\n\n## 참고\n\n- [OpenWrt](https://openwrt.org/)\n- [ipTIME AX2004M용 OpenWrt](https://kasugano.tistory.com/m/157)\n","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null},"/notes/zsh":{"title":"zsh","content":"\n\n\n## 이상한 괄호쌍\n\n쉘을 쓰다 보면 너무나도 다양한 괄호쌍이 나온다... 헷갈려서 정리했다.\n\n대괄호, 중괄호, 소괄호를 영어로는 각각 brackets, curly braces, parenthese라고\n한다.\n\n- 단일 대괄호(`[ ]`): 조건 표현문. POSIX 표준[^1]\n- 이중 대괄호(`[[ ]]`): `[`의 개선판.\n- 중괄호(`{ }`): 중괄호 확장문(*brace expansion*)[^3]\n- 단일 소괄호(`( )`): 배열 표현.\n- 이중 소괄호(`(( ))`): 산술 표현문.[^2]\n- 산술 확장문(`$[ ]`): 더 이상 쓰지 않는다.\n- 변수 확장문(`${ }`)\n- 명령어 대치문(`$( )`): 명령어를 실행하고 그 결과로 값을 대치한다.\n- 산술 확장문(`$(( ))`)\n\n[^1]: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html\n[^2]: https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html\n[^3]: https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html\n\n### 대괄호\n\n`[ ]`(단일 대괄호, *single bracket*), `[[ ]]`(이중 대괄호, *double bracket*)\n모두 조건 검사에 쓴다.\n\n`[ ]`는 조건 검사 명령어이다. 보통 `/bin/[`에 위치하며 `/bin/test`와 동치이다.\nPOSIX 호환 문법이다.[^4]\n\n[^4]: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html\n\n`[[ ]]`는 확장 문법이다. korn, bash, zsh 등의 쉘에서 폭넓게 사용한다. 해당 쉘을\n쓴다면 `[[ ]]`만 알아도 충분하다.\n\n자세한 사용법은 [Bash Conditional Expressions] 참고.\n\n[Bash Conditional Expressions]: https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html\n\n`$[ ]`(산술 대치문, *arithmetic expansion*)은 `$(( ))`로 대치되어 현재는 쓰지\n않는다.[^5]\n\n[^5]:https://wiki.bash-hackers.org/scripting/obsolete\n\n### 중괄호\n\n`{ }`(중괄호, *braces, curly braces*)는 문자열의 리스트를 만들 때 쓴다.\n\n아래의 두 명령어는 똑같다. `{ }`를 이용하여 간편하게 줄여 쓸 수 있다.\n\n```bash\n$ mv -i lib/user/{accont,account}.ex\n$ mv -i lib/user/accont.ex lib/user/account.ex\n```\n\n아래와 같이 범위를 지정할 수도 있다. 이는 문자열도 가능하다.\n\n```bash\n$ mkdir test_dir_{00..99..2}\n$ touch {가..힣} # 왜 이런 짓을...?\n```\n\n`${ }`(변수 확장문, *parameter expansion*)을 쓰면 변수를 결과값으로\n대치(*substitute*)할 뿐 아니라, 여러가지 옵션으로 확장할 수 있다.\n\n변수와 뒤에 오는 문자열을 구분해야 할 경우 `$var` 대신 쓸 수 있다.\n\n```bash\n$ DIR_PREFIX=hello\n$ echo $DIR_PREFIX_world\n## \n$ echo ${DIR_PREFIX}_world\n## hello_world\n```\n\n옵션으로 확장하면 다양한 기능을 함께 쓸 수 있다. `${var=str}` 문법은 `var`\n변수가 정의되어 있으면 그걸 쓰고, 정의되어 있지 않다면 `var`에 `str`을 대입하고\n`str` 값을 결과로 쓴다. 아래의 코드는 `$EDITOR` 변수가 정의되어 있으면 해당\n편집기로 `config` 파일을 열고, 아니라면 `vim`으로 여는 명령어이다.\n\n```bash\n$ ${EDITOR=vim} config\n```\n\n그 외의 옵션은 [Shell parameter Expansion] 참고.\n\n[Shell parameter Expansion]: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\n\n### 소괄호\n\n`( )`(단일 소괄호, *single parentheses*)는 배열을 만들 때 쓴다.\n\n```bash\n$ array=(1 2 3)\n$ $array\n## 1 2 3\n```\n\n`(( ))`(이중 소괄호, *double parentheses*)는 산술 연산에 쓴다.\n\n```bash\n$ i=10\n$ i+=10\n## i = 1010\n\n$ i=10\n$ ((i += 10))\n## i = 20\n```\n\n`$(( ))`(산술 확장문, *arithmetic expansion*)은 산술 계산 후 결과값으로\n대치된다.\n\n```bash\n$ echo ((i += 10))\n## zsh: no maches found: ((i += 10))\n$ echo $((i += 10))\n## 30\n```\n\n## 팁\n\n### 특정 명령어가 있는지 확인하기\n\n`(( $+commands[foobar] ))` 쓰면 된다.\n\n[Speed Test: Check the Existence of a Command in Bash and Zsh][check-speed-test]\n\n[check-speed-test]: https://www.topbug.net/blog/2016/10/11/speed-test-check-the-existence-of-a-command-in-bash-and-zsh/\n\n- `type foobar \u0026\u003e /dev/null`\n- `hash foobar \u0026\u003e /dev/null`\n- `command -v foobar \u0026\u003e /dev/null`\n- `which foobar \u0026\u003e /dev/null`\n- `(( $+commands[foobar] ))`\n\n아래와 같이 쓸 수 있다.\n\n```bash\nexport EDITOR=vi\n\nif (( $+commands[vim] )); then\n  export EDITOR=vim\nfi\n\nif (( $+commands[helix] )); then\n  export EDITOR=helix\n  alias hx='helix'\nfi\n```","lastmodified":"2023-02-05T06:08:11.423465274Z","tags":null}}