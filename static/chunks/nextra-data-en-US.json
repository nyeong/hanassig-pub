{"/":{"title":"index","data":{"":"안녕하세요. 인터넷에서 안녕이라는 이름을 쓰고 있습니다.\n컴퓨터와 프로그래밍을 공부하고 있습니다.\n이 사이트는 제가 배운 것들을 정리하여 스스로 더 잘 이해하고자 만들었습니다.배움이 부족하기에 내용에 옳지 않거나 오래된 것들이 있을 수 있습니다.\n고쳐야 할 점이 있다면 저장소 이슈\n혹은 연합우주 (@annyeong@stella.place)를 통해 연락주시면 반영하겠습니다.","주제별#주제별":"프로그래밍\n웹 백엔드\n개발환경\n디자인 패턴\n한글 인코딩\n\n\n생활, 도구 등\nMy New Gears\n최적화\n\n\n취미\n🎼 음악\n하나씩\nuibox — 홈 서버 구성하기\n\n\n기초 CS\n프로그래밍 언어\n자료구조\n데이터베이스\n운영체제\n🤖 기계학습\n네트워크\n\n\n수학\n카테고리 이론\n수학적 귀납법"}},"/notes/GTD":{"title":"GTD","data":{"":"데이비드 앨런의 《쏟아지는 일 완벽하게 해내는 법》에서 소개하는 할 일 관리 방법론. 원제가 Getting Things Done이라서 GTD로 줄여서들 부른다.\n\n\n수집\n명료화\n정리\n검토\n실행"}},"/notes/algorithm":{"title":"알고리즘","data":{"":"정렬 알고리즘\n퀵 정렬(quick-sort)\n병합 정렬\n힙 정렬\n\n\n검색 알고리즘\n이진 검색\n\n\n그래프 탐색 알고리즘\nDFS\nBFS\nPrim\n다익스트라","참고#참고":"Buck Shlegeris, 알고리즘 학습에 대한 조언, 김용균 역.\n자료구조"}},"/notes/category-theory":{"title":"카테고리 이론","data":{"":"합성과 프로그래밍\n타입은 집합이다\n모나드와 펑터와 어플리케이티브\n순서","참고#참고":"Bartosz Milewski, Category Theory for Programmers.\nhmemcpy/milewski-ctfp-pdf\nEugenia Cheng, Category Theory in Life."}},"/notes/composition-and-programming":{"title":"합성과 프로그래밍","data":{"":"","카테고리#카테고리":"+----------+  f  +----------+  g  +----------+\n| object a |---->| object b |---->| object c |\n+----------+     +----------+     +----------+\n|               g∘f               ^\n+---------------------------------+\n카테고리는 대상(object)와 사상(morphism)의 모음이다.\n위 그림에서 네모는 대상, 화살표는 사상이다.\n위의 사상 는 아래와 같이 표기한다. 대상 에서 대상 로 가는 사상이라는\n뜻이다.위의 그림에서 사상 와 를 순서대로 따라가면 대상 에서 대상 로 도달할\n수 있다. 이를 합성(composition)이라고 하며 라고 쓴다.\n합성은 결합법칙(associativitiy)이 성립한다. 무엇을 먼저 합성하든 결과가 같아야한다.\n에 대하여 아래가\n만족한다:\n모든 대상에 대해 항등 사상(identity morphism)이 존재한다. 항등 사상은\n와 같은 꼴이며 따라서 모든 사상 에 대해 아래가 성립한다:\n\n위의 조건을 만족하기만 하면 무엇이든 대상과 사상, 즉 카테고리로 볼 수 있다.","카테고리로서의-프로그래밍-언어#카테고리로서의 프로그래밍 언어":"프로그래밍 언어에서는 타입을 대상으로, 함수를 사상으로 볼 수 있다.\n아래의 하스켈, 엘릭서 코드의 함수 f를 위의 사상 로 볼 수 있다.\nf :: a -> b\n\n@spec f(a) :: b\n프로그래밍 언어를 카테고리로 보려면 합성이 가능해야하고, 합성에 대해 결합법칙과\n항등사상이 존재해야한다.먼저 합성이다. 이미 존재하는 , 를 합성하여 새로운 함수를 만들고 이름을\n붙일 수 있다.\nfn f(obj: A) -> B;\nfn g(obj: B) -> C;\nfn g_after_f(obj: A) -> C {\ng(f(obj))\n}\n하스켈 같은 일부 언어는 언어 자체에서 함수의 합성을 지원한다. 아래의 두 줄은\n동일하다:\ng . f object\ng(f(object))\n실제로 동작할 때에는 가장 오른쪽의 f부터 연산을 시작하기 때문에 시각적으로\n헷갈릴 수 있다. 이에 엘릭서 같은 일부 언어는 아래와 같은 함수의 합성을 지원한다.\n보통은 pipe operator 라는 이름으로 지원한다.\nf(object) |> g()\n프로그램의 합성을 상상해도 좋다. git 디렉토리에서 커밋 목록을 출력하는 프로그램\ngit log와 문자열에서 줄 수를 세는 프로그램 wc -l을 합성하여 커밋의 수를\n출력하는 프로그램으로 바꿀 수 있다:\ngit log --oneline | wc -l\n프로그램의 함수의 합성도 결합법칙을 만족한다. 합성을 할 때에 무얼 먼저 합성하든\n결과는 동일하다:\nf :: a -> b\ng :: b -> c\nh :: c -> d\n-- f, g, h에 대하여 아래의 두 합성은 동일하다.\nh . (g . f)\n(h . g) . f\n\n@spec f(a) :: b\n@spec g(b) :: c\n@spec h(c) :: d\n\n## f, g, h에 대하여 아래의 두 합성은 동일하다.\n(f(a) |> g()) |> h()\nf(a) |> (g() |> h())\n모든 대상에 대한 항등사상도 쉽게 만들 수 있다. 동적 언어의 경우 받은 값을 그대로\n돌려주기만 하면 된다.https://hexdocs.pm/elixir/main/Function.html#identity/1\n@spec identity(value) :: value when value: var\ndef identity(value), do: value\n제네릭을 지원하는 언어는 이를 이용하여 만들 수 있다:https://doc.rust-lang.org/std/convert/fn.identity.html\npub const fn identity<T>(x: T) -> T {\nx\n}\n당연히 하스켈에서도 쉽게 정의할 수 있다. https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:id\nid :: a -> a\nid x = x\n\nf . id == f"}},"/notes/concurrency":{"title":"동시성","data":{"":"일부에서는 병행성이라 부르기도 한다. 병렬성과의 명확한 구분을 위해 동시성이라 부르자.","병렬성과의-차이#병렬성과의 차이":"동시성은 여러 일을 한꺼번에 다루는 것이다. 병렬성은 여러 일을 한꺼번에 해내는 것이다.\n롭 파이크\n\n\nRob Pike, Concurrency is not Parallelism, 2013.동시성(concurrency)은 논리적 개념이다. 동시적인 프로그램은 병렬적으로 돌\n수도 있고, 아닐 수도 있다. 액터, 스레드 등 동시성 모델을 이용하여 실현할 수 있다.병렬성(parallelism)은 물리적 개념이다. 여러 병렬적 방법으로 동시에 계산을\n해낸다. 다중코어, 분산 시스템 등을 이용하여 실현할 수 있다.","동시성이-필요한-이유#동시성이 필요한 이유":"실세계가 동시적이기 때문에\n프로그램은 좋든 싫든, 의도했든 안했든 실세계와 상호작용한다. 그 실세계가\n동시적이므로 동시성이 필요하다.\n동시성이 없다면 파일을 다운 받으며 마우스를 움직일 수 없다.\n\n\n더 나은 성능을 위해\n한 번에 하나의 요청만 처리할 수 있는 서버는 성능이 좋지 못하다.\n현대 프로그램에서는 I/O에서 버리는 시간이 많다.\n결과를 기다리는 동안 다른 일을 할 수 있다면 좋을 것이다.\n성능 향상을 보장하지는 않는다. 동시성을 실현하기 위한 비용이 더 클 수도 있다.","동시성을-다루는-방법#동시성을 다루는 방법":"오늘날의 운영체제는 프로그램을 프로세스 단위로 실행하며 멀티태스킹한다.운영체제는 선점형 멀티태스킹으로 프로세스와 스레드를 스케줄한다. 선점형\n멀티태스킹에서는 제어권이 바뀌는 시점을 어플리케이션이 제어할 수 없다.\n이로 인하여 공유 메모리에 서로 다른 제어 주체가 의도치 않게 접근하여 예기치\n못한 오류가 발생할 수 있다. 이를 경쟁 위험이라고 하며 경쟁 위험을 막기 위한\n여러 동시성 모델(concurrency model)이 있다.\"코딩을 지탱하는 기술\"에서는 경쟁 위험을 막기 위한 방법을 크게 세 가지로 구분한다:\n공유하지 않기\n변경하지 않기\n끼어들지 않기","공유하지-않기#공유하지 않기":"공유하지 않으면 문제될 것이 없다.\n운영체제는 프로세스를 동시적으로 실행한다. 각 프로세스는 서로\n메모리를 공유하지 않는다.\n액터 모델은 프로세스와 비슷하다. 한 프로세스 내에서 실행되는 여러\n액터들은 서로 메모리를 공유하지 않는다.\n필요한 경우 메시지를 교환한다.\nCSP도 비슷하다. 메모리를 공유하지 않고 채널을 만들어 메시지로 보낸다.","변경하지-않기#변경하지 않기":"변경하지 않으면 공유해도 문제가 없다.\n여러 함수형 언어에서 할당한 값은 기본적으로 불변이다. 값이 바뀌지 않으므로 공유해도 문제가 없다.\n하스켈, 엘릭서 등의 언어가 이에 해당한다.\n모든 값을 불변으로 다루는 것이 어렵다면, 적어도 불변을 장려한다. 러스트, 스칼라, 스위프트 등의 언어는\n그 전에 만들어진 언어들보다 불변 선언이 자연스럽도록 설계되었다.","끼어들지-않기#끼어들지 않기":"공유하고 변경하더라도 타이밍만 잘 맞다면 문제가 없다.\n운영체제가 아니라 애플리케이션 수준에서 직접 작업을 스케쥴링한다.\n그린 스레드, 파이버, 코루틴 등이 이에 해당한다.\n작업 중인 메모리에 작업 중이라고 표시하여 다른 작업이 끼어들지 않도록 한다.\n락, 뮤텍스, 세마포어, 싱크로나이즈, STM 등이 이에 해당한다.","프로세스#프로세스":"","액터#액터":"프로그램을 액터(actor)와 액터 사이의 의사소통으로 본다. 각 액터는 동시에 돌아가며 정보 공유는 메시지 전달을 통해 이루어진다.","채널#채널":"CSP는 순차 프로세스 통신(communicating sequential process)의 약어이다. 스레드 사이에서 메시지를 통해 값을 공유한다는 점에서 액터와 유사하다. 액터가 메시지를 주고 받는 주체인 액터에 초점을 맞춘 것에 비해, CSP는 메시지를 주고 받는 채널에 초점을 맞추었다.고 언어에서 언어 수준에서 지원하며 많은 주목을 받았다.\nDo not communicate by sharing memory; instead, share memory by communicating.공유 메모리로 communication하지말자. communication하여 메모리를 공유하자.-- Effective Go","함수형-프로그래밍#함수형 프로그래밍":"함수형 프로그래밍(FP; functional programming)에서는 불변 변수를 최대한 활용하고, 부수 작용을 통제하는 프로그래밍 방법론이다.","그린-스레드#그린 스레드":"스레드와 비슷하게 쓸 수 있다. 프로그래밍 모델을 바꿀 필요가 없다. 스레드보다 오버헤드가 적어 많은 양의 그린 스레드를 만들 수 있다.","스레드#스레드":"스레드는 이미 널리 쓰이는 개념이며 운영체제에서 지원한다.\n기존의 동기 코드나 라이브러리를 쉽게 이용할 수 있다.\n하지만 각 스레드를 서로 동기화 하는 것은 어렵고, 스레드를 생성하고 스위칭하는 비용도 비싸다.\n\n스레드 풀을 만들어 비용을 줄일 수도 있다.\n커널 스레드: 운영체제 커널이 스케줄링한다.\n유저 스레드: 프로세스가 직접 스레드를 스케줄링한다. 커널이 볼 때에는 일반적인 프로세스로 보인다.","락#락":"교착 상태(deadlock)의 위험이 있다.","교착-상태#교착 상태":"상호 배제(mutual exclusion)\n점유 상태로 대기 (Hold and wait)\n선점 불가 (No preemption)\n순환성 대기 (Circular wait)","stm#STM":"Software transaction memory\nclojure.","비동기-프로그래밍#비동기 프로그래밍":"C#, rust, JS 등.비동기 프로그래밍은 오늘날 점점 더 많은 언어에서 지원하는 동시성 프로그래밍 모델이다. async/await 문법을 이용하여 코드가 동기적으로 보이도록 한다.적은 CPU, 메모리 오버헤드를 소모한다. 특히 서버나 DB 같은 많은 양의 IO 작업에 유리하다. 적은 수의 스레드를 런타임으로 활용하여 많고 비용이 적은 비동기 작업을 처리할 수 있다.","이벤트-기반-설계#이벤트 기반 설계":"이벤트 기반 설계(event driven architecture) 혹은 이벤트 루프는 성능이 우수하며 스레드 수가 적어도 데이터 흐름과 오류 전파를 따라가기 힘들다.자바스크립트에서 주로 사용한다.","observerable#observerable":"RxSwift, RxJs 등","용어#용어":"","공유-자원#공유 자원":"시스템 안에서 여러 스레드나 프로세스가 함께 접근할 수 있는 자원을 공유 자원(shared resource)이라고 한다.","임계-영역#임계 영역":"공유 자원에 접근하는 코드들을 임계 영역(critical section)이라고 한다.상호 배제 등의 기법으로 임계 영역에 하나의 쓰레드만이 진입하도록 보장해야한다.임계 영역이 제대로 설정되지 않으면 아래와 같은 문제가 발생할 수 있다:\n입출금 문제","경쟁-상태#경쟁 상태":"여러 스레드가 동시에 임계 영역에 접근하여 발생하는 문제를 경쟁 상태(race condition) 혹은 경쟁 위험(race hazard)라고 한다.","상호-배제#상호 배제":"임계 영역에 한 개의 프로세스만 진입할 수 있도록, 즉 원자적으로 실행할 수 있도록 하는 기법을 상호 배제(mutual exclution)라고 한다.임계 영역을 잠궈서 원자적으로 다룰 수 있다. 이를 락(lock)이라고 부르며 락을 구현한 자료구조나 스마트 포인터를 흔히 mutex라고 부른다.\n// 상호 배제가 가능한 변수를 선언한다.\nlet m = Mutex::new(5);\n{\n// 변수에 접근하기 전에 먼저 임계 영역을 잠근다.\nlet mut num = m.lock().unwrap();\n\n// 변수에 마음대로 접근할 수 있다.\n*num = 6;\n\n// 러스트에서는 블록이 끝나면 자동으로 잠금을 푼다.\n}","참고#참고":"니시오 히로카즈, 코딩을 지탱하는 기술 : 원리로 깨우치는 프로그래밍 기법, 2013.\n폴 부처, 7가지 동시성 모델, 2016.\nClojure Concurrency Tutorial for Beginners with Code Examples\n동시성 프로그래밍 하기 좋은 Clojure\n[Track 1-2] 유인동 - ES6+ 비동기 프로그래밍과 실전 에러 핸들링\n[Track 2-2] 나석주 - 비동기를 우아하게 처리하기 위한 Observable\n[Why Async? - Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/01_getting_started/02_why_asy\u001b[<43;66;8Mnc.html)\n데브시스터즈 서버 직군은 왜 코딩 면접을 볼까?"}},"/notes/cs-terms":{"title":"용어 정리","data":{"":"","구조적-타입과-명목적-타입#구조적 타입과 명목적 타입":"구조적 타입 체계(structural type system)는 구조로 타입을 구분한다.\n명목적 타입 체계(nominal type system)은 이름으로 타입을 구분한다.","참고#참고":"Alexis King, 동적 타입 시스템은 더 개방적인 시스템이 아닙니다, donghwi 역. — 원문"}},"/notes/data-structures":{"title":"자료구조","data":{"":"나쁜 프로그래머는 코드를 신경씁니다. 훌륭한 프로그래머는 자료구조와 자료구조 사이의 관계를 신경씁니다. —  리누스 토르발즈, 2006\n\n올바른 자료구조로 구성했다면 알고리즘은 언제나 자명합니다. 알고리즘이 아니라 자료구조가 프로그래밍의 핵심입니다. —  롭 파이크, 1989","adts#ADTs":"선형 리스트\n딕셔너리\n서로소 집합\n최소 신장 트리\n스택\n큐\n우선 순위 큐\n이진 검색 트리","알고리즘을-개발하기-위한-단계#알고리즘을 개발하기 위한 단계":"문제를 모델링하기\n문제를 해결하기 위한 알고리즘을 찾아 써보기\n효율적인지 확인하기\n다른 방법이 더 있는지 확인하고 개선하기","참고#참고":"2015-2017 가을학기 자료구조 및 실습 - YouTube"}},"/notes/database":{"title":"데이터베이스","data":{"":"","참고#참고":"한양미, 데이터베이스의 원리와 응용. 한양대학교, 2015."}},"/notes/design-pattern":{"title":"디자인 패턴","data":{"":"","의존성-주입#의존성 주입":"DI; Dependency Injection.\nreally just a pretentious way to say 'taking an argument'\nhttps://www.youtube.com/watch?v=ZasXwtTRkio\n내가 쓸 인터페이스부터 정의하고 (의존성), 나중에 구현체 끼어넣기 (주입).\n구현체만 바꾸면 동작이 그대로라 좋다.","예시#예시":"class UserService {\nconstructor(\n// userRepository는 여기서 의존성 주입한다.\n// 인스턴스 생성은 프레임워크에 맡긴다. (= IoC)\n@InjectRepository(User)\nprivate readonly userRepository: Repository<User>,\n) {}\n\nasync create(body: BodyDto): Promise<ResponseDto> {\n// this.userRepository로 열심히 작업한다.\n// 나중에 Repository 종류가 바뀌면 (RDB에서 documented DB로 바뀐다던가) 인터페이스가 동일한 한 Repository만 새로 구현해서 DI하면 된다.\n}\n}","의문#의문":"UserController는 어차피 UserService에 의존하는데 (그렇게 설계했으니까) 이것마저 DI할 필요가 있을까?\n모든 것들을 이것저것 DI하는데, 주입하는 대상을 바꾸었을 때 인터페이스가 바뀌는 상황이면 DI를 할 필요가 있을까?","참고#참고":"Taehee Kim, 프런트엔드에서 의존성을 제어하는 법.\nMark Seemann, Dependency injection is passing an argument.\nJin-Wook Chung, DI는 IoC를 사용하지 않아도 된다.\nRúnar Bjarnason, Dead-Simple Dependency Injection."}},"/notes/devenv":{"title":"💻 개발환경","data":{"":"셸: zsh\n편집기: helix, vs code\n터미널 레이아웃: tmux\ndotfile 관리: nyeong/.dotfiles\n생각 정리: obsidian, helix\n언어 버전 관리: asdf-vm","시스템#시스템":"MacBook Air (M1, 2020) -- macOS 참고","helix#helix":"A post-modern text editor.\nhttps://helix-editor.com/터미널에서 돌아가는 선택 기반 모달 에디터이다.\n모달 에디터라 vim이나 emacs처럼 모드를 바꿔가며 쓴다.\n마우스나 방향키가 필요 없어 손이 키보드를 떠날 필요가 적다.\n다양한 명령어를 간편한 단축키로 쓸 수 있다.\n\n\n선택 기반 모달 에디터이다.\nvim은 명령 → 선택 순서로 명령어를 입력하여, 명령이 영향을 끼치는 범위가 눈에 보이지 않는다.\nhelix는 선택 → 명령 순서로 입력하여 선택된 영역이 눈으로 보여 익히기 쉽다.\n\n\n터미널에서 TUI로 돌아간다.\nSSH에서도 쓸 수 있다.\n메모리도 적게 먹는다.\n\n\n여러 기능이 내장되어 있다.\n다중선택, LSP, tree-sitter, fuzzy finder 등등\n\n\n\n아직 플러그인을 지원하지 않는 것이 큰 단점이다.","asdf-vm#asdf-vm":"asdf다양한 언어를 하나의 명령어로 버전관리 할 수 있어서 편하다.\n왠만한 언어들은 OS의 패키지 매니저가 아니라 asdf-vm으로 관리하는 중.","용례#용례":"# gleam 플러그인 설치\nasdf plugin-add gleam https://github.com/asdf-community/asdf-gleam.git\n\n# 설치 가능한 gleam 버전 보기\nasdf list all gleam\n\n# gleam 최신 버전 설치\nasdf install gleam latest\n\n# 설치된 gleam 버전 보기\nasdf list gleam\n\n# gleam 최신 버전을 기본으로 쓰기\nasdf global gleam latest\n\n# 이 디렉토리에서는 특정 버전의 gleam 쓰기\nasdf local gleam 0.26.1","설치#설치":"git으로 설치한다. 기본 설치 위치는 ~/.asdf이다.\n~/.local/share/asdf에 설치하면 유저 레벨에서 깔끔하게 관리할 수 있다.\n설치 위치를 바꾸었으면 환경변수도 바꾸어주자.\nmkdir -p ~/.local/share\ngit clone https://github.com/asdf-vm/asdf.git ~/.local/share/asdf --branch v0.11.2\nhomebrew나 pacman 등 패키지 매니저에서 지원하긴 하는데, 환경마다 설치 위치가 달라져 관리하기 힘들고, 공식 문서에서도 권장하지 않는다.https://asdf-vm.com/guide/getting-started.html#community-supported-download-methods설치 후 셸에서 불러와야 한다. 셸에서 PATH 설정을 완료한 후 asdf.sh 파일을 불러와야한다.공식 문서에서 하라는 대로 셸 설정 파일(.bashrc, .zshrc 등)의 마지막에 아래 한 줄만 추가하면 쓸 수 있다.\n. $HOME/.asdf/asdf.sh\n나는 설정을 별도로 분리하고 싶어서 .dotfiles/zsh/init.zsh에 아래처럼 추가하고 이 파일을 ~/.zshrc에서 부르고 있다.\n# asdf-vm\nif [[ -d ~/.local/share/asdf ]]; then\nexport ASDF_DIR=$HOME/.local/share/asdf\nexport ASDF_DATA_DIR=$HOME/.local/share/asdf\n\n. $ASDF_DIR/asdf.sh\nfi"}},"/notes/dictionary":{"title":"딕셔너리","data":{"":"검색, 삽입, 삭제 세 가지 연산을 지원하는 동적 집합을 딕셔너리(dictionary)라고 부른다.흔히 딕셔너리라고 하면 아래와 같이 키와 그에 대응하는 값들이 모인 키-값 쌍의 모음을 떠올린다:\ndic = {'alice': [1, 2, 3], 'bob': 42}\n## dic['alice'] = [1, 2, 3]\nADT로서 정의하고자 하는 딕셔너리는 이보다 더 일반적이다. 파이썬의 딕셔너리도 검색, 삽입, 삭제가 가능하므로 딕셔너리 ADT의 구현체라고 할 수 있다. 더 넓게 보면 배열이나 연결 리스트와 같은 선형 리스트나 이진 탐색 트리도 마찬가지로 검색, 삽입, 삭제가 가능한 동적 집합이므로 딕셔너리이다.수많은 일반적인 데이터 처리는 딕셔너리의 연산으로 처리할 수 있다. 딕셔너리라는 ADT를 정의함으로서 일반적인 데이터 처리 알고리즘을 표현할 기준이 생기고, 또한 어떤 구현체가 해당 알고리즘에 효과적인지 손쉽게 분석할 수 있다.그래도 딕셔너리면 키-값 쌍이여야 하는 거 아니야? 선형 리스트면 키-값 쌍이 아니잖아? 라는 생각이 든다면 맘 편히 키값이 값과 같다고 생각해도 좋고, 키가 인덱스와 같다고 생각해도 좋다.\nlinear_list_0 = { 0 => '철수', 1 => '영희', 2 => '명수', 3 => '상수'}\nlinear_list_1 = { '철수' => '철수', '영희' => '영희', '명수' => '명수', '상수' => '상수'}\nlinear_list_2 = ['철수', '영희', '명수', '상수']","연산#연산":"아래의 정의는 \"The Algorithm Design Manual\"과 \"Introduction to Algorithms\"을 참고하였다.\n: 딕셔너리 에서 키 에 대응하는 원소의 포인터를 반환한다.\n: 딕셔너리 의 집합에 포인터 가 가리키는 원소를 추가한다.\n: 딕셔너리 에서 포인터 가 가리키는 원소를 삭제한다. (키값이 아닌 원소 에 대한 포인터임에 유의한다.)\n: 딕셔너리 에서 가장 키값이 작은 원소을 반환한다.\n: 딕셔너리 에서 가장 키값이 큰 원소을 반환한다.\n: 정렬된 딕셔너리 에서 포인터 가 가리키는 원소의 다음 원소를 반환한다.\n: 정렬된 딕셔너리 에서 포인터 가 가리키는 원소의 이전 원소를 반환한다.\n\n위의 연산은 딕셔너리의 내용을 바꾸는 수정연산(, )과 내용을 바꾸지 않는 탐색연산(, , , , )으로 나눌 수 있다.","구현#구현":"선형 리스트로 구현할 수 있다.\n이진 탐색 트리를 이용하여 구현할 수 있다.\n해시 테이블을 이용하여 구현할 수 있다.","선형-리스트#선형 리스트":"선형 리스트로 구현한다면 정렬의 유무에 따라 효과적인 연산이 달라진다. 정렬하지 않을 경우 수정연산이 효과적이고, 정렬할 경우 탐색연산이 효과적이다.\n연산\tunsorted array\tsorted array\tunsorted linked list (s/d)\tsorted linked list (s/d)\t\t\t\t / \t / \t\t\t\t / \t / \t\t\t\t / \t / \t\t\t\t / \t / \t\t\t\t / \t / \t\t\t\t / \t / \t\t\t\t / \t /\n연결 리스트도 단순이냐, 이중이냐에 따라 연산의 비용이 달라진다. 단순일 경우 다음 노드를 찾기 쉬우나, 이전 노드를 찾기 위해서는 결국 순회해야 하므로 의 비용이 든다.\n이중 연결 리스트는 이전 노드에 대한 정보도 함께 갖고 있으므로 삭제 연산의 비용이 으로 줄어들며, 정렬되었을 경우  연산도 으로 줄어든다.","이진-탐색-트리#이진 탐색 트리":"연산\tbinary search tree","참고#참고":"Steven S.Skiena. \"The Algorithm Design Manual\" 2008.\nThomas H.Cormen et al. \"Introduction to Algorithms\" 2009."}},"/notes/dining-philosophers":{"title":"식사하는 철학자 문제","data":{"":"다섯 명의 철학자가 원탁에 둘러 앉는다. 철학자들은 생각을 하다 이따금 스파게티를 먹는다. 철학자들 사이엔 포크가 놓여 있는데, 양쪽의 포크를 모두 사용하여 식사를 한다.\n일정 시간 동안 생각을 한다.\n왼쪽의 포크를 집어든다. 포크가 사용중이면 대기한다.\n오른쪽의 포크를 집어든다. 포크가 사용중이면 대기한다.\n양쪽의 포크를 잡았다면 일정 시간 동안 식사를 한다.\n오른쪽 포크를 내려놓는다.\n왼쪽 포크를 내려놓는다.\n1번으로 돌아간다.","교착상태#교착상태":"이 문제는 1965년에 컴퓨터 과학자 에츠허르 데이크스트라(Edsger W. Dijkstra) 박사가 교착상태(deadlock)을 설명하기 위해 만든 것으로 알려져있다.어느 순간 모든 철학자가 왼쪽의 포크를 집어든 순간을 상상해보자. 모든 철학자는 이미 사용중인 자신의 오른쪽 포크를 기다리기만 하고 아무것도 하지 못하는 교착상태(deadlock)에 빠지게 된다.","해결-방법#해결 방법":"자원 위계 해결법\n적어도 한 명의 철학자는 다른 순서로 포크를 집도록 하여 순환 의존성을 없앤다.\n다섯 개의 뮤텍스가 필요하다.\n언뜻보면 손쉽고 좋은 해결책인 것 같으나 허점이 많은데, 가령 오른쪽 포크부터 집는 철학자는 생각이 길면 밥을 절대 먹을 수 없다.\n또한 자원의 갯수를 미리 알아야 해결할 수 있다.\n\n\n타임아웃을 이용한 해결법\n일정 시간 동안 자원을 얻지 못하면 자원을 반환하고 처음부터 작업을 다시한다.\n근본적인 해결법은 아니나 빠르게 적용할 수 있는 임시방편이다.\n\n\n중재자 해결법\n포크를 감독할 웨이터를 둔다. 포크를 감독하다 포크 하나만 남으면 왼손에 포크를 쥔 철학자에게만 포크를 준다.\n뮤텍스 하나만 있으면 된다.\n\n\nn-1 해결법\n철학자를 감독할 웨이터를 둔다. 적어도 한 명의 철학자를 기다리게 한다.\n뮤텍스 하나와 세마포어 하나가 있어야 한다.\n\n\nChandy/Misra 해결법\n메시지 패싱을 이용한 해법.\n철학자가 서로 대화할 수 있을 경우의 해법이다. (메시지 패싱하므로)\nMSPC를 이용하여 해결한다.","참고#참고":"데드락 (DeadLock, 교착 상태) | 👨🏻‍💻 Tech Interview"}},"/notes/disjoint-set":{"title":"서로소 집합","data":{"":"disjoint sets. 그래프 추상 자료형. union 연산과 find 연산을 쓰기 때문에\nunion-find 자료구조라고도 한다.","연산#연산":"union: 두 오브젝트를 연결함.\nfind: 두 오브젝트가 연결 되었는지 질의함.\n\nunion, 즉 연결에 대한 합의가 있어야 한다. 따라서 연결을 다음과 같이 정의한다.오브젝트 가 다른 오브젝트 에 연결되었음을 라고 하자.\n반사적(reflexive):  모든 객체는 자기 자신과 연결되어있다.\n대칭적(symmetric): 이면 이다. 연결은 양방향이다.\n추이적(transitive): 이고 이면 이다.\n\n반사적, 대칭적, 추이적 용어는 이산수학에서 관계를 표현하는 용어를 그대로 썼다.연결되어 있는 가장 커다란 집합을 연결 요소(connected component)라고 부른다.\n아래의 그림에서는 0은 {0} 그 자체, 1, 4는 서로 연결되어 있으므로 {1, 4},\n2, 3도 마찬가지로 {2, 3}이 연결 요소라고 볼 수 있다. 연결 요소를 이용하면\nfind 연산을 오브젝트끼리 연결 되어있는지 확인하는 문제에서 하나의 연결 요소에\n포함되어있는지 확인하는 문제로 바꿀 수 있다.\n0 1 2-3\n|\n4","구현#구현":"","quick-find#Quick Find":"find 연산이 빠른 구현이다.선형 리스트를 이용하여 간단히 구현할 수 있다. 아래의 서로소 집합을 예로 보자:\n0  1--2  3--4\n|     |  |  |\n5--6  7  8  9\n이를 선형 리스트로 나타내면 아래와 같다. 각각의 원소를 인덱스로, 리스트의 값을\n연결 요소의 id로 표현한다. 같은 연결 요소에 있다면 같은 리스트 값을 가진다:\nindex     0   1   2   3   4   5   6   7   8   9\n+---+---+---+---+---+---+---+---+---+---+\ncontent | 0 | 1 | 1 | 8 | 8 | 0 | 0 | 1 | 8 | 8 |\n+---+---+---+---+---+---+---+---+---+---+\n0, 5, 6은 같은 연결 요소에 있기 때문에 해당 인덱스의 리스트 값이 같다.find 구현은 쉽다. 와 의 연결 요소가 같은지 확인하면 된다.union는 조금 번거롭다. 연결 할 때 같은 연결 요소의 원소 수만큼 그 내용을\n바꾸어주어야 한다. 위의 그림에서 0번 연결 요소({0, 5, 6})과 8번\n연결 요소({3, 4, 8, 9})를 union한다고 생각해보자. 0번의 원소를 8로 바꾸거나\n8번의 원소를 0으로 바꾸어주어야한다. 연결 요소 의 원소를 별도로 저장하지 않는다면\n배열 전체를 순회하며 확인해야한다."}},"/notes/elixir":{"title":"엘릭서","data":{"":"","이상한-점#이상한 점":"혹은 아쉬운 점","익명-함수#익명 함수":"정확히는 변수에 할당된 함수를 호출하는 과정이 번잡스럽다.\n# `def`로 함수를 정의하고 호출할 때에는 아무 문제가 없다\ndef add(x, y), do: x + y\nadd(1, 2)\n\n# 익명 함수를 변수에 할당하고 호출하려면 `.`을 찍어야 한다.\nadd = fn x, y -> x + y end\nadd.(1, 2)\n\n# 기명 함수를 변수에 할당하고 출력할 때에도 `.`을 찍어야 한다.\nadd = &+/2\nadd.(1, 2)\nadd를 변수로써 다룰 때와 함수로써 호출할 때를 구별하기 위하여 .을 찍어야\n한다.참고: Anonymous Function and the Dot","iex에서-바로-함수를-정의할-수-없음#iex에서 바로 함수를 정의할 수 없음":"iex에서 def로 함수를 정의하려고 하면 모듈에서 하시오! 하며 거부한다.루비는 irb에서 선언한 것들을 모듈로 감싸주던 것 같은데 잘 기억 안난다.\niex> def sum(a, b), do: a + b\n** (ArgumentError) cannot invoke def/2 outside module\n(elixir 1.14.2) lib/kernel.ex:6387: Kernel.assert_module_scope/3\n(elixir 1.14.2) lib/kernel.ex:5084: Kernel.define/4\n(elixir 1.14.2) expanding macro: Kernel.def/2\niex: (file)","arity#arity?":"함수를 다룰 때 arity, 차수를 중요하게 다룬다. 어떤 함수를 특정하기 위해서는\n함수 이름 + 차수가 필요하다.\ndef some_function(a)\ndef some_function(a, b)\n\n&some_function/1\n&some_function/2","패턴-매칭으로-함수-분리#패턴 매칭으로 함수 분리":"엘릭서에서는 함수의 인자를, 선언부부터 패턴매칭 할 수 있다.\n이를 이용하여 어떤 인자가 넘어오냐에 따라 아예 다른 함수 몸체를 호출한다.\n그런데 실질적으로 다른 동작을 함에도 불구하고 같은 함수 취급을 받는다.아래처럼 같은 맥락을 다루는 경우라면 문제가 없지만...:\n@spec elevator(integer()) :: String.t()\ndef elevator(1), do: \"Go to 1st floor\"\ndef elevator(2), do: \"Go to 2nd floor\"\ndef elevator(3), do: \"Go to 3rd floor\"\ndef elevator(a), do: \"Go to #{a}th floor\"\n이게 타입 시스템과 물리면 분석하기 어려워진다. 아래의 negate/1 함수의 예를\n보자.\n@spec negate(x :: integer() | boolean()) :: integer() | boolean()\ndef negate(x) when is_integer(x), do: -x\ndef negate(x) when is_boolean(x), do: not x\n여기서 선언한 negate/1 함수는\nnegate(1) = -1이며 negate(true) = false로 상식적이고 예측 가능한 함수이다.그러나 타입만 보면 integer() | boolean()을 받아서 integer() | boolean()을\n반환하는 함수이므로 integer() -> booelan() 혹은 booelan() -> integer()인\n경우도 (타입만 본다면) 있을 수 있다.\n# 인간이 볼 때, `negate`는 `integer -> integer | boolean -> boolean`이지만\n# 현재 엘릭서의 타입 시스템으로는 `integer | booelan -> integer | boolean`이다.\n\nres = negate(3)\n\n# 따라서 사람에게 res가 `integer`임은 당연하고, 바로 알 수 있지만\n# 정적 분석 도구는 res가 `integer | boolean`일 것으로 예측한다.\n엘릭서에서 자주 쓰는 GenServer에서 쓰이는 디자인 패턴을 보면 해당 모듈이\n서버로서 받는 요청을 handle_call, handle_cast 콜백을 구현함으로서\n처리한다. 아무리 많은 콜백을 만들더라도 결국은 handle_call/3, handle_cast/2\n두 개의 함수만 남게 된다.이러한 프로그램이 엘릭서 코드를 분석하기 어렵게 하며, 도구의 지원을 받기 어렵게\n하는 것 같다.아래는 엘릭서에서 자주 쓰는 GenServer 패턴이다.\ndefmodule Stack do\nuse GenServer\n\n@impl true\ndef handle_call(:pop, _from, [head | tail]) do\n{:reply, head, tail}\nend\n\n@impl true\ndef handle_cast({:push, element}, state) do\n{:noreply, [element | state]}\nend\nend\n\n{:ok, stack} = GenServer.start_link(Stack, [])\nGenServer.call(stack, :pop)\nGenServer.cast(stack, {:push, :value})\n스택에서 값을 꺼내지 않고 제일 위의 값을 확인하는 peek 연산을 구현한다고 하자.\n그러면 handle_call의 첫번째 인자가 :peek인 특수한 경우로서 처리하게 된다:\n# 구현\ndef handle_call(:peek, _from, [head | _] = state), do: {:reply, head, state}\n\n# 사용\ntop_of_stack = GenServer.call(stack, :peek)\nhandle_call 함수는 실질적으로 다른 맥락에 따라 다른 동작을 하지만 단 하나의\n함수이며, 처리해야하는 경우가 많아질 수록 복잡한 타입을 갖게 되어 분석이\n어려워 질 것이다.엘릭서 코어팀은 집합 기반 타입 시스템을 도입하여 이를 해결하고자 하고 있다.https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/","typespec#Typespec":"컴파일 언어이면서 동적 타입 시스템인 것이 일단 독특하다.\n생각 외로 이런 언어가 많긴 하다. Clojure도 그렇고, CPython도 내 기억으론\n실행 전에 바이트코드로 컴파일된다.\n구조체의 타입은 타입스펙으로 별도로 선언해주어야함.\n구조체는 모듈 이름을 따르면서, 구조체의 타입은 그렇게 할 수 없음(t()).\n타입 표시에 자꾸 괄호(())를 붙여야 함.\n\n아래는 웹 애플리케이션을 다룰 때 주로 쓰는 Plug.Conn 객체의 구현의 일부이다. 구조체를 다룰 때 아래처럼 defstruct에는 필드와 초기값을 선언하고, 필요하다면 @type으로 그에 대한 타입을 덧붙여준다.\ndefmodule Plug.Conn do\ndefstruct adapter: {Plug.MissingAdapter, nil},\nassigns: %{},\nbody_params: %Unfetched{aspect: :body_params}\n# 이외의 필드는 숨김\n\n@type t :: %__MODULE__{\nadapter: adapter,\nassigns: assigns,\nbody_params: params | Unfetched.t()\n# 이외의 필드는 숨김\n}\nend\n이러다보니 각 필드를 두 번 선언해야한다. 고칠 때에도 두 번 고쳐야 하는데... 생각해보니 보통의 언어들도 초기값을 정의하려면 그런 것 같기도 하고?하지만 구조체는 모듈을 기준으로 선언하면서, 타입은 모듈 이름으로 선언 못하고,\nt를 붙여줘야하는 건 확실히 이상하고 어색하다. 거의 표준처럼 쓰고 있지만\n표준은 아닌 듯.그래서 타입을 선언할 때 String을 String이라고 부를 수 없다.\ndefmodule String do\n# Typespec으로 String은 이렇게 선언한다.\n@type t :: binary\nend\n\n# `ends_with?`이라는 함수를 만드려면, 아래와 같이 `String.t()`로 선언해야 한다.\n@spec ends_with?(String.t(), String.t()) :: boolean()\n추가로 위의 ends_with?/2 함수의 스펙은 괄호 없이 아래처럼 적어도 되긴 하다:\n@spec ends_with?(String.t, String.t) :: boolean"}},"/notes/exceptions":{"title":"예외를 처리하는 방법","data":{"":"","오류를-반환하기#오류를 반환하기":"","특수한-값으로-반환하기#특수한 값으로 반환하기":"C언어에서는 파일을 열 때 fopen 함수를 쓴다. 이 함수는 힙에 파일 객체를 생성하고 포인터를 반환하는데, 파일 열기에 실패하였다면 널 포인터를 반환한다.https://cplusplus.com/reference/cstdio/fopen/\n#include <stdio.h>\n\nint main() {\nFILE * file = fopen(\"somefile\", \"r\");\nif (file == NULL) {\n// handle error\n}\n\n// do something with `file`\n}","평범한-값으로-반환하기#평범한 값으로 반환하기":"성공했을 때에는 성공값을 반환하고, 오류가 났을 때에는 오류값를 반환한다. 둘의 경우를 구분하기 위하여 구분자를 붙이거나 순서를 달리한다.\n// go의 경우. 첫번째 반환값은 성공값이고 두번째 반환값은 오류값이다.\nfunc Divide(a, b int) (int, error)\n\nres, err := Divide(3, 0)\n\n# elixir의 경우. `:ok`와 함께 반환되면 성공값이고, `:error`와 함께 반환되면 오류값이다.\n@spec divide(integer, integer) :: {:ok, integer} | {:error, :divide_by_zero}\n\ncase divide(3, 0) do\n{:ok, res} -> IO.puts(\"success!\")\n{:error, e} -> IO.puts(\"input new value\")\nend","result-모나드#\bResult 모나드":"enum Result<T, E> {\nOk(T),\nErr(E)\n}","오류를-던지기#오류를 던지기":"","참고#참고":"Timur Doumler, How C++23 changes the way we write code - Meeting C++ 2022"}},"/notes/hanassig":{"title":"하나씩","data":{"":"","목표#목표":"배운 것들을 조리있게 정리하기\n정보를 정리하는 과정에서 더 잘 기억하고 구조화하기\n나중에 기억나지 않더라도 찾아볼 수 있도록 하기\n\n\n로컬에서 편리하고 빠르게 정리하기\n웹은 정 필요하면. 급하면 github repo 링크를 써도 된다.\nGitHub Code View가 좋아져서 왠만하면 필요 없겠는걸?","구성#구성":"nyeong/hanassig — 해당 저장소\nnyeong/hanassig issues — 이슈 트래커","디렉토리-구성#디렉토리 구성":"assets/ — 이미지, 동영상 등 첨부파일\nnotes/ — 문서를 모아둔 곳","글-구성#글 구성":"---\ntitle: 글 제목\ndescription: 글 설명\ndate: 글 작성 일자\ntags:\n- 태그\n---\n\n## 도구\n\n- obsidian\n- foam\n- helix\n\n## 참고\n\n- [기계인간 John Grib](https://johngrib.github.io/)\n- [MaggieAppleton/digital-gardeners](https://github.com/MaggieAppleton/digital-gardeners)\n- [TuanManhCao/digital-garden](https://github.com/TuanManhCao/digital-garden)"}},"/notes/idris":{"title":"idris","data":{"":"","어떤-언어인가#어떤 언어인가":"타입 주도 개발(type driven development)을 위해 개발됨\n타입이 1급 구조(first-class constructs)임\n문자열, 정수 등의 값처럼 타입을 다룰 수 있음\n함수에 인자로서 전달될 수 있음\n함수가 반환할 수 있음","기본-도구와-생태계#기본 도구와 생태계":"idris — 컴파일러이자 REPL이자 타입 분석 도구","repl에서#REPL에서":"The Idris REPL — Idris 1.3.3 documentation\n:module <module name> — 모듈 불러오기\n:l <file name> — 파일 불러오기\n:t <expr> — 타입 확인하기\n:r — 다시 불러오기\n:t — 값 바인딩하기","기본-자료구조#기본 자료구조":"수: Int, Integer, Double\n문자: Char, String\n포인터: Ptr\n부울: Bool, True, False\n타입: Type\n\n표현문의 끝은 들여쓰기로 구분한다. 값의 타입 지정과 선언은 아래와 같이 한다.\n하스켈과 다르게 타입 지정을 :로 하고, 리스트 연결을 ::로 한다.\nx : Int\nx = 3\nidris로 작성한 자연수 타입 Nat와 리스트 타입 List의 선언은 아래와 같다:\ndata Nat = Z | S Nat\ndata List a = Nil | (::) a (List a)","의존-타입#의존 타입":"보통의 언어들은 타입 선언에서는 타입만 다룰 수 있고, 함수의 몸체에서는 값만 다룰 수 있다. idris의 타입은 1급 시민으로, 값과 차이 없이 다룰 수 있다. 인자로도 받을 수 있고, 함수가 반환도 할 수 있다. 아래의 예시에서 대문자로 시작하는 것들은 모두 타입이다.\nisSingleton : Bool -> Type\nisSingleton True = Nat\nisSingleton False = List Nat\n이렇게 정의한 함수를 다시 타입 선언에 활용할 수도 있다.\n아래의 예시에서는 위에서 정의한 isSingle 함수를 이용하여 경우에 따라 다른 타입을 반환한다.\nmkSingle : (x : Bool) -> isSingleton x\nmkSingle True = 0\nmkSingle False = []\n\n타입 선언은 컴파일 타임에 실행되며, 프로그램의 검증을 위해 쓰인다.\n함수 몸체는 런타임에 실행되며, 프로그램의 동작을 위해 쓰인다.\n\n이렇게 보는 게 편할 것 같다."}},"/notes/korean-encoding":{"title":"한글 인코딩","data":{"":"파인더에서는 멀쩡한 파일 이름이 helix 에디터에서 망가지는 이유를 알아보자.","동치#동치":"UNICODE NORMALIZATION FORMS - 1.1 Canonical and Compatibility Equivalence유니코드에서 \"같음\"에 대한 두 가지 정의가 있다. 정준 동치와 호환 동치다:두 문자 시퀀스가 동일한 모양과 의미와 기능을 지닐 경우 \"같다\"고 할 수 있다.\n이를 정준 동치(canonical equivalence)라고 한다.예를 들어 가와 ᄀ+ᅡ는, 유니코드는 U+AC00, U+1100, U+1161로 서로 다르지만\n이를 읽는 이는 동일하게 '가'로 읽을 것이다. 따라서 프로그램도 이를 동일한\n글자로 취급하고 다뤄야 한다.호환 동치(compatibility equivalence)는 이보다는 큰 범위의 \"같음\"이다.\n모양이나 기능이 조금 다르더라도 비슷한 의미를 지녔으면 같은 글자로 취급한다.예를 들어 𝑓는 f와 모양이 다르므로 표준 동치로는 서로 다른 문자이다.\n그러나 두 문자 모두 f를 의미하므로 호환 동치로는 같은 문자로 취급하고 다룬다.구글 검색은 문자열을 호환 동치하기 때문에 𝑓를 검색하여도 f를 검색한 것과\n결과가 같다.\n\nhttps://www.compart.com/en/unicode/U+1D453","정규화#정규화":"UNICODE NORMALIZATION FORMS - 1.2 Normalization Forms동치의 개념에서 보았듯, 유니코드에서는 같은 의미의 문자라도 여러 방법으로\n표현할 수 있다. 따라서 이를 통일할 방법이 필요하며 이를\n정규화(normalization)라고 부른다.정규화에는 네 가지 방법이 있다.\nNFD: 정준 분해\nNFC: 정준 분해 후 정준 결합\nNFKD: 호환 분해\nNFKC: 호환 분해 후 정준 결합\n\n대부분의 한글 표기는 호환 동치와는 무관하므로 정준 분해에 대해서만 보면 아래와\n같다:\n가(U+AC00)를 정규화하면...\nNFD: → ᄀ(U+1100) + ᅡ(U+1161)\nNFC: → 가(U+AC00)\n\n\nᄀ(U+1100) + ᅡ(U+1161)를 정규화하면...\nNFD: → ᄀ(U+1100) + ᅡ(U+1161)\nNFC: → 가(U+AC00)","뭐가-맞는가#뭐가 맞는가":"https://unicode.org/reports/tr29/#Standard_Korean_Syllables","macos에서#macOS에서":"convmv -r -f utf-8 -t utf-8 --nfc . --notest","참고#참고":"유니코드 등가성\nUnicode® Standard Annex #15"}},"/notes/life-optimization":{"title":"최적화","data":{"":"내 삶을 최적화하기","목표#목표":"시간/할 일 관리\n지식 관리","행동원칙#행동원칙":"모든 \"입력\"을 미리 알림에 몰아 넣는다.\n틈틈이 미리 알림을 확인하여 각 항목을 평가한다.\n어떤 항목이 \"행동\"이면...\n\n\n10분 내에 할 수 있는 행동이면 당장하고 Logseq에 기록한다.\n- 프로젝트와 관련된 일이면 노션/프로젝트에도 기록한다.\n다른 사람이 해야하는 일이면 위임하고 Logseq에 기록한다.\n나중에 해야하는 일이면...\n특정 날짜나 특정 시간에 해야만 하는 일은 캘린더에 기록한다. (주택청약 신청 등)\n빨리 하면 좋은 일들은 다이어리/할일에 기록한다. (중고 게시글 올리기 등)\n\n\n\n\n\n\n그 외의 항목은...\n가치가 없는 항목은 지운다.\n연속되는 행동이 요구되는 일들은 노션/프로젝트에 프로젝트로 만든다. (일본어 공부하기)\n당장은 아니고 언젠간 하고 싶은 일은 상태:언젠간으로 기록한다. (1종 대형 취득하기)\n\n\n나중에 읽을 글은 노션/북마크에 기록한다.\n시간이 남을 때 하나씩 본다.\n\n\n사고 싶은 것은 다이어리/위시리스트에 기록한다.","도구#도구":"미리 알림\n생각나는 모든 것들을 털어놓는 곳\n최대한 가볍게 쓰자. 목록도 하나만 쓴다.\n\n\n캘린더\n특정 날짜나 특정 시간에 해야만 하는 일 기록용\n\n\n노션\n프로젝트 관리\n프로젝트 관련하여 발전시킨 생각 정리\n\n\n데이터베이스\n읽은 책, 읽은 글 관리\n\n\n\n\nLogseq\n한 일 목록 작성용\n\n\n다이어리\nNAS\n데이터베이스\n\n\n하나씩\n데이터베이스\n\n\nSpark","참고#참고":"도구\n지식관리 도구\nLogseq,\n\n\n할 일 관리 도구\nGitHub Issues, 칸반보드\n\n\n\n\n여러가지 모델\n시간/할 일 관리\nGTD\n작명5개항\nMETT-TC\n\n\n지식관리\n제텔카스텐"}},"/notes/linear-list":{"title":"선형 리스트","data":{"":"선형 리스트(linear list)는 자료가 순서 있게 나열된 추상적 자료형(ADT)입니다.아래와 같은 예시를 생각해볼 수 있습니다:\n(폰, 룩, 퀸, 킹, 비숍, 나이트)\n(월, 화, 수, 목, 금, 토, 일)\n(1, 2, 3, 4, 5, ...)\n그 외 순서 있게 나열할 수 있는 모든 것들","구분#구분":"선형 리스트에 포함된 자료의 타입이 모두 같다면 동형(homogeneous)이라고 합니다.\n아래는 러스트의 배열이며, 동형 선형 리스트입니다.\nlet ages: [i32; 4] = [15, 26, 34, 42];\n반대로 자료의 타입이 다를 수 있다면 이형(heterogeneous)이라고 합니다.\n아래는 엘릭서의 리스트이며, 이형 선형 리스트입니다.\ninputs = [:something, \"Hello\", 42]","연산#연산":"길이 구하기\n모든 원소를 하나씩 방문하기\n번째 원소 구하기\n번째 원소 바꾸기\n번째 자리에 새 원소를 삽입하고 나머지 원소를 뒤로 밀기\n번째 원소를 삭제하고 나머지 원소를 앞으로 당기기\n서로 다른 두 리스트를 합치기","구현#구현":"","배열#배열":"배열(array)은 가장 기본적인 연속적 자료구조입니다.고정된 크기의 메모리에 각 원소가 순서에 맞게 연속적으로 저장됩니다.\n각 원소에 바로 접근할 수 있어 효율적이지만, 원소를 더하거나 뺄 때 형태를\n유지하기 위해 비용이 필요합니다.","장점#장점":"랜덤 엑세스가 가능하다: 시작 주소와 인덱스로 각 원소의 메모리 주소를 바로\n알 수 있기 때문에 각 원소에 바로 접근할 수 있습니다.\n공간 효율성이 좋다: 순수한 데이터의 나열이기 때문에 낭비되는 공간이 없습니다.\n메모리 지역성이 좋다: 현대 컴퓨터는 캐시 메모리를 적극 이용하는데, 배열은\n연관된 자료가 한 곳에 모여있으므로 캐시 적중률이 좋아서 실질적으로 더 빠릅니다.","단점#단점":"프로그램 실행 중 그 크기를 바꿀 수 없습니다.\n동적 배열로 해결할 수 있습니다.\n\n\n리스트를 쪼개고 합치거나, 앞에 자료를 추가하는것이 비효율적입니다.\n리스트의 개의 원소를 옮겨야하므로, 의 비용이 듭니다.","용례#용례":"대부분의 프로그래밍 언어들이 동적 배열을 기본 선형 리스트로 사용합니다.효율이 중요한 시스템 프로그래밍 언어들은 배열","연결-리스트#연결 리스트":"연결 리스트(linked list)는 가장 기본적인 연결적 자료구조입니다.각각의 원소는 메모리 이곳저곳에 떨어져서 저장되고, 이들을 포인터로 논리적으로\n연결합니다. 각 원소가 논리적으로 연결되어 있기 때문에 중간에 값을 추가하거나\n자르거나 나누거나 합치는 등의 연산은 효율적이지만 랜덤 엑세스가 불가능하여\n특정 원소를 찾기 위해서는 대부분의 경우 앞에서부터 순차적으로 확인해야합니다.","장점-1#장점":"쪼개고 잇는 연산이 효율적이다: 배열은 수정을 위해서 배열 전체를 복사해야\n하지만 연결 리스트는 그럴 필요가 없습니다. 해당 노드에서 다음 노드로의\n연결 고리만 바꾸어주면 되기 때문에 상수시간()에 해결할 수 있습니다.\n원소의 순서를 바꿔야할 필요가 있을 경우에도, 원소 자체를 옮기는 것보다는\n포인터를 바꾸는 것이 훨씬 효율적입니다.\n성능이 일정하다: 동적 배열의 경우 실행 중간에 크기가 커질 때에 한해\n성능 저하가 일어나기 때문에 성능이 일정하지 않습니다.\n추가가 자유롭다: 컴퓨터의 메모리가 부족하지 않는 이상 오버플로우 등의\n문제를 겪을 일이 없습니다.","단점-1#단점":"최적화가 어렵습니다. 캐시 지역성(cach locality)이 좋지 않기 때문에 캐시\n적중률이 낮으며, 반드시 포인터로 메모리 여기저기를 순회해야합니다.\n랜덤 엑세스가 불가능합니다. 리스트의 마지막 원소에 접근하려면 대부분의 경우\n전체 리스트를 순회해야합니다.\n공간 효율성이 나쁩니다. 포인터를 활용하기 때문에 반드시 배열보다 많은 메모리를\n사용합니다.","용례-1#용례":"불변 자료구조를 적극 활용하는 프로그래밍 언어들이 연결 리스트를 기본 선형 리스트로\n자주 사용합니다. ex) 엘릭서의 List, 하스켈의 [a]이러한 언어들은 언어 차원에서 리스트를 쪼개고 잇는 연산을 쉽게 쓸 수 있도록 지원합니다.\nlist = [1, 2, 3, 5, 7]\n\n[_ | primes] = list\nassert primes == [2, 3, 5, 7]\n이러한 언어들은 포인터로 잇는 연결적 자료구조의 특성을 적극 활용하여 성능을 높입니다.\n이를 영속적 자료 구조(persistent data structure)라고 합니다.\n예를 들어 아래와 같이 1, 2, 3, 4를 담은 연결 리스트 list가 있고, 이를 이용해\nnew_list를 만들었다고 합시다:\nlist = [1, 2, 3, 4]\nnew_list = [0 | list]\n연결 리스트의 특성을 활용하면 1, 2, 3, 4를 복사하지 않고도 이를 표현할 수 있습니다.\n/-> [1, 2, 3, 4]\n[0, *]\n그러나 위에서 언급한 단점으로 인하여 데이터를 저장하고 다룰 때에는 배열을 쓸 수\n있도록 지원하고 있습니다. ex) 엘릭서의 :array, {}, 하스켈의 Data.Array 등."}},"/notes/machine-learning":{"title":"🤖 기계학습","data":{"":"주어진 데이터를 이용하여 문제를 해결하기 위해 최적의 모델을 찾는 학문.","종류#종류":"지도학습(supervised learning) — 정답이 주어지는 학습\n분류(classification)\n회귀(regression)\n\n\n비지도학습(unsupervised learning) — 정답이 주어지지 않는 학습\n클러스터링(clustering)\n\n\n자기지도학습(SSL; Self-Supervised Learning) — 정답이 없을 경우 직접 달면서 학습\n단어 임베딩 등\n\n\n강화학습(reinforcement learning) — 행동을 통해 보상을 얻으며 학습","지도학습#지도학습":"데이터에 정답 가 주어지는 경우 지도학습 알고리즘을 쓸 수 있다.\n분류 — 예측하고자하는 레이블이 이산적일 경우 분류 문제이다.\n스팸이거나 아니거나. 글의 카테고리가 무엇인지 등.\nKNN, SVM, 의사 결정 트리 등을 이용하여 해결한다.\n\n\n회귀 — 예측하고자하는 값이 연속적일 경우 회귀 문제이다.","과정#과정":"데이터를 수집한다.\n데이터를 분석하여 파악하고 학습에 맞게 전처리한다.\n적절한 모델을 세워서 학습한다.\n학습 결과에 대해 평가한다.\n반복","평가#평가":"","혼동행렬#혼동행렬":"알고리즘의 정확성을 평가하기 위한 도구.\n구분\t예측 참 (P)\t예측 거짓 (N)\t실제 참\tTP\tFN\t실제 거짓\tFP\tTN\n\n; True Positive — 참양성 혹은 참긍정\n; False Positive — 위양성 혹은 거짓긍정\n; False Negative — 위음성 혹은 거짓부정\n; True Negative — 참음성 혹은 참부정\n\n위 값을 이용하여 정밀도, 재현율, 정확도를 구하여 알고리즘을 평가한다:\n정밀도(precision) — 참으로 예측한 것이 얼마나 맞는가\n\n재현율(recall) — 실제로 참인 것을 얼마나 맞추는가\n\n정확도(accuracy) — 정답을 얼마나 맞추는가\n\n값 —","과적합과-과소적합#과적합과 과소적합":"모델이 데이터를 과하게 학습한 경우 과적합(overfitting)이라고 한다.\n학습 데이터에서는 높은 성능을 발휘하지만 평가 데이터에서는 성능이 떨어진다.\ndropout, early stopping을 활용한다.\n\n모델이 충분히 데이터를 학습하지 못한 경우 과소적합(underfitting)이라고 한다.\n학습 데이터에서도 높은 성능을 발휘하지 못한다.","참고#참고":"Team-Neighborhood/I-want-to-study-Data-Science\n유원준, 딥 러닝을 이용한 자연어 처리 입문. WikiDocs, 2022."}},"/notes/macos":{"title":"macOS","data":{"":"","자잘한-설정#자잘한 설정":"","런치패드#런치패드":"기본앱 폴더 하나 만들어서 모조리 넣어버리자.","독-조절하기#독 조절하기":"독에 있는 모든 것을 없애기\n아이콘을 밖으로 드래그하면 없앨 수 있다\n시스템 설정 → 데스크탑 및 Dock에서\nDock에서 최근 사용한 응용 프로그램 보기 끄기","미션-컨트롤#미션 컨트롤":"시스템 설정 → 데스크탑 및 Dock에서\nSpaces를 최근 사용 내역에 따라 자동으로 재정렬 끄기","시간#시간":"시스템 설정 → 일반 → 날짜 및 시간에서 24시간제 켜기","키보드#키보드":"시스템 설정 → 키보드에서\n키 반복 속도를 적당히 빠르게 설정\n반복 지연 시간을 적당히 짧게 설정\n키보드 탐색 켜기\n텍스트 입력 → 편집…에서\nCaps Lock키로 ABC 입력 소스 전환 끄기\n맞춤법 자동 수정 끄기\n자동으로 단어를 대문자로 시작 끄기\n스페이스를 두 번 눌러 마침표 추가 끄기\n스마트 인용 부호 및 대시 사용 끄기\n큰따옴표를 가장 마지막 것으로 변경\n작은따옴표를 가장 마지막 것으로 변경\n\n\n키보드 단축키…에서\n보조 키에서 Caps Lock을 Escape로","트랙패드#트랙패드":"시스템 설정 → 트랙패드에서\n클릭을 가볍게로 바꾸기\n탭하여 클릭하기를 끄기\n\n시스템 설정 → 데스크탑 및 Dock에서 아래로 쭉 내려서 Mission Control에서 핫 코너…를 눌러서\n오른쪽 아래에 빠른 메모를 -로 바꾸기","보안-관련#보안 관련":"시스템 설정 → 화면 잠금에서\n화면 보호기 시작 후 또는 디스플레이가 꺼진 후 암호 요구를 즉시로 바꾸기\n\n시스템 설정 → 네트워크 → 방화벽에서 방화벽 켜기","호스트-이름-바꾸기#호스트 이름 바꾸기":"시스템 설정 → 일반 → 공유에서가장 밑의 호스트 이름 → 편집… 눌러서 적당한 이름으로 변경","파인더-설정#파인더 설정":"Finder에서 커맨드+, 눌러서 설정 열어서\n새로운 Finder 윈도우에서 보기를 홈폴더로 변경 (계정명과 동일한 폴더)\n\nFinder 설정 고급에서\n모든 파일 확장자 보기 켜기\niCloud Drive에서 제거하기 전에 경고 표시 끄기\n폴더 우선 정렬에서 윈도우에서와 데스크탑에서 모두 켜기","꿀팁#꿀팁":"","-대신-백틱-입력하기#₩ 대신 백틱 입력하기":"~/Library/KeyBindings/DefaultkeyBinding.dict 만들고 아래의 내용을 추가한다:\n{\n\"₩\" = (\"insertText:\", \"`\");\n}","세-손가락으로-드래그하기#세 손가락으로 드래그하기":"트랙패드로 드래그하려면 기본적으로 클릭을 해야 하는데 손에 힘들어가서 불편하다. 세 손가락으로 드래그하기를 켜면 그냥 손가락 세 개 올려놓고 슥 하면 드래그 된다.\n시스템 설정 → 손쉬운 사용 → 포인트 제어기 → 트랙패드 옵션…\n드래그에 트랙패드 사용 켜기\n드래그 스타일에 세 손가락으로 드래그하기","shift---space로-한영-전환하기#shift - space로 한영 전환하기":"언제부턴가 한/영 전환에 shift-space가 설정 안 되게 바뀌었다. 아래의 방법으로 강제로 가능하다.\n시스템 설의 키보드 > 단축키 > 이전 입력 소스를 더클클릭하고 아무 키나 입력한다. 수정하지 않으면 plist 에 수정할 값이 보이지 않기 때문이다.\nPlistEdit 를 다운로드해서 설치 한다. Xcode 가 설치되어 있으면 Xcode 로 열 수 있다.\n파인더에서 사용자 폴더 아래의 라이브러리 폴더를 연다. 라이브러리 폴더는 숨김 처리되어 있다. 파인더 메뉴바의 ‘이동 메뉴’를 Option 키를 누른 상태에서 클릭하면 ‘라이브러리’ 폴더가 표시된다.\n라이브러리 풀더 아래 Preferences 안에서 다음 plist 파일을 PlistEdit Pro 로 연다./Users/사용자/Library/Preferences/com.apple.symbolichotkeys.plist\nProperty List 에서 60을 찾는다. 맨 아래에 있을 것이다.\n60/value/parameters/2를 131072로 바꿔준다.\n\n\n이후 재부팅하면 적용된다.","파인더-타이틀바-아이콘-딜레이-조절#파인더 타이틀바 아이콘 딜레이 조절":"macOS Big Sur부터 타이틀바의 아이콘은 기본적으로 숨겨져 있고, 마우스를 올려야 나온다.타이틀바에 아이콘을 계속 표시하려면 아래의 명령어를 Terminal에 입력한다:\ndefaults write com.apple.Preview NSWindowSupportsAutomaticInlineTitle -bool false && killall Finder\n계속 표시하지는 않되, 마우스를 올리면 딜레이 없이 바로 나오게 하고자 하면 아래의 명령어를 입력한다:\ndefaults write NSGlobalDomain \"NSToolbarTitleViewRolloverDelay\" -float \"0\" && killall Finder","유용한-앱#유용한 앱":"","karabiner-elements#Karabiner-Elements":"brew install karabiner-elements\n설정 파일내려받은 후 ~/.config/karabiner/assets/complex_modifications 디렉토리 밑으로 파일을 넣어줍니다.위의 설정은 아래의 동작을 합니다.\n캡슬락을 짧게 누르면 ESC키로 동작합니다\n캡슬락을 누른 채로 H, J, K, L을 누르면 방향키로 동작합니다.\n캡슬락을 누른 채로 U, I, O, P를 누르면 Page Up, Home 등으로 동작합니다.\n캡슬락을 누른 채로 스페이스 바를 누르면 백스페이스로 동작합니다.\n캡슬락을 누른 채로 백스페이스를 누르면 delete로 동작합니다.\n\n캡슬락을 이용하는 설정이므로\n시스템 환경설정 → 키보드 → 보조키...에 들어가 Caps Lock키를 작업 없음으로 설정해줍니다.","hammerspoon#Hammerspoon":"brew install hammerspoon\n기본 설정 파일 위치가 ~/.hammerspoon인데, XDG_CONFIG 디렉토리를 쓰고 싶다면 아래의 명령어로 ~/.config/hammerspoon으로 바꾸면 된다.\ndefaults write org.hammerspoon.Hammerspoon MJConfigFile \"~/.config/hammerspoon/init.lua\"\n바꾸고 아래의 설정파일을 심볼릭 링크.dotfiles/hammerspoon"}},"/notes/mathematical-induction":{"title":"수학적 귀납법","data":{"":"","수학적-귀납법은-축소-논리이다#수학적 귀납법은 축소 논리이다":"일때를 이용해서 로 확장하지 말고, 를 이용해서 를 증명하라.\n김일희 박사, 수학적 귀납법 99.99% \"엉터리\"로 배웠습니다..\n김일희 박사, 어디서도 보기 힘든 절묘한 수학적 귀납법의 활용 (귀납가설을 다섯번 활용?).","트리로-증명#트리로 증명":"명제: 트리의의 점 개수가 이면 선 개수는 이다.\n트리가 면 단말이 존재한다.\n트리에서 단말을 없애도 여전히 트리이다.\n\n위를 이용하면:\n명제가 참이라고 가정함\n일 때, 선의 개수는 로 참.\n인 트리가 있다면, 선의 개수는 여야 함.\n위의 트리에서 단말을 없앤 트리는 이고, 가정에 의해 선의 개수는 임.\n단말을 없애면 선도 없어지니 가 맞음.","n까지의-합으로-증명#n까지의 합으로 증명":"명제:\n명제가 참이라고 가정함.\n일 때, 이므로 참.\n이라고 하면, 이어야 함.\n가설에 의해\n우변의 식을 정리하면 이므로 모순이 없으니 명제가 참임."}},"/notes/minimum-spanning-tree":{"title":"최소 신장 트리","data":{"":"MST; minimum spanning tree그래프 가 있을 때\n트리란, 사이클이 없는 연결 그래프이다.\n의 신장 트리란, 의 부분 그래프로서 의 모든 정점을 포함하는 트리이다.\n의 최소 신장 트리란, 의 신장 트리 중 가중치의 합이 최소가 되도록 하는 트리이다.\n\n최소 신장 트리를 구하는 알고리즘으로는 대표적으로 kruskal's algorithm과 prim's algorithm이 있다. 둘 다 한 번 한 결정을 번복하지 않는 욕심쟁이(greedy) 알고리즘이다.","kruskals-algorithm#Kruskal's Algorithm":"희소한 그래프에 유리하다.\n비용이 가장 적은 간선을 찾는다.\n해당 간선을 추가해도 사이클이 생기지 않으면 이를 추가한다.\n모든 정점이 연결될 때까지 이를 반복한다.","증명#증명":"두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지. 먼저 신장 트리가 되는지 확인하자. 신장 트리가 되려면 다음의 세 조건을 만족해야한다.\n사이클이 없어야 하고\n연결 그래프여야 하고\n모든 정점을 포함해야한다.\n\n귀류법으로 확인해보자. 가중치가 있는 연결 그래프 에서 Kruskal 알고리즘으로 최소 신장 트리 를 구했다고 하자.에는 사이클이 없다. 간선을 추가할 때 사이클이 생기는지 확인하고 추가하니까 당연하다.는 연결 그래프이다. 가 이미 연결 그래프이기 때문에 가 연결 그래프가 아니려면 의 특정 간선을 추가하지 않았어야 한다. 그 간선을 추가하지 않으려면 간선을 추가함으로써 사이클이 생긴다는 건데, 사이클이 있다는건 이미 연결된 상태라는 소리니까 말도 안 되는 소리다.는 의 모든 정점을 포함한다. 가 이미 연결 그래프이기 때문에 에 사이클이 없고 끝까지 돈다면 모든 정점을 포함할 수 밖에 없다.따라서 kruskal 알고리즘으로 만든 는 신장 트리이긴 하다. 그렇다면 가중치의 합이 최소가 되긴 하는가?최소 신장 트리가 존재하긴 할테다. 최소 신장 트리의 간선의 집합을 라고 라고, kruskal 알고리즘으로 만든 트리의 간선의 집합을 라고 하자. 이 둘이 다르다고 가정하고 모순을 찾아보자. 귀류법이다.처음에는 에 아무것도 없을 테니 이다. 그런데 어느 순간에 에는 없는 간선 가 추가되어 가 된다.에는 왜 가 없을까? 와 가 간접적으로 연결되어 있기 때문에 추가하는 순간 사이클이 생기기 때문일 것이다.그런데 말입니다. 와  둘 다 신장 트리의 간선의 집합이기 때문에 그 크기가 같다. 즉 는 와 를 연결하기 위해 다른 간선을 썼다는 뜻이다. 허나 kruskal 알고리즘은 간선을 비용이 낮은 순으로 연결하기 때문에 가  대신 고른 간선보다 비용이 작거나 같다. 가 최소 신장 트리라고 했으니 더 작을 수는 없고 같을 것이다. 따라서 의 비용과  비용이 같으므로 도 최소 신장 트리이다.","구현#구현":"구현의 핵심은 두 가지이다. 첫째, 간선들을 어떻게 정렬할 것인가? 둘째, 사이클이 있는지는 어떻게 확인할 것인가?간선 정렬은 그냥 정렬해도 되지만 최소 힙을 사용하여 해결할 수도 있다.사이클이 있는지는 DFS나 BFS를 이용하여 확인할 수도 있지만 그보다 UnionFind 자료구조를 이용하는 편이 효율적이다.위키피디아에 예쁜 의사코드가 있다.\nKRUSKAL(G):\nA = ∅\nforeach v ∈ G.V:\nMAKE-SET(v)\nforeach (u, v) in G.E ordered by weight(u, v), increasing:\nif FIND-SET(u) ≠ FIND-SET(v):\nA = A ∪ {(u, v)}\nUNION(u, v)\nreturn A","시간-복잡도#시간 복잡도":"","prims-algorithm#Prim's Algorithm":"밀집 그래프에 유리\n정점 v를 고른다. (이거다 싶은거 아무거나 고른다)\n정점 v의 간선 중 비용이 가장 적은 간선을 추가한다. 이젠 정점이 두 개다.\n두 정점의 간선 중 (서로를 연결하는거 말고) 비용이 가장 적은 간선을 추가한다.\n...\nPROFIT!!","증명-1#증명":"마찬가지로 두 가지를 증명해야한다. 이렇게 만든것이 신장 트리이긴 한지, 가중치의 합이 최소가 되는지.먼저 신장 트리가 되는지는 Kruskal 알고리즘과 같은 이유이다.그렇다면 가중치의 합이 최소가 되는가? 아까와 같은 방법으로 해보자. 그래프 에 대해 어딘가 어떤 형태로든 존재하는 최소 신장 트리의 간선의 집합을 라고 하고, Prim 알고리즘으로 만들어낸 간선의 리스트를 라고 하자. 처음에는 인데 에 가 추가되는 순간 가 되었다고 하자. 왜 에는 간선 가 없을까? 는 신장 트리, 즉 연결 그래프이기 때문에 이미 정점 와 는 연결되어 있다. 따라서 간선 를 추가하면 사이클이 생기게 된다.둘 다 신장 트리이므로 간선의 수는 같다.  대신 다른 간선이 그 역할을 하고 있다는 뜻이다. 그런데 Prim 알고리즘은 가중치가 작은 순으로 간선을 추가하므로 간선 는 그 다른 간선보다 비용이 같거나 더 작다. 가 최소 신장 트리라고 했으므로 더 작을 수는 없고 같을 것이다. 는 최소 신장 트리이다.","시간-복잡도-1#시간 복잡도":"","참고자료#참고자료":"네이버캐스트/최소 비용 신장 트리 알고리즘: 가장 적은 비용으로 연결하려면?"}},"/notes/miryoku":{"title":"miryoku","data":{"":"manna-harbour/miryoku\nnyeong/zmk-config\n\n36개의 키만으로 구현 가능한 키배열.\n손가락의 움직임을 최소로 한 것이 특징이다.home-row mod와 엄지키를 이용한 레이아웃을 적극 활용하여 움직임을 최소로 하였다.My New Gears에 miryoku flip inverted T 배열을 변형하여 쿼티 기반으로\n사용중 (2022-09-13)","home-row-mods#home-row mods":"ctrl, alt 등 모드 키를 손이 기본 위치하는 2열(A, S, D, F, J, K, L, ;)에 두자는 생각이다.짧게 누를 경우 원래 키(A, S 등...)가 입력되고, 길게 누를 경우 설정한 모드키가 동작한다.길게 누르는 시간을 0.15초 정도로 설정해주면 굳이 의식하지 않아도 누르고 조합할 키를 누르면 모드키로 동작한다.\n그냥 누르면 아래의 값들이 입력된다:\n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  |\n\n길게 누르면 아래의 모드키가 눌린 것처럼 동작한다:\n|  _  | CTL | OPT | CMD | SHF |  _  |        |  _  | SHF | CMD | OPT | CTL |  _  |\n예를 들어, 복사를 위해 <cmd>-c를 누르려면 k를 꾹 누른 채로 c를 누르면 된다.\nkc를 입력하려면 평범하게 k를 누른 후 c를 누르면 된다.home-row mods로 할당한 키는 원래키를 길게 눌러도 연속입력이 안 되는게 단점이다.\ng와 h에 별도의 레이어를 할당하여 해결하였다. k를 꾹 눌러 연속으로\n입력하고 싶다면 g를 누른 채로 k를 꾹 누르면 된다.","레이아웃#레이아웃":"home-row mods와 마찬가지로, 아래의 키는 짧게 누르면 원래의 키로 입력되고,\n길게 누르면 모드가 바뀐다.\nESC -> 펑션 레이아웃\nSPC -> 숫자 레이아웃\nTAB -> 기호 레이아웃\nENT -> 마우스 레이아웃\nBSP -> 방향키 레이아웃\nDEL -> 시스템 레이아웃\n\n\n그냥 누르면 아래의 키가 한 번 눌린 것으로 간주된다:\n| ESC  | SPC  | TAB  |        |  ENT   |  BSP   |  DEL   |\n\n길게 누르면 누르는 동안 아래의 레이아웃으로 키 배열이 바뀐다:\n| 펑션 | 숫자 | 기호 |        | 마우스 | 방향키 | 시스템 |","일반-레이아웃#일반 레이아웃":"쿼티를 쓰고 있다. 콜맥을 쓰고 싶은 욕심은 있지만, helix와 vim 단축키 적응하는게\n쉽지 않을 것 같다.home row mods가 적용되어 있어서 A, S, D, F, J, K, L, ;은 위에 기술된 대로 MODS키로 동작한다.\n|  _  |  Q  |  W  |  E  |  R  |  T  |        |  Y  |  U  |  I  |  O  |  P  |  _  |\n|  _  |  A  |  S  |  D  |  F  |  G  |        |  H  |  J  |  K  |  L  |  ;  |  _  |\n|  _  |  Z  |  X  |  C  |  V  |  B  |        |  N  |  M  |  ,  |  .  |  /  |  _  |\n| ESC | SPC | TAB |        | ENT | BSP | DEL |","펑션-레이아웃#펑션 레이아웃":"|  _  |     |     |     |     |     |        |     | F7  | F8  | F9  | F12 |  _  |\n|  _  | CTL | OPT | CMD | SHF |     |        |  =  | F4  | F5  | F6  | F11 |  _  |\n|  _  |     |     |     |     |     |        |  +  | F1  | F2  | F3  | F10 |  _  |\n| *** | SPC | TAB |        | ENT | BSP | DEL |","숫자-레이아웃#숫자 레이아웃":"우측 키보드를 키패드처럼 쓸 수 있다. 따옴표(\", ', `)는 모두 오른쪽 새끼손가락으로 입력할 수 있다.\n|  _  |     |     |     |     |     |        |     |  7  |  8  |  9  |  \"  |  _  |\n|  _  | CTL | OPT | CMD | SHF |     |        |  =  |  4  |  5  |  6  |  '  |  _  |\n|  _  |     |     |     |     |     |        |  +  |  1  |  2  |  3  |  `  |  _  |\n|     | *** |     |        |  -  |  0  |  .  |","기호-레이아웃#기호 레이아웃":"괄호쌍을 입력할 경우 엄지로 TAB을 누른 채로 오른손 검지와 새끼를 타닥 누르면\n되니 편하다.부등호 기호(<>)를 괄호처럼 쓸 일이 종종 있는데, 여기에 욱여 넣을 수 없어서 아쉽다.\n|  _  |     |     |     |     |     |        |  (  |  &  |  *  |  ~  |  )  |  _  |\n|  _  | CTL | OPT | CMD | SHF |     |        |  {  |  $  |  %  |  ^  |  }  |  _  |\n|  _  |     |     |     |     |     |        |  [  |  !  |  @  |  #  |  ]  |  _  |\n|     |     | *** |        |  _  |  |  |  \\  |","마우스-레이아웃#마우스 레이아웃":"ZMK 펌웨어에서는 아직 마우스 키를 지원하지 않기 때문에 이 부분은 비워두었다.","네비게이션-레이아웃#네비게이션 레이아웃":"방향키, HOME, END, PG UP, PG DN 등 네비게이션과 관련된 버튼을 모아둔 레이아웃.\n|  _  |     |HOME |  ↑  | END |PG UP|        |     |     |     |     |     |  _  |\n|  _  |     |  ←  |  ↓  |  →  |PG DN|        |     | SHF | CMD | OPT | CTL |  _  |\n|  _  |     |     |     |     |     |        |     |     |     |     |     |  _  |\n| ESC | SPC | TAB |        |     | *** |     |","시스템-레이아웃#시스템 레이아웃":"블루투스, 화면 밝기, 미디어 재생, 볼륨 조절 등 버튼을 모아놓은 레이아웃.왼손 새끼로 밝기를 다루고, 검지로 볼륨을 조절한다.미디어 조절 버튼은 넣을 수 있길래 넣어봤는데 막상 써 본 적은 없다.\n|  _  |BR UP|REWND|PAUSE|FA FO|VL UP|        |     |     |     |     |     |  _  |\n|  _  |BR DN|PREV |PLAY |NEXT |VL DN|        |     | SHF | CMD | OPT | CTL |  _  |\n|  _  |BR AT|BTCLR|BTOFF|BT ON|MUTE |        |     |     |     |     |     |  _  |\n| BT0 | BT1 | BT2 |        |     |     | *** |","개선-여지#개선 여지":"home row mod로 할당된 키들은 꾹 눌러서 입력이 불가능하다\n양손 검지로 누르는 안쪽열 키(g, k)를 누르고 있으면 연속 입력이 가능\n\n\n한 손으로 할 수 있는 것들이 적다.\n매크로 등 편의기능\n여는 괄호((, {, [) 입력시 닫는 괄호와 왼쪽 방향키를 입력하여 바로 괄호 속에서 입력 가능하도록"}},"/notes/monad-functor-applicative":{"title":"모나드와 펑터와 어플리케이티브","data":{"":"요약: 셋 다 합성을 쉽게 하기 위해서이다.\nclass Monad m where\n(>>=)  :: m a -> (a -> m b) -> m b\nreturn :: a -> m a\n\nclass Functor f where\nfmap :: (a -> b) -> f a -> f b\n(<$) :: a -> f b -> f a\n\nclass (Functor f) => Applicative f where\npure  :: a -> f a\n(<*>) :: f (a -> b) -> f a -> f b","모나드#모나드":"이진트리 하나를 생각해보자. 어떤 노드는 그 밑에 왼쪽노드와 오른쪽노드가\n있을 수도 있고, 없을 수도 있다.\n@type Node :: %{ left: Node | nil, right: Node | nil }\n\n@spec left(Node) :: Node | nil\ndef left(node), do: node.left\n\n@spec right(Node) :: Node | nil\ndef right(node), do: node.right\n어떤 노드 n의 왼쪽 자식이 노드라면 그 노드도 자식이 있을 수 있다.\nn의 왼쪽 자식의 오른쪽 자식을 구하려면 어떻게 해야할까?그냥 n |> left() |> right()하면 직관적이어서 좋겠지만, left()에서 nil이\n반환되는 경우를 생각해야 한다.\nnode |> left() |> right()\n** (KeyError) key :left not found in: nil.\n엘릭서스럽게 이 상황을 타파하는 간단한 방법은 저 두 함수가 nil을 받도록\n고치는 것이다.\n@spec left(Node) :: Node | nil\ndef left(nil), do: nil\ndef left(node), do: node.left\n\n@spec right(Node) :: Node | nil\ndef right(nil), do: nil\ndef right(node), do: node.right\n함수를 고치지 않고 해결할 수 있을까? 패턴 매칭이나 case로 해결할 수 있겠지만,\n구조가 깊어질 수록 표현하기 어렵다.\n# 패턴매칭\ndef left_right_node(%{left: %{right: lrnode}}), do: lrnode\ndef left_right_node(_), do: nil\n\n# case\ndef left_right_node(node) do\ncase node.left do\n%{left: left} ->\nright(left)\n\n_ ->\nnil\nend\nend\nleft/1과 right/1을 파이핑하면 직관적으로 깊은 구조도 표현할 수 있다.\n함수를 고치지 않고 파이핑 할 수 있을까? nil인 경우를 처리해주는 함수를\n만들어 감싸주자.\ndef bind(nil, _), do: nil\ndef bind(val, f), do: f.(val)\n\nnode |> bind(&left/1) |> bind(&right/1) |> bind(&right/1)\napply/2 함수 덕분에 case를 중첩하거나 구조를 직접 나열하지 않고\n파이핑으로 직관적으로 알아볼 수 있게 되었다.","일반화하기#일반화하기":"무엇이 문제였고, 어떻게 해결했는지 일반화해보자.left/1, right/1 함수는 Node를 취하고 Node나 nil을 반환하는 함수이다.\nnil이 반환되는 경우 때문에 다시 left/1, right/1 함수에 넣을 수 없었다.\n@spec left(Node) :: Node | nil\n@spec right(Node) :: Node | nil\n\"Node | nil\"은 유무를 나타내기 위해 Node를 확장한 타입이다.\n이외에도 다양한 맥락에 의해 Node를 확장할 수 있다.\n# 유무를 나타내기 위해: Maybe monad, Option monad\n@spec left(Node) :: Node | nil\n\n# 실패까지 나타내기 위해: Result monad\n@spec get_left_from_network(Node) :: {:ok, Node} | {:error, reason}\n\n# 여러개가 있음을 나타내기 위해: List Monad\n@spec children(Node) :: [Node]\n이런 함수로 얻은 값을 Node에 취하려면 특수한 경우를 처리하고 순수한 Node를\n얻어야 한다. 크게 네 가지 경우를 생각할 수 있다:\n함수가 직접 특수한 경우도 받도록 한다.\n내가 직접 처리해서 함수에 던져준다.\n처리해주는 함수를 쓴 후 그 결과를 함수에 던져준다.\nwith을 쓴다.\n\n어떤 타입을 확장한 타입은 그 가짓수가 많다. 특별히 유용한 경우가 아니라면\n매번 함수를 만들 때 이런 경우도 모두 처리하는 것은 어려울 것이다.따라서 보통은 내가 직접 처리해서 함수에 던져주는 것이 나을 것이다.\n엘릭서의 경우 함수 인자나 case를 통한 패턴매칭으로 손쉽게 처리할 수 있다.\n{:ok, content} = File.read(filename)\ndo_something(content)\n\n# 에러도 처리하기\ncase File.read(filename) do\n{:ok, content} ->\ndo_something(content)\n\n{:error, reason} ->\nhandle_error(reason)\nend\n그러나 이런 제어구조를 빈번히 사용하면 가독성이 떨어진다. Node의 자식의\n자식을 찾는 예시에서 처럼 제어구조가 중첩되면 읽기 어렵고 고치기 어렵다.\ncase Accounts.get_user(id) do\n{:ok, user} ->\ncase Accounts.update_user(user, name: \"fantastic\") do\n{:ok, updated_user} ->\nIO.puts(\"User updated!\")\n{:error, reason} ->\nIO.puts(\"User can not be updated with #{reason}\")\nend\n{:error, _} ->\nhandle_not_found()\nend\n\ndef nil ~>> _, do: nil\ndef val ~>> f, do: f.(val)\n\nnode ~>> left() ~>> right() ~>> right()"}},"/notes/music":{"title":"🎼 음악","data":{"":"","다이어토닉-코드#다이어토닉 코드":"diatonic chord. 어떤 음계에서 그 음계의 구성음으로만 이루어진 코드를 의미한다.\n\n\b다이어토닉 코드를 분석할 때에 로마숫자로 표기하면 특정 키에 얽매이지 않고 코드 진행을 볼 수 있어서 편리하다.","3화음의-경우#3화음의 경우":"I\tii\tiii\tIV\tV\tvi\tviio\tC\tDm\tEm\tF\tG\tAm\tBm(♭5)\nviio는 감3화음(diminished triad)이며 7화음과의 구분을 위해 VIIm(♭5)로 표기하기도 한다.","7화음의-경우#7화음의 경우":"I△7\tii7\tiii7\tIV△7\tV7\tvi7\tviio7\tC△7\tDm7\tEm7\tF△7\tG7\tAm7\tGo7\n마찬가지로 viio7는 감7화음인데, 표기에 마이너가 없어도 3음은 단3도이다.","코드의-성질#코드의 성질":"","토닉#토닉":"우리말로 으뜸화음이라고 한다. 안정감을 주어 특히 곡의 끝에 많이 쓰인다.메이저에서는 I△7이 토닉이며, iii7과 vi7이 대리코드로 쓰일 수 있다.","도미넌트#도미넌트":"우리말로 딸림화음이라고 한다. 불안정하며 토닉으로, 혹은 완전5도 아래로 진행하려는 성질이 있다.메이저에서는 V7이 도미넌트이며, viio7이 대리코드로 쓰일 수 있다","서브-도미넌트#서브 도미넌트":"우리말로 버금딸림화음이라고 한다. 도미넌트보다는 덜하지만 토닉으로 진행하려는 성질이 있다.메이저에서는 IV△7이 서브 도미넌트이며, ii7이 대리코드로 쓰일 수 있다.","텐션#텐션":"코드 위에 더 쌓은 음.C△7(9, 13)표기할 때에는 위처럼 9도, 11도, 13도로 표기한다.\n코드: R부터 시작하여 3도씩 쌓은 3~4화음 (1 - 3 - 5 - 7)\n텐션: 화음 위로 3도씩 쌓은 추가음 (9 - 11 - 13)\n\n실제로 옥타브 위의 음을 연주할 필요는 없기에, 2, 4, 6음으로 생각해도 좋다.메이저 다이아토닉 코드별로 사용 가능한 텐션은 아래와 같다.\n코드\tI7(9, 13)\tii7(9, 11)\tiii7(11)\tIV7(9, #11, 13)\tV7(9, 13)\tvi7(9, 11)\tvii7(b5, 11, b13)\t텐션\t9, 13\t9, 11\t11\t9, #11, 13\t9, 13\t9, 11\t11, b13\t어보이드 노트\t11\t13\tb9, b13\t\t11\tb13\tb9","7화음#7화음":"3화음에 7음을 붙여 만든 화음. R + 3 + 5 + 7로 구성된다.\n표기\t3음\t5음\t7음\t이름\tR△7\t3\t5\t7\t메이저 세븐스\tR7\t3\t5\tb7\t도미넌트 세븐스\tRm7\tb3\t5\tb7\t마이너 세븐스\tRmM7\tb3\t5\t7\t마이너-메이저 세븐스\tRo7\tb3\tb5\t6\t디미니시 세븐스\tRø7\tb3\tb5\tb7\t하프 디미니시 세븐스. Rm7b5로도 표기하곤한다.\tR+7\t3\t#5\tb7\t어거먼트 세븐스.","여러가지-코드-진행#여러가지 코드 진행":"ii7 - V7 — 투 파이브 코드 진행\nii7 - V7 - IV7 — 투 파이브 원\n\n\nIV△7 - III7 - vi7 - v7 - I7 — Just The Two Of Us 진행\nIV△7 III7 vi7 I7\nBill Withers - Just The Two Of Us\n椎名林檎 - 丸の内ディスチック\nyama - 春を告げる\nれをる - 第六感\n\n\nIV V iii vi — 왕도진행\nI V vi iii IV I IV V7 — 카논 코드\n요한 파헬벨 - 카논 라 장조\n\n\nI V vi IV — Pop-punk chord progression\nIV I V vi\nV vi IV I\nvi IV I V\nIV I V vi\n\n\nvi IV V I — 小室(코무로)진행\n작곡가 코무로 테츠야가 많이 썼다고 하여 붙은 이름\nKing Gnu - 百日\n\n\nIV V I\nI V vi IV\ni bIII bVII IV\nii V vi iii\nvi IV I V","참고#참고":"【今知るべき】ヒット曲に使われるコード進行 TOP5【ギターで弾こう】 - YouTube\nJ-POP を席巻！定番コード進行 5 選をまとめて紹介～コード特徴、使用楽曲など～ - YouTube"}},"/notes/my-new-gears":{"title":"My New Gears","data":{"":"📚 전자책 단말기 — 오닉스 북스 리프2\n📱 휴대폰 — 아이폰 12 Pro\n⌨️ 개인용 서버 — UiBox\n💻 노트북 — 맥북에어 (M1, 2020)\n⌨️ 키보드 — Corne Keyboard\n📡 라우터 — AX2004M -- openwrt 깔아서 쓰는 중","corne-keyboard#Corne Keyboard":"3x6 사이즈 + 3 엄지 세로 스테거 스플릿 키보드\n\nfootsan/crkbd\n키캡: 까먹었다\n스위치: 게이트론 저소음 갈축 → 홀리 판다\nMCU: ELITE-C → nice!nano\n케이스: 3D printed\n펌웨어: QMK → ZMK\n보드: crkbd choco v3 → crkbd cherry v2\n배열: miryoku flip inverted T 변형","로그#로그":"2023-03-06 홀리 판다 스위치 풀윤활 완료 (크라이톡스 GPL105)\n스템, 스프링 모두 동일한 윤활제로 윤활\n윤활 후 기존보다 걸림이 덜 느껴지고 힘이 덜 필요.","ax2004m#AX2004M":"openwrt를 활용해서 공유기를 보다 다목적으로 써보자.\nVPN 서버 (wireguard)\n리버스 프록시","사양#사양":"무선지원: AX1800\nCPU: 미디어텍 MT7621, 880MHz 듀얼코어\nRAM: 256MB\nFLASH: 128MB","참고#참고":"박윤지, ipTIME AX2004M용 OpenWrt.","오닉스-북스-리프2#오닉스 북스 리프2":"","장점#장점":"책 둘 곳 걱정 할 필요가 없다.\n가볍다 — 185g인데 쓰고 있는 휴대폰(아이폰 12 프로, 187g)보다 넓고 가벼워 훨씬 편하다.\n눈이 확실히 편하다.\n크기가 작아 들고다니기 편하다.\n물리키가 있어 활용이 좋다.","단점#단점":"e-ink 패널에 최적화되지 못한 앱이 많다.\n특히 색상이 들어간 앱 중에 흑백으로 표시되며 사용이 어려운 앱이 간혹 있다.\n\n\n종이책보다는 몰입이 덜하다.\n명암비가 종이책보다 좋지 못하다.\n작은 크기. 왠만한 종이책보다는 화면 크기가 작아 불편하다.\n\n\n프로세서가 느린 게 체감된다.","쓰는-앱#쓰는 앱":"리디\n전자책용 앱이 없어서 일부 애니메이션을 끌 수 없다.\n페이지 넘김은 끌 수 있다.\n아무 책 열고 → 뷰어 설정 → 페이지 넘김 효과를 효과 없음으로 설정\n\n\n\n\nKindle\nVPN 등 설정 없이도 일본 원서를 볼 수 있다.\n물리키가 먹히지 않으며, 페이지 전환 애니메이션을 끌 수 없다.\n\n\nbitwarden — 비밀번호 조회용"}},"/notes/network":{"title":"네트워크","data":{"":"","라우터-공유기-스위치의-차이#라우터, 공유기, 스위치의 차이":"흔히 가정에서 사용하는 공유기는 라우터, 스위치의 역할을 겸용할 수 있으며 무선 AP로도\n활용할 수 있는 만능 기기이다.","스위치#스위치":"L2; 데이터 링크 계층에서 작동한다.\nL2 스위치라고도 부른다.\n로컬 네트워크를 구성하며, 로컬 네트워크의 입구 역할을 맡는다.\n이더넷 프레임을 주고 받는다.\n수신할 목적지를 MAC 주소로 특정한다.","라우터#라우터":"L3; 네트워크 계층에서 작동한다.\nL3 스위치라고도 부른다.\n네트워크와 네트워크를 잇는다.\nIP 패킷을 주고 받는다.\n수신할 목적지를 IP 주소로 특정한다.","l4-스위치#L4 스위치":"로드밸런싱.","l7-스위치#L7 스위치":"웹 방화벽, 보안 스위치 등.","참고#참고":"Keith Shaw, 네트워크 스위치와 허브, 라우터는 어떻게 다른 걸까."}},"/notes/nginx-reverse-proxy":{"title":"Nginx로 리버스 프록시","data":{"":"리버스 프록시란 다른 서버의 앞단에 놓이는 프록시 서버로, 클라이언트의 요청을\n먼저 받아 여러 처리를 한 후에 필요한 서버에게 보내주는 역할을 한다.\nsequenceDiagram\nparticipant Client\nparticipant ReverseProxy\nparticipant Server\nClient->>ReverseProxy: HTTP Request\nReverseProxy->>Server: HTTP Request\nServer-->>ReverseProxy: HTTP Response\nReverseProxy-->>Client: HTTP Response\n홈 서버에서 운영하는 서비스를 웹으로 노출시키려고 한다.\n이때 리버스 프록시를 운영하면 아래와 같은 이점이 있다.\n보안. SSL 같은 암호화를 맡아서 처리를 할 수 있다.\n또한 내부 주소를 숨기고 도메인 주소만 노출할 수 있다.\n확장. 서브 도메인을 이용하여 여러 서비스를 하나의 도메인으로 노출할 수 있다.\n성능. 캐싱, 압축을 적용하여 성능에서 이득을 볼 수 있긴 한데... 얼마나\n이득일지는 잘 모르겠다.","외부에서-홈-서버에-접속하기#외부에서 홈 서버에 접속하기":"외부에서 내 홈서버에 접속하여 서비스를 이용하는 시나리오를 그려보자.먼저 홈 네트워크의 구성은 아래와 같다:\n┌─Proxmox VE──┐\n┌───┐  ┌──────┐ │   ┌─────┐   │\n│WAN├─►│router├─┼──►│nginx│   │\n└───┘  └──────┘ │   └──┬──┘   │\n│      ▼      │\n│  NextCloud  │\n└─────────────┘\n\n웹 브라우저에 도메인을 입력한다\n이 도메인을 DNS 서버에 질의하여 IP 주소를 확인한다.\n확인한 IP 주소로 HTTPS 요청을 보낸다.\n라우터는 받은 모든 HTTPS 요청을 Proxmox VE의 nginx에 넘긴다.\nnginx는 받은 요청을 검사하여 처리 후 적절한 서비스로 넘겨준다.\n\n따라서\n도메인을 DNS에 등록해야하고\n라우터에서 nginx로 포트 포워딩 해줘야하고\nnginx에서는 서브도메인을 확인하여 원하는 서비스로 넘겨줘야 한다.\n\n먼저 nginx부터 설정하자.","proxmox-ve에-nginx-올리기#Proxmox VE에 nginx 올리기":"리버스 프록시 역할을 수행할 수 있는 소프트웨어는 아파치 HTTP 서버, HAProxy 등\n다양하다.그 중 nginx는 설정이 간편하고 기능이 많으며 성능이 좋아 사용하기 편리하다.Proxmox VE에 무언가를 올릴 때 LXC 혹은 VM으로 올릴 수 있는데, 간편하게 LXC로\n설정하였다. 사양은 최소로 잡아놓고, 필요하면 올리는 것으로.\n템플릿: fedora37-default_20221119_arm\n메모리: 512MB\n코어: 1\n디스크: 8GB\n네트워크: DHCP\n\n페도라에서 nginx는 dnf로 간편하게 설치할 수 있다. 서비스 관리는 systemd로\n한다.\n$ dnf install nginx\n$ systemctl enable nginx\n$ systemctl start nginx\nnginx 가동 후 ip addr로 내부 주소를 확인하고 접속하면 환영 페이지를 볼 수\n있다.","openwrt에서-포트포워딩-하기#OpenWRT에서 포트포워딩 하기":"이제 외부에서 보낸 HTTP/HTTPS 요청을 nginx가 받을 수 있도록 라우터를\n설정해주어야 한다. 구체적으로는 라우터가 외부에서 받는 요청을 홈 네트워크의\n특정 포인트로 넘겨주도록 포트 포워딩 해주어야 한다.OpenWrt를 쓰는 경우, 온전한 리눅스이므로 nginx를 라우터에 직접 설치하여 쓸 수도\n있다. 추후에 설정을 자주 바꿀 필요가 없어지면 nginx로 옮기는 것도 좋겠다.\niptime 공유기에 NGINX를 돌려봅시다.\n링크시스 공유기에 NGINX 올려서 Reverse Proxy로 쓰기\n\n라우터로 OpenWrt를 쓰고 있는데 OpenWrt는 Network → Port Fowarding에서\n포트 포워딩 설정을 할 수 있다.\n\n\n이름: 편한 대로 설정\n프로토콜: TCP. HTTP3를 고려한다면 UDP도 해야한다.\n소스: 외부에서 입력을 받을 것이기에 wan 선택\n외부 포트: HTTP 포트인 80, HTTPS 포트인 443을 열어준다.\n목적지: 내부 네트워크를 고르면 된다.\n내부IP: nginx를 설치한 서버의 IP\n내부 포트: 굳이 바꿀 필요 없이 80, 443을 쓰자\n\n포트를 한 번에 하나만 입력할 수 있으므로 두 개를 만들어야 한다.이렇게 바꾼 후 외부 IP를 확인하여 접속하면 내부에서 접속했을 때와 동일한\n화면을 볼 수 있다.","cloudflare에-dns-등록#cloudflare에 DNS 등록":"이제 도메인 주소와 IP를 연결하면 일반적인 웹 주소로 내 홈 서비스에 접속할 수 있다.\nDNS 등록은 DNS 제공 서비스를 통해 해야하는데, 본래 쓰던 cloudflare를\n이용하였다.\n타입: A\n이름: www, @, *\n주소: 내 IP주소\nproxy: DNS only\nTTL: auto\n\n\n\nwww와 루트(@), 와일드카드(*) 세 개를 등록하자. 완료하면 이제 nyeong.me로\n접속하면 IP주소로 접속했을 때와 동일한 화면을 볼 수 있다.","레코드-종류#레코드 종류":"A 레코드\nCNAME 레코드","lets-encrypt로-인증서-받기#Let's Encrypt로 인증서 받기":"지금은 http 프로토콜을 이용한 접속만 가능하다. https를 쓰려면 인증기관(CA)에서\nSSL 인증서를 발급받아야한다. 여러 CA가 있는데 그중\nLet's Encrypt는 무료로 인증서를 발급해준다.Let's Encrypt에 사이트를 인증하려면 ACME 프로토콜을 이용해야한다. 이를 지원하는\n여러 클라이언트가 있는데Cloudflare API 토큰을\n발급받는다.\n권한: DNS에 대한 편집 권한\n리소스: DNS에 등록한 도메인 주소\n\n완료하면 API 토큰을 발급해준다. 이 토큰을 이용하여 SSL 인증서를 발급받을 것이다.\n$ dnf install git openssl\n$ git clone https://github.com/acmesh-official/acme.sh.git\n$ cd ./acme.sh\n$ mkdir /etc/nginx/ssl/\n$ ./acme.sh --install --force -m me@annyeong.me\n$ export CF_Token=\"위에서 발급받은 토큰\"\n$ export CF_Email=\"cloudflare 이메일\"\n$ acme.sh --issue \\\n--dns dns_cf \\\n--server letsencrypt \\\n-d nyeong.me -d '*.nyeong.me' \\\n--keylength ec-256 \\\n--key-file /etc/nginx/ssl/privkey.pem \\\n--fullchain-file /etc/nginx/ssl/fullchain.pem \\\n--cert-file /etc/nginx/ssl/chain.pem \\\n--reloadcmd \"systemctl reload nginx.service\"\n\nacme.sh는 install 할 때 cron이 존재하는지 검사한다. 페도라는 systemd를\n이용하므로 cron이 없으므로 --force 명령어로 진행시킨다.\nacme.sh --cron\n\n이후 acme.sh list 확인하면 잘 발급되었음을 볼 수 있다.\n$ acme.sh list\nMain_Domain  KeyLength  SAN_Domains  CA               Created               Renew\nnyeong.me    \"ec-256\"   *.nyeong.me  LetsEncrypt.org  2023-03-20T05:03:49Z  2023-05-18T05:03:49Z\nSSL 설정은 모질라의\nSSL Configuration Generator를\n이용하였다.\nserver {\nlisten       443 ssl http2;\nlisten       [::]:443 ssl http2;\nserver_name  _;\nroot         /usr/share/nginx/html;\n\nssl_certificate \"/etc/nginx/ssl/fullchain.pem\";\nssl_certificate_key \"/etc/nginx/ssl/privkey.pem\";\nssl_trusted_certificate /etc/nginx/ssl/chain.pem;\nssl_session_cache shared:MozSSL:10m;\nssl_session_timeout  1d;\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\n# OCSP stapling\nssl_stapling on;\nssl_stapling_verify on;\n\n# verify chain of trust of OCSP response using Root CA and Intermediate certs\n\n# replace with the IP address of your resolver\nresolver 127.0.0.1;\n}","리버스-프록시#리버스 프록시":"ㅈ","nextcloud#nextcloud":"occ 실행\nsu www-data -s /usr/bin/php /var/www/nextcloud/occ"}},"/notes/nth-week-today":{"title":"오늘은 몇 주차","data":{"":"오늘은 몇 주차","주란-무엇인가#'주'란 무엇인가?":"주란 과연 무엇일까요? 주에 대해 자세히 생각해보면 이런 저런 의문이 듭니다.\n한 주의 시작은 월요일일까, 일요일일까?\n365.25일을 7로 나누면 약 52.178이다. 즉 1년은 평균 52.178주이다?\n올해(2022년)의 첫날은 토요일이다. 그렇다면 올해의 첫주는 1월 1일을 포함할까?\n\n세상에는 혼돈을 줄이기 위하여 별에 별 것들에 대해 표준이 있습니다. 날짜와 시간과 관련된 데이터에 대한 국제 표준으로 ISO 8601이 있으며, 이에 대응하는 국내 표준으로 KS X ISO8601이 있습니다. 표준이력사항을 읽어보면 국내산업에서 개정의 요구가 없어 국제 표준과 동일한 내용으로 국내에 적용하고 있는 것을 확인할 수 있습니다.해당 표준 내용을 정리하면 아래와 같습니다.\n한 주는 7일로 이루어져있다.\n한 주는 월요일로 시작하여 일요일로 끝난다.\n1년은 52주 또는 53주이다. (즉 364일 또는 371일이다.)\n1년의 첫번째 주는 해당 해의 첫번째 목요일이 포함된 주이다.\n1년의 마지막 주는 해당 해의 마지막 목요일이 포함된 주이다.\n주를 표현할 때에는 2018-W12 혹은 날짜를 포함하여 2018-W12-4처럼 한다. 이 경우 2018년의 13번째 주의 4번째 날이므로 2018년 03월 22일이 된다.\n\n요약하면, 한 주의 시작은 월요일, 끝은 일요일이지만, 주차에 대한 판단 기준은 목요일에 있습니다.예시를 들어보면 아래와 같다. 아래처럼 첫해의 첫 목요일이 포함된 주가 그 해의 첫번째 주가 됩니다.\nWeek\tMon\tTue\tWed\tThu\tFri\tSat\tSun\tW01\t01\t02\t03\t04\t05\t06\t07\n만약 첫 목요일이 아래와 같이 되어 있다면 해당 연도의 1월 1일부터 1월 3일은 그 해의 첫주가 아니라, 그 전 해의 마지막 주가 됩니다.\nWeek\tMon\tTue\tWed\tThu\tFri\tSat\tSun\tW53\t\t\t\t\t01\t02\t03\tW01\t04\t05\t06\t07\t08\t09\t10","week-number-계산하기#Week Number 계산하기":"주차를 직접 계산해봅시다. 깔끔하게 week_number(date: Date) -> i32 같은 함수가 나오는 것이 목표입니다. 주차란 올해의 첫번째 주로부터 몇 주가 지났는지를 의미합니다. 오늘이 올해의 몇 번째 날인지만 알면 7로 나누어 알아낼 수 있습니다. 오늘이 올해의 몇번째 날인지를 라고 하겠습니다. 이는 컴퓨터로는 오늘에서 1월 1일을 빼면 알 수 있고, 손으로는 오늘 날짜와 지나간 월들의 날을 모두 합하여 알아낼 수 있습니다.가장 간단하게 1월 1일이 월요일인 해를 가정해봅시다. 다음은 해당 해의 첫주이므로 부터 까지의 값이 1로 같아야합니다.\nWeek\tMon\tTue\tWed\tThu\tFri\tSat\tSun\tW01\t01\t02\t03\t04\t05\t06\t07\n다음과 같이 6을 더하고 버림 함수를 사용하면 이 구간에서는 의도한 대로 나옵니다.다른 예시를 살펴봅시다. 1일이 작년으로 넘어가면 올바른 결과가 나오지 않습니다. 해가 금요일부터 시작하여 1월 1일이 W01이 아닌 예를 봅시다.\nWeek\tMon\tTue\tWed\tThu\tFri\tSat\tSun\tW53\t\t\t\t\t01\t02\t03\tW01\t04\t05\t06\t07\t08\t09\t10\n, 이 되어야 하지만, 위의 식을 적용하면, 둘 다 1이 되어버립니다.주의 시작이 월~목일 때와 이를 넘어갈 때를 구분할 방법이 필요하다. 오늘 날짜에서 요일을 빼면 가능할 것 같다. ISO 8601에 요일을 수로 표현할 때는 월요일을 1로, 일요일을 7로 하여 나열한다고 나와있다. (이를 week day라고 한다.) 이렇게 하면 같은 주의 의 값은 일정해진다.값을 명확히 보기 위해 바닥함수는 제외하고 wN = (date) => (ordinal(date) - weekday(date) + 6) / 7이라고 하자. 1월 1일이 월요일일 때와 금요일일 때의 wN값을 확인해보자\nWeek\tMon\tTue\tWed\tThu\tFri\tSat\tSun\t요일\t01\t02\t03\t04\t05\t06\t07\tW01\t01\t02\t03\t04\t05\t06\t07\twN\t0.86\t0.86\t0.86\t0.86\t0.86\t0.86\t0.86\tW53\t\t\t\t\t01\t02\t03\twN\t\t\t\t\t0.29\t0.29\t0.29\tW01\t04\t05\t06\t07\t08\t09\t10\twN\t1.29\t1.29\t1.29\t1.29\t1.29\t1.29\t1.29\nwN이 1보다 작은 경우는 전년도의 마지막 주로 처리하면 깔끔할 것 같다. 그런데 1월 1일이 월요일일 경우 wN이 1.0을 넘지 않는다. 위에서 주었던 보정값 +6 대신 다른 상수를 더해서 해결해보자."}},"/notes/openwrt":{"title":"OpenWrt","data":{"":"","wireguard를-이용한-vpn-설정#Wireguard를 이용한 VPN 설정":"VPN은 공개 네트워크에서 비밀 네트워크로 접속할 때 유용한 보안 기술이다. 이를 이용하면 외부에서도 홈 네트워크에 안전하고 편리하게 접속할 수 있다.다양한 프로토콜이 있는데, 최근 리눅스 커널(5.6)에 포함된 wireguard가 편리하다.OpenWRT를 VPN 서버로 이용할 수 있다.WireGuard basics","설치#설치":"wireguard 프로토콜 자체는 커널에 포함되었으나, 관리도구는 별도로 설치해야한다. LuCI에서 편히 쓰고자 설치하는 거라서 없어도 무방하긴 하다. SSH로 접속하여 다음을 진행한다:\nopkg update\nopkg install luci-proto-wireguard luci-app-wireguard\n/etc/init.d/network restart\n혹은 LuCI → System → Software에 접속하여 두 패키지를 찾아 설치한다. 그 후 LuCI → System → Startup → Initscripts → network에서 restart를 누른다.","키쌍-생성하기#키쌍 생성하기":"wireguard는 공개키 암호화 방식을 이용한다. 다음 명령어로 공개키 쌍을 생성하자:\nmkdir /etc/wireguard\ncd /etc/wireguard\nwg genkey | tee uibook | wg pubkey > uibook.pub\nchmod 600 uibook\n/etc/wireguard는 키 저장을 위하여 임의로 만든 공간이다. wg genkey 명령어로 비밀키를, wg pubkey 명령어로 공개키를 만든다. 그중 비밀키는 반드시 권한을 600으로 수정하자.","인터페이스-생성하기#인터페이스 생성하기":"새로운 프로토콜(wireguard)를 사용하기 때문에, 통신을 위해서 새로운 인터페이스를 정의해야한다. LuCI → Network → Interfaces에서 할 수 있다.\n이름: wg0. 그냥 이걸 제일 많이 쓰더라.\nprotocol: WireGuard VPN\nprivate key: 아까 생성한 비밀키\npublic key: 아까 생성한 공개키\nlisten port: 49152 ~ 65535에서 고르면 된다는데 그냥 두면 랜덤 되는 듯\nip addresses: 해당 인터페이스에 할당할 IP이다. 10.9.0.1/24로 했다. 이 IP가 게이트웨이 역할을 한다.\n\n/etc/config/network 파일을 편집하여서 할 수도 있다. 아래처럼 추가하면 된다.\nconfig interface 'wg0'\noption proto 'wireguard'\noption private_key '[비밀키 내용 입력]'\nlist addresses '10.9.0.1/24'","피어-설정하기#피어 설정하기":"같은 곳에서 피어 설정도 같이 진행해야 한다. 피어란 접속하고자 하는 기기이다. 아래의 앱을 이용하면 편리하게 접속할 수 있다.Installation - WireGuard접속자도 공개키/비밀키 쌍을 만들고 공개키를 wireguard 서버에 등록해야한다. 그러나 서버에서 공개키/비밀키를 생성하고 이 자체를 공유해버릴 수도 있다.따라서 LuCI에서 Generate new key pair로 키쌍을 만들어버리고, 설정을 완료한 후 해당 설정을 QR 코드나 conf 파일 형태로 접속을 원하는 피어에 공유하여 등록하면 편하게 피어를 설정할 수 있다. QR코드로 보기 위해서는 qrencode 패키지를 설치해야한다.\nPublic Key: 접속하고자 하는 장치의 공개키\nPrivate Key: 접속하고자 하는 장치의 비밀키. 접속에는 필요 없지만 이를 넣으면 설정파일 공유할 때 편해진다.\nPreshared Key: 사실 뭔지 모르겠다.\nAllowed IPs: 피어가 터널 안에서 쓰도록 허용한 IP 대역.\nPersistent Keep Alive: 25가 권장값인듯\n\n\nconfig wireguard_wg0\noption public_key 'cIDLafiUna6OyxWd4aCtmTpGt1XIaCGVzmfEuEC4nmQ='\noption private_key '[검열 삭제]'\noption preshared_key '[검열 삭제]'\nlist allowed_ips '10.9.0.0/24'\noption persistent_keepalive '25'\n설정 후 가장 밑의 Generate configuration...을 누르면 설정을 피어에게 내보낼 수 있다. 이를 복사하거나 QR코드로 촬영하여 등록한다.\n[Interface]\nPrivateKey = 이 클라이언트의 개인키\nAddress = 할당 받을 IP (예: 10.9.0.3/24)\nDNS = 라우터 DNS (192.168.1.1)\n\n[Peer]\nPublicKey = 서버의 공개키\nAllowedIPs = 0.0.0.0/0\nEndpoint = 서버주소:포트\n여기서 AllowedIPs는 VPN을 거칠 IP를 의미한다. 0.0.0.0/0으로 되어있다면\n모든 접속을 VPN을 거쳐서 하게 된다.","방화벽-설정#방화벽 설정":"이제 방화벽을 개방해주어야한다. LuCI → Network → Firewall에서 설정 할 수 있다. 이 작업은 /etc/config/firewall을 수정하여서 할 수도 있다.General Settings 하단의 Zones에서 Add를 눌러 존을 만든다.\nName: 원하는 이름으로 한다. 여기서는 wireguard로 하였다.\nInput/Output: Accept\nForward: Reject\nMasquerading: 체크하라는데 뭔지는 모르겠다.\nMSS clamping: 체크하라는데 뭔지는 모르겠다.\nCovered Networks: 아까 만든 wg0\nAllow forward to destination zones: 이 존에서 어떤 존으로 갈 수 있는 지를 묻는 것이다. VPN으로 접속시 내부 네트워크와 외부망을 모두 쓰고 싶으므로 lan, wan을 고른다\nAllow forward to source zones: 외부망에서는 접근을 원치 않으므로 lan만 고른다.\n\n\nconfig zone\noption name 'wireguard'\noption input 'ACCEPT'\noption output 'ACCEPT'\noption forward 'REJECT'\noption masq '1'\noption mtu_fix '1'\nlist network 'wg0'\n\nconfig forwarding\noption src 'wireguard'\noption dest 'lan'\n\nconfig forwarding\noption src 'wireguard'\noption dest 'wan'\n\nconfig forwarding\noption src 'lan'\noption dest 'wireguard'\n이제 포트를 개방해줄 차례이다.Traffic Rules 탭에 들어가 Add를 누른다.\nName: 작명 규칙에 맞게 Allow-Wireguard로 하자.\nProtocol: wireguard는 UDP를 사용하므로 UDP만 체크한다\nSource zone: 외부에서의 접속이므로 wan에 체크한다.\nDestination port: 기본 wireguard 포트인 51820을 쓴다.\nAction: 당연히 accept"}},"/notes/order":{"title":"순서","data":{"":"직관적으로 생각하는 순서는 정수의 크기비교이다.순서라는 개념을, 두 원소가 특정 조건을 만족하는 관계로 일반화하여 생각할 수 있다.\n조건에 따라 준순서, 부분순서, 전순서 등으로 확장하여 생각할 수 있다.순서를 표기할 때  기호를 그대로 쓰기도 하고,  기호처럼 살짝 다른 부등호를 써서 정의하기도 한다. 보통 부분순서에 , 전순서에  쓰는 듯.","준순서#준순서":"어떤 집합 에 대해 이항 관계 가 준순서(preorder)이려면, 에 대하여 아래를 만족해야한다.\n: 반사적\n: 추이적","전순서#전순서":"어떤 집합 에 대해 이항 관계 가 전순서(total order)이려면, 에 대하여 아래를 만족해야한다.\n: 반사적\n: 연결적\n: 반대칭적\n: 추이적\n\n전순서 관계인 집합의 원소는 그 크기를 비교하여 일렬로 늘여 놓을 수 있다. 이 때문에 선형 순서(linear order)라고 부르기도 한다.","예시#예시":"실수\n사전식 순서\n시간","부분순서#부분순서":"부분순서(partial order)는 전순서에서 어떤 원소든 비교할 수 있다는 성질이 빠진다.\n: 반사적\n: 반대칭적\n: 추이적","예시-1#예시":"집합 의 부분집합들의 포함관계는 부분순서이다.\n모든 원소는 스스로의 부분집합이므로 반사적이다.\n인 관계는 일 때 뿐이므로, 반대칭적이다.\n인 것 처럼, 추이성도 성립한다.\n인 것처럼, 모든 관계에서 순서가 성립하는 것이 아니므로 전순서는 아니다.\n\n아래 그림은 위의 예에 대한 하세 다이어그램이다.","관계의-성질#관계의 성질":"아래의 정의는 에 대해서이다.\n\n는 과 동일하다.","반사적-관계#반사적 관계":"모든 원소에 대해 스스로와의 관계가 성립한다면 반사적(reflexive)이다.\n정수에서 모든 수는 자기 자신과 같고(), 같거나 작고(), 같거나 크다().\n집합에서 모든 집합은 자기 자신을 부분집합()으로 삼는다.\n\n정수의 , , 는 반사적이지 않다. 이를 비반사적(irreflexive)이라고 한다.","대칭-관계와-반대칭-관계#대칭 관계와 반대칭 관계":"가 성립할 때 그 대칭적 관계, 즉 도 성립하면 대칭적(symmetric)이다.두 항이 같을 때에만 대칭 관계가 성립하면 반대칭적(antisymmetric)이다.아예 대칭 관계가 성립하지 않으면 비대칭적(asymmetric)이다.","추이적-관계#추이적 관계":"두 관계로 새로운 관계를 유추할 수 있다면 추이적(transitive)이라고 한다.\n정수 a, b, c가 있을 때, 이고 이면 이다.\n\n\n\n집합 에 대하여,","연결성#연결성?":"종류가 여럿 있는데 용어 통일이 안 된 모양새이다.\n집합의 전체 원소에 대해 관계를 만족하는 것을 연결되어있다고 한다.\n연결되어있다(connected) :\n혹은\n강하게 연결되어있다:","참고#참고":"Total order - Wikipedia\nBartosz Milewski, Category Theory for Programmers.\n관계(Relations) - 기계인간 John Grib.\n황병연, 이산수학."}},"/notes/os":{"title":"운영체제","data":{"":"“운영체제: 아주 쉬운 세 가지 이야기”에서는 운영체제의 근간을 세 가지 개념으로 나눈다.\n가상화\n동시성 (번역본에서는 병행성으로 번역되었다.)\n영속성\n\n\n유닉스 신호","멀티태스킹#멀티태스킹":"스케줄링 방식에 있어, 제어권을 누가 갖느냐로 크게 둘로 나눈다.","협력형-멀티태스킹#협력형 멀티태스킹":"Cooperative multitasking. 혹은 비선점(non-preemptive) 멀티태스킹으로 부르기도 한다.Windows 3.1, Mac OS 9 등 고전 운영체제에서 사용했던 방법으로 운용프로그램이 자발적으로 제어권을 반환하는 방법. 운용프로그램이 제어권을 독점할 문제가 있다.","선점형-멀티태스킹#선점형 멀티태스킹":"Preemptive multitasking.운영체제의 스케줄러에 의하여 제어권을 관리하는 방법. 상당히 짧은 시간에 한하여 제어권을 인계하고 도로 가져간다. 오늘날 대부분의 운영체제에서 사용한다.구현을 위하여 하드웨어 타이머, 스케줄러 등이 필요하다.","용어에-대하여#용어에 대하여":"언뜻 보면 선점형 멀티태스킹은 먼저 제어권을 선점한 프로세스가 맘껏 연산장치를 쓸 수 있을 것처럼 보인다. 실은 스케줄러에 의해 제어권을 관리한다.일본어권에서는 선점형이라는 말보다는 preemptive multitasking을 그대로 음차하여 プリエンプティブマルチタスク라고 부르거나 非協調的(비협력적)이라고 부르는 듯하다.협력적 멀티태스킹을 疑似(의사) 멀티태스킹이라고 부르기도 한다.\nThe term \"preemptive multitasking\" is sometimes mistakenly used when the intended meaning is more specific, referring instead to the class of scheduling policies known as time-shared scheduling, or time-sharing. - Preemption (computing)","참고#참고":"리눅스 및 커널프로그래밍 - 금오공과대학교 | KOCW 공개 강의\n국민대학교 OCW\n반효경, 운영체제, 이화여자대학교, 2014\nostep-translations/korean at master · remzi-arpacidusseau/ostep-translations · GitHub"}},"/notes/phoenix":{"title":"Phoenix","data":{"":"Phoenix Framework","heex#HEEx":"Phoenix 1.6.0 Released - Phoenix Blog"}},"/notes/postgresql":{"title":"PostgreSQL","data":{"":"PostgreSQL: The world's most advanced open source database","설치#설치":"세 가지 선택지가 있다:\n직접 빌드한다\n컨테이너로 깐다\n패키지 매니저로 깐다","macos#macOS":"brew로 깔고 brew services로 돌린다. 버전명이 붙은 formula이기 때문에 아래처럼 PATH를 등록해주어야 psql이나 createdb와 같은 명령어를 쓸 수 있다.\nbrew install postgresql@15\necho 'export PATH=\"/opt/homebrew/opt/postgresql@15/bin:$PATH\"' >> ~/.zshrc\nbrew services start postgresql@15","시작하기#시작하기":"PostgreSQL은 클라이언트/서버 모델 데이터베이스이다. 클라이언트는 PostgreSQL에서\n제공하는 프론트엔드가 될 수도 있고, 사용자가 개발하는 어플리케이션이 될 수도\n있다.PostgreSQL 서버 프로세스는 새 클라이언트가 접속할 때마다 프로세스를 포크한다.PostgreSQL 서버는 여러 데이터베이스를 관리할 수 있다.\ncreatedb [DB 이름] -- DB 생성\ndropdb [DB 이름] -- DB 삭제\npsql [DB 이름] -- DB 접속","psql#psql":"SQL이 아닌 명령어는 \\으로 시작한다.\n\\h -- 도움말.\n\\i -- 파일에서 SQL 읽어오기.\n\\d -- 현재 DB의 모든 객체 나열.\n\\d [테이블 이름] -- 테이블의 구조 확인. \\d+는 더 자세한 정보가 나온다.\n\\d [함수 이름] -- 함수의 인자, 반환형 등 확인.\n\\dt -- 현재 DB의 모든 테이블 나열.\n\\dt [테이블 이름] -- 테이블과 관련된 테이블 나열.","sql#SQL":"","테이블-만들고-지우기#테이블 만들고 지우기":"CREATE TABLE cities (\nname       varchar(80),\nlocation   point\n);\n\nDROP TABLE cities;\n표준 SQL 타입: int, smallint, real, double precision, char(n),\nvarchar(n), date, time, interval, ...point 같은 비표준 타입도 있으며, 타입을 새로 만들 수도 있음.https://www.postgresql.org/docs/current/sql-createtype.html그 외의 자료형은 문서 참고TODO: 테이블 이름은 복수형이여야 하는가?\nhttps://stackoverflow.com/questions/4702728/relational-table-naming-convention","행-삽입하기#행 삽입하기":"column 순서에 맞게 기입해야함.\n혹은 column 순서를 명시할 수 있음.\n\n\ncolumn은 nullable하다면 생략할 수 있음.\n숫자가 아닌 값은 작은따옴표(')로 감싸야함.\n\n\nINSERT INTO cities VALUES ('Seoul', '(37.5642, 127.0016)');\n\nINSERT INTO cities (name, location)\nVALUES ('Seoul', '(37.5642, 127.0016)');","쿼리하기#쿼리하기":"SELECT로 테이블에서 값을 얻어올 수 있음. *로 모든 컬럼을 얻어올 수도 있다:\nSELECT name FROM cities;\n\nSELECT * FROM cities;\n가져온 필드로 연산을 할 수도 있다:\nSELECT city, (temp_hi + temp_lo) / 2 AS temp_avg, FROM weather;\nWHERE로 가져올 테이블의 조건을 명시하거나, 가져온 데이터를 정렬할 수 있다:\nSELECT * FROM weather\nWHERE city = 'Seoul'\nORDER BY city;\n중복된 행은 빼고 가져올 수 있다:\nSELECT DISTINCT city FROM weather;","조인#조인":"여러 테이블의 정보를 연관지어 하나의 결과를 만드는 것을 조인이라고 한다.\ninner join: 두 테이블에서 특정 값이 일치하는 데이터만 찾는다.\nouter join: 일치하지 않는 데이터도 가져온다.\nleft outer join: 왼쪽 테이블에 오른쪽 테이블을 결합한다.\nrigjt outer join: 왼쪽 테이블을 오른쪽 테이블에 결합한다.\nfull outer join: 두 테이블에서 모든 데이터를 가져온다.\n\n\ncross join","inner-join#inner join":"CREATE TABLE weather (\ncity\t\tvarchar(80),\ntemp_lo\t\tint,\t\t-- low temperature\ntemp_hi\t\tint,\t\t-- high temperature\nprcp\t\treal,\t\t-- precipitation\ndate\t\tdate\n);\n\nCREATE TABLE cities (\nname\t\tvarchar(80),\nlocation\tpoint\n);\n\n-- join on\nSELECT * FROM weather JOIN cities ON city = name;\n\nSELECT weather.city, weather.temp_lo FROM weather\nJOIN cities ON weather.city = cities.name;\n\n- join 키워드 없이 조인\nSELECT * FROM weather, cities WHERE city = name;\nweather 테이블과 cities 테이블이 있다. weather 테이블의 정보 중 city\n컬럼을 cities의 name과 연관지어 cities의 내용도 쿼리하였다.위의 예에서는 두 테이블에 겹치는 컬럼이 없지만, 있을 경우 테이블 이름을\n접두어로 쓸 수 있다.left join과 right join은 기준만 다르고 동작은 같다. 하나의 테이블은 온전히\n출력하되, 참고하는 테이블에 값이 일치하는 행이 있다면 그 내용을 가져온다.\n-- 아래의 두 SELECT의 결과는 column의 순서만 다르고 내용은 같다:\n\nSELECT * FROM weather\nLEFT OUTER JOIN cities ON weather.city = cities.name;\n\nSELECT * FROM cities\nRIGHT OUTER JOIN weather ON weather.city = cities.name;","참고#참고":"Stephan Schmidt, Just Use Postgres for Everything.\nPostgreSQL 13.3 문서 – 자습서 최신 번역본\nPostgreSQL Documentation"}},"/notes/proxmox-setup":{"title":"Proxmox VE 기초설정","data":{"":"","유저-설정하기#유저 설정하기":"항상 시스템 구성하면 root 외의 유저 계정 생성하고 SSH 접속 제한하자.서버에 접속하여 adduser로 유저를 생성한다.\n$ adduser nyeong\n$ apt install sudo\n$ groupadd sudoers\n$ usermod -g suoders nyeong\n$ EDITOR=vi visudo\n$ su nyeong\n로컬로 빠져나와 SSH 공개키를 서버로 복사한다.\n$ ssh-copy-id 192.168.1.100\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/Users/nyeong/.ssh/id_ed25519.pub\"\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\nnyeong@192.168.1.100's password:\n\nNumber of key(s) added:        1\n\nNow try logging into the machine, with:   \"ssh '192.168.1.100'\"\nand check to make sure that only the key(s) you wanted were added.\n다시 서버에 접속하여 ssh 설정을 바꾼다.\n# /etc/ssh/sshd_config\nPasswordAuthentication no\nPermitRootLogin no\n그 후 다시 ssh 서비스를 재시작한다.\n$ sudo systemctl restart ssh\n이후 ssh로 root로 로그인은 불가능하다.리눅스 계정이 있더라도 Proxmox VE 유저는 별도로 추가해야한다.\nhttps://proxmox-ip:8006으로 이동하여 proxmox 웹 환경에 접속하여\ndatacenter -> permissions -> user로 이동하여 유저를\n추가한다. Realm은 Linux PAM으로, 유저이름은 방금 추가한 리눅스 유저이름으로\n한다.","패키지-저장소-관리#패키지 저장소 관리":"기업 지원 패키지는 유료이기 때문에 주석처리한다.\nvi /etc/apt/sources.list.d/pve-enterprise.list\n/etc/apt/sources.list 파일에 비 구독 저장소를 추가한다.\ndeb http://download.proxmox.com/debian/pve bullseye pve-no-subscription\n\napt update\napt dist-upgrade","컨테이너-만들기#컨테이너 만들기":"다음의 명령어로 컨테이너 이미지 목록을 업데이트한다.\n$ sudo pveam update\n$ sudo pveam available","유용한-명령어#유용한 명령어":"pct enter <vmid>"}},"/notes/proxmox-storage":{"title":"Proxmox 저장장치 설정","data":{"":"","현재-상황#현재 상황":"현재 시스템에 연결된 저장장치는 세 개이다:\nNVME SSD (256GB)\nHDD (14TB)\nHDD (2TB)\n\n\n호스트 OS : Proxmox VE를 돌릴 공간\nNAS, cloud : 클라우드 저장소 서비스를 대체하기 위함\nSMB, nextcloud,\n\n\nDB\n그 외 VM을 돌릴 가상 드라이브","의문#의문":"Proxmox VE에서 직접 스토리지 다루기 vs Guest NAS OS에 패스스루하기.\nNextCloud + SMB를 쓰려면 TrueNAS같은 운영체제를 설치하는 것이 좋은가?\n아니면 그냥 리눅스에 깔아도 무방한가?\nNextCloud를 쓰면 SMB, AFP, NFS 같은 서비스들이 굳이 필요할까?","nas-운영하기#NAS 운영하기":"어디서든 데이터 접근\n사진 백업\n\nSMB, AFP, NFS\nTrueNAS\nOMV\nLinux\nSynology\n\n서비스는\nnextcloud\nphotoprism\nfilerun\n\n따라서 아래와 같이 계획을 잡음\n디스크 관리: Proxmox VE에서 ZFS로.\n공유 서비스: NextCloud를 최대한 활용.","스토리지-설정#스토리지 설정":"ZFS로 구성하려면 RAID, 압축 여부, ashift 등을 설정해야함.\nRAID: 갖고 있는 디스크가 14TB, 2TB로 용량 차이가 크므로 RAID를 하지 않았음\n압축: 일반적으로 lz4가 자원 대비 성능이 좋아 공식 문서에서도 이를 추천함\nashift: 블록의 크기를 결정함. HDD의 블록의 크기가 4KB이므로 12를 썼음."}},"/notes/scala":{"title":"스칼라","data":{"":"","왜#왜":"JVM 언어를 써 본 적 없어서\n강타입 구조적 언어를 써보려고\n데이터를 다룰 때 주로 거론되기에\n다른 언어에서 좋게 썼던 기능들이 있기에\n루비와 뭔가 비슷함\n엘릭서처럼 액터 모델이 주류임 (akka)\n러스트처럼 함수적 데이터 모델링이 가능\n하스켈처럼 타입 시스템이 있긴 함","도구와-생태계#도구와 생태계":"https://docs.scala-lang.org/getting-started/index.htmlcoursier라는 읽기 힘든 이름의 도구를 사용한다.\nJRE가 필요한데, 스칼라 버전에 따라 호환되는 JVM 버전이 정해져있다.\ncoursier: 버전 관리자\nscalac: 컴파일러\nscala: REPL (정적 컴파일 언어인데도 REPL을 지원한다)\nsbt: 빌드 도구\nscalafmt: 코드 포맷터\n\n2.x 버전과 3.x 버전이 있는데, 대부분의 코딩 저지 사이트와 책에서\n2.x 버전만 다루고 있어서 2.x 설치\n$ asdf install java openjdk-17.0.2\n$ cs install scala:2.13.10 scalac:2.13.10\n\n스칼라 표준 라이브러리","타이핑-모델#타이핑 모델":"정적이고 강타입이고 명목적이며 대부분의 값들이 객체이다.\nif (Nil) println(\"true\")\nerror: type mismatch;\nfound   : collection.immutable.Nil.type\nrequired: Boolean\n\n스칼라, 러스트: 참/거짓 판별은 오직 Bool만 가능함\n루비, 엘릭서: nil, false는 false로 평가되고 나머지는 true임\nC, 파이썬: 맥락에 따라 false로 평가되는 값이 있음 (0, null, [] 등)\n\n루비와 비슷하게 기본 자료형도 객체이고, 기본 연산자도 메소드다.https://www.scala-lang.org/api/current/scala/Int.html다만 기본 자료형이 abstract로 선언되어있고 세부 구현이 숨겨져 있는 것을 보면\n아마 컴파일 단계에서는 원시타입으로 바뀌는 것 같다.\n// 1 + 1이라는 건\n1 + 1\n\n// 1이라는 Int 클래스의 인스턴스가 1을 인자로 `+`라는 메소드를 호출하는 것\n1.+(1)\n\n# 루비도 기본 자료형이 객체이고 +, - 등 연산자도 메소드이다.\n3.class\n# => Integer\n3.methods.include? :+\n# => true\n재밌게도 def +(x: String): String, 그러니까 Int와 String의 합연산이\n정의되어 있어 보기처럼 작동은 하는데, 이 메소드는 2.13.0부터 deprecated 됐다.\n그런데 반대로 String에서 Int를 더하는 연산은 deprecated 되지 않았는데,\njava.lang.String을 쓰기 때문인 것 같다.java.lang 아래의 모듈들은 자동으로 import한다. String도 사실은\njava.lang.String이다.\n3 + \".14\"\nval res: String = \"3.14\"\n\n\"4\" + 2\nval res: String = \"42\"\nInt + String이 s-보간법 때문에 deprecated 되는 것 같은데, 같은 이유라면\n항의 순서가 뒤바뀐 String + Int도 deprecated 되어야 하겠지만 JVM에 귀속된\n메소드라 유지되는 것 같다.루비의 중위 연산자는 특수한 경우이고 별도로 선언이 불가능하다.\n엘릭서에서는 선언은 가능하나, 컴파일러가 인식할 수 있는 연산자가 정해져\n있다.https://hexdocs.pm/elixir/1.14.3/operators.html#defining-custom-operators그에 비해 스칼라는 중위 연산자 자체가 문법 설탕이라 아래의 짓거리가 가능하다.\ncase class MyBool(x: Boolean) {\ndef and(that: MyBool): MyBool = if (x) that else this\n}\n\n// 보통은 이렇게 쓰겠지만\nMyBool(true).and(MyBool(true))\n\n// 이렇게 써도 알아먹는다\nMyBool(true) and MyBool(true)\n변수 선언은 val 혹은 var로 가능하다. val은 불변 변수이고 var은 가변\n변수이다. 타입은 : Type 구문으로 명시하고, 유추 가능하면 생략할 수 있다.\nval value = 4\nvar variable = 4\n다행히 재할당(혹은 가리기(shadowing))이 가능하다. val로 같은 이름을 여러번\n선언할 수 있다. 자바스크립트는 const로 선언하면 이게 안 되어서 불편하다.\nval value = 3\nval value = doSomethingWith(value)\n\nconst value = 10\nconst value = doSomethingWith(value)\n// Uncaught SyntaxError: Identifier 'value' has already been declared\n불변과 가변 선언을 갈라놓은 언어들은 함정이 있다. 불변의 의미가 두가지이기\n때문이다.\n객체의 재할당이 불가능하다\n객체의 재할당도 불가능하고 객체 값의 변경도 불가능하다\n\n1번인 언어들은 객체가 같음은 보장되지만, 객체가 불변임은 보장되지 않는다.\n값의 불변성을 위해서는 freeze 처리를 따로 해주어야 한다.\nconst config = { url: 'https://example.com' }\n\n// config와 Object 사이의 할당 관계 자체는 변하지 않았다.\nconfig.url = 'https://bad-url.com'\n\n// 이렇게 해야 불변성이 보장된다.\nObject.freeze(config)\n2번인 언어는 불변으로 선언만 하면 어떤 변수가 가리키는 대상이 바뀌지 않고,\n대상 자체의 값도 변하지 않는 것이 보장된다.\nlet map = HashMap::new();\n// 아래의 코드는 컴파일이 안된다.\n// `insert` 메소드는 `(&mut HashMap<K, V>, K, V) -> Option<V>` 타입이고,\n// `map`은 `mut`가 아니기 때문에 `&mut`로 빌릴 수가 없다.\nmap.insert(37, \"a\");\n스칼라는 1번인 언어이다. 대신 가변 자료구조와 불변 자료구조를 구분하여 이를\n타입으로 명시했다.\n가변 자료구조로 선언하면 val로 선언하더라도 불변이 보장되지 않는다.\nval arr = Array(1, 2)\n\n// 업데이트가 가능하다.\narr.update(0, 42)\n\n// 이렇게는 가능하다.\n// arr이 가리키고 있던 List가 갖고 있는 값이 바뀐 것이 아니라\n// arr에 업데이트된 List가 재할당된다\nvar arr = List(1, 2)\narr.updated(0, 42)\n\n// 이렇게는 재귀적인 값 참고라고 불가능하다\nval arr = List(1, 2)\nval arr = arr.updated(0, 42)","자료구조#자료구조":"LISP 계열의 구조적 타이핑 언어들은 표준 자료구조 몇 개를 열심히 돌려써먹는다.\n따라서 자료구조의 리터럴 표현도 간략하고 특징적이다.\ntuple = {1, 2}\nlist = [1, 2]\ntuple_in_list = [a: 2, b: 4]\nmap = %{:a => 2, :b => 4}\nfunction = fn x -> x end\ncustom_type = %CustomType{field: value}\n스칼라는 반대로 대부분의 자료구조는 리터럴이 없고 열심히 타입을 명시해야한다.\n대신 자료구조가 풍부하며 리터럴이 일관적이다.위에서 얘기한 대로 가변 자료구조와 불변 자료구조를 구별하기도 한다.\nval tuple: (String, Int) = (\"localhost\", 80)\nval list: List[Int] = List(1, 2, 3, 4, 5)\nval array: Array[Int] = Array(1, 2, 3, 4, 5)\nval set: Set[Int](1, 2, 3, 4, 5)\nval map: scala.collection.immutable.Map[String,Int] = Map(\"a\" -> 1)\nval function: Any => Any = (x: Any) => x","list#List":"랜덤 엑서스가 가능하고, 동종 자료만 담을 수 있고, 순서가 보장되며 불변이다.\nval l = List(\"one\", \"two\", \"three\")\n동종 자료만 담을 수 있다.\n서로 다른 자료형을 담고자 하는 경우, 이에 대한 타입을 새로 선언하거나 Any를\n써야한다. 스칼라 3에서는 합타입을 지원하므로 편하게 합타입으로 처리하면 된다.\nval l: List[Any] = List(\"one\", \"two\", 3)\n\n// 스칼라 3의 경우\nval l: List[String | Int] = List(\"one\", \"two\", 3)","set#Set":"순서가 보장되지 않으며 불변이다.","range#Range":"val res: scala.collection.immutable.Range.Inclusive = 1 to 10\nval res: scala.collection.immutable.Range = 1 until 10","제어구조#제어구조":"제어구조의 조건문에는 Boolean 타입만 들어갈 수 있다.\nwhile\nfor\nforeach[U](f: (T) => U): Unit"}},"/notes/sql":{"title":"SQL","data":{"":"","select#SELECT":"","like#LIKE":"https://www.postgresql.org/docs/current/functions-matching.html\nSELECT FACTORY_ID, FACTORY_NAME, ADDRESS\nFROM FOOD_FACTORY\nWHERE ADDRESS LIKE \"강원도%\"\n...;","coalesce#COALESCE":"https://www.postgresql.org/docs/current/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULLNULL인 경우 출력을 대체할 수 있음\n-- TLNO가 NULL인 경우 NONE을 출력\nSELECT COALESCE(TLNO, \"NONE\") FROM PATIENT ..."}},"/notes/types-are-sets":{"title":"타입은 집합이다","data":{"":"타입을 집합으로 생각해보자.정수 타입 i32를 생각해보자. 보통 이 타입은 구간 에 속한\n정수를 표현할 수 있다. 구간 내의 정수를 원소로, 타입 i32를 집합으로 볼 수\n있다.i32를 인자로 취하는 함수를 생각해보자. 아래의 함수 i32는 수를 제곱해준다.\n따라서 반환 타입도 i32이다.\nfn square(n: i32) -> i32 { n * n }\n이를 집합으로 생각해보자. 함수 는 를 취하여\n를 반환하는 함수이다.타입을 집합으로 생각하면 아래처럼 볼 수 있다:\n값은 원소이다.\n타입은 가능한 값들의 집합이다.\n함수는... 함수이다. 집합의 함수가 그러하듯 어떤 타입을 다른 타입과 이어준다.","사실-집합은-아니다#사실 집합은 아니다":"그러나 프로그래밍 언어는 컴퓨터에 내리는 명령이고, 정의만으로 끝나는 것이 아니라\n실제로 수행하는 작업의 나열이다. 어떤 때에는 작업이 끝나지 않을 수도 있다.\n그리고 작업이 끝나지 않는 것을 미리 알 수 있는 방법은 없다.https://en.wikipedia.org/wiki/Halting_problem\nfn some_function(arg: bool) -> bool;\n// 이 함수가 정상적으로 `bool`을 반환하지 않을 수도 있다.\n위의 함수가 정상적으로 bool을 반환한다는 것은 보장할 수 없다.\n무한 루프에 빠질 수도 있고, 무한 재귀에 빠질 수도 있고, 예외가 발생할 수도\n있고, 에러가 날 수도 있고, 프로그램이 강제 종료 될 수도 있다.\n아니면 결과가 나오기 전에 컴퓨터가 폭발하여 사라질 수도 있다.따라서 끝나지 않는 작업(non-terminating computation)을 표현하기 위하여\nbottom이라는 값이 도입되었다. 으로 표기한다.\n모든 타입은 ⊥을 값으로 갖는다. 특정 타입을 반환할 때만 안전하리라는 보장이\n없기 때문이다. 따라서 bool 타입은 true, false, ⊥을 값으로 취한다.⊥도 bool 타입이기 때문에 아래의 코드는 정상적으로 컴파일된다.\n그리고 의도대로 true도 false도 아닌 ⊥을 반환할 것이다.\nfn some_function(_arg: bool) -> bool {\npanic!()\n}\n⊥의 존재로 프로그래밍 언어의 타입은 엄밀히 말하여 집합은 아니다. 그러나\n⊥만 제외한다면 집합과 유사하기 때문에 집합으로 생각하여도 괜찮다.","타입은-집합이다#타입은 집합이다":"타입을 집합이라고 생각해도 괜찮다. 타입을 집합으로 생각하면 프로그램을 분석하기\n쉬워진다.프로그램이 옳은지 분석하고 검증하는 것은 어려운 일이다. 프로그램을 함수의\n결합(composition)으로 생각하고, 유효한 결합인지 검증하는 것은 훨씬 쉽다.\n또한 프로그래밍 언어는 각 언어 설계자의 취향과 의도에 따라 서로 다른 용어를\n사용하는데, 이를 집합으로 봄으로써 동일한 언어와 용어로 분석할 수 있다.","공집합#공집합":"공집합(empty set)은 아무런 원소가 없는 집합이다.  혹은 로\n표기한다. 공집합에 대응하는 타입을 상상해보자.\nenum EmptySet {}\nlet some_value: EmptySet = ???;\nEmptySet이라는 타입은 존재하지만 그 타입에 속하는 값이 존재하지 않는다.\nEmptySet을 인자로 취하는 함수를 상상해보자.\nfn absurd(arg: EmptySet) -> T;\n위 함수를 호출할 수 있을까? EmptySet을 인자로 취하기 때문에 값을 넘겨주어야\n하지만 EmptySet 타입인 값은 존재하지 않는다. 따라서 위의 함수는 호출할 수 없다.\nabsurd(???); // 인자로 넘겨줄 값이 존재하지 않다.\nEmptySet을 반환하는 함수는 만들 수 있을까? 얼핏보아서는 불가능할 것 같다.\n반환하면 EmptySet의 원소를 메모리에 표현해야하는데, 존재하지 않는 것을 메모리에\n표현할 수는 없다.그럼에도 EmptySet을 반환하는 함수를 정의하고 실행할 수 있다. 말장난 같지만\n끝나지 않는 작업을 이라는 값으로 정의하였고, 모든 타입은 을 원소로\n갖기 때문에 공타입 enum EmptySet {} 또한 을 원소로 취한다.따라서 아래 함수는 정의할 수 있고, 컴파일되고, 실행할 수 있다.\n아래가 바로 공타입을 반환하는 함수이다. 정말 대단해.\nfn some_function() -> EmptySet {\nloop {}\n}\n러스트에서는 원시타입으로 never가 정의되어 있으며 !로 표기하기 때문에\nbang-type이라고도 부른다. 위의 EmptySet은 !로 대체할 수 있다.대체 이걸 어디다 써먹는단 말인가? 위에서 보았듯이 공타입은 오로지 , 즉\n반환이 없음만을 그 값으로 취할 수 있다. 따라서 이를 표현하는 타입으로 활용할 수 있다.\n문제가 있는 경우를 타입으로 표기함으로써 이를 타입 시스템에서 파악할 수 있다.현재 프로세스를 종료하는 러스트 표준 함수 std::process::exit의 타입은 아래와 같다:\npub fn exit(code: i32) -> !\n반환형이 !이기 때문에 이 함수가 실행되면 다음 작업을 실행할 수 없음을 알 수 있다.\n덕분에 컴파일러가 아래처럼 실행 전에 미리 경고해줄 수 있다.\nfn main() {\nstd::process::exit(0);\n//  --------------------- any code following this expression is unreachable\nprintln!(\"Hello, World!\");\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n}\nhttps://rust-lang.github.io/rfcs/1216-bang-type.html","단위-집합#단위 집합":"단위 집합(unit set)은 단 하나의 원소만을 갖고 있는 집합이다.\n원소가 하나니까 싱글톤(singleton)이라고도 불리운다. 싱글톤 패턴의 그 싱글톤 맞다.싱글톤 패턴은 어떤 클래스에 대한 인스턴스가 오직 단 하나만 존재하도록 하는\n디자인 패턴이다. 아래의 예시에서 변수 x, y, z 모두 같은 싱글톤 인스턴스를\n가리키고 있다. 인스턴스가 단 하나이기 때문에 싱글톤이라는 이름이 붙었다:\nclass Singleton {\nprivate static Singleton instance = null;\nprivate Singleton() { /* initiating Singleton object */ }\npublic static Singleton getInstance() {\nif (instance == null)\ninstance = new Singleton();\nreturn instance;\n}\n}\n\n// in other methods...\nSingleton x = Singleton.getInstance();\nSingleton y = Singleton.getInstance();\nSingleton z = Singleton.getInstance();\n어떤 언어에서는 특별한 값을 나타내기 위해 단위 타입을 사용한다.\n루비의 true, false, nil 등의 값은 TrueClass, FalseClass, NilClass의\n유일한 값이다. 따라서 이들은 단위 타입이다.\nirb> true\n=> true\nirb> true.class\nTrueClass\nTrueClass의 원소는 (을 제외하면) true 말고는 없다.단위 타입은 사실 암묵적으로 정말 많이 쓰이고 있다. 아래의 예시를 통해 알아보자.\n아래의 함수 hello_world는 아무 인자를 취하지 않고 String을 반환하고 있다.\n아무것도 아닌 것을 인자로 취하는 공타입과는 구별된다.\n// 인자를 취하지 아니함\nfn hello_world() -> String { /* ... */ }\n// 인자를 넘기지 않아도 실행된다\nlet hi = hello_world();\n\n// 아무것도 아닌 것을 인자로 취하는 공타입과는 다르다\nfn hello_world(arg: !) -> String { /* ... */ }\n// 아무것도 아닌 것을 인자로 넘길 수는 없다...\nlet hi = hello_world(???);\n정말 아무것도 취하지 않고 String을 반환한다면 사실상 String과\n동일해야 한다. 그러나 hello_world는 String은 아니다.\n아래의 예시는 타입 에러가 난다:\nfn hello_world() -> String { /* ... */ }\nlet hello_string: String;\n\nfn print_it(arg: &String);\nprint_it(&hello_world);  // mismatched types\nprint_it(&hello_string); // 문제 없음\nhello_world는 그냥 String인 것이 아니라 아무것도 아닌 무언가를 String으로\n바꿔주는 함수이다. 아무것도 아닌 무언가의 역할을 할 것이 있어야 하는데 이\n암묵적인 역할을 단위 타입이 맡는다. 러스트에서는 이를 ()으로 표기하고\n유닛이라고 읽는다. hello_world 함수를 인자로 받는 함수는 아래와 같다:\nfn print_it(arg: dyn &Fn() -> String);\nprint_it(&hello_world);\n아무것도 반환하지 않는 함수도 사실은 아무것도 아닌 무언가를 반환하고 있다.\n아래의 셋은 동일하다:\nfn main() { /* ... */ }\nfn main() -> () { /* ... */ }\nfn main() { return (); } // () 타입은 그 값도 ()로 표기한다.\nC계열 언어에서는 반환값이 없는 함수를 표현할 때에 void로 선언하기 때문에\n좀 더 명시적으로 확인할 수 있다.\nvoid function_no_return() { /* ... */ }\n단위 타입을 이용함으로써 아무것도 아님을 표현할 수 있다.어떤 타입 T를 받아 단위 타입을 반환하는 함수는 타입 별로 딱 하나만 존재한다.\n예를 들어 bool -> ()인 함수는 아래의 함수 외에는 존재할 수 없다.\nfn unit(_: bool) -> () { return (); }\n반대로 단위 타입을 받아 어떤 타입 T를 반환하려면, 타입 T의 원소 수만큼\n함수를 만들 수 있다. 예를 들어 () -> bool인 함수는 아래의 두 함수가 있다.\nfn true() -> bool { true }\nfn false() -> bool { false }","원소가-둘인-집합#원소가 둘인 집합":"원소가 둘인 집합은 그 값이 이거 아니면 저거인 집합이다.\nenum Boolean {\nTrue,\nFalse,\n}\n우리에게 친숙한 원소가 둘인 집합은 바로 bool이다. 0, 1도 좋고\ntrue, false도 좋다. 어쨌든 원소는 둘뿐이어야한다.bool을 취하여 bool을 반환하는 함수는 몇 개나 있을까? 집합 의 갯수를\n생각해보자.아래와 같이 항등함수 두 개(always, never), 단위함수 하나(id), not 함수까지\n총 네 개를 생각할 수 있다.\nfn always(_: bool) -> { true }\nfn never(_: bool) -> { false }\nfn id(b: bool) -> { b }\nfn not(b: bool) -> {\nmatch b {\ntrue -> false,\nfalse -> true,\n}\n}\n우리가 흔히 쓰는 \"boolean 타입\"과 완벽히 대응함을 알 수 있다.","합집합#합집합":"두 집합 A, B가 있을 때, 두 집합의 모든 원소를 가지고 새로운 집합을 만들\n수 있다. 새로운 집합 의 원소는 본래 의 원소이거나 의 원소이다.\n이를 합집합(union)이라 부르고 아래처럼 정의한다:합집합에 대응하는 타입은 합타입(union type 혹은 sum type)이다.\n합타입을 이용하면 타입을 확장할 수 있다.\n아래의 예시에서 Number의 원소는 i64의 원소이거나 f64의 원소이다:\nenum Number {\nInt(i64),\nFloat(f64),\n}\nlet a: Number = Int(3);\nlet b: Number = Float(1.1);\n어떤 언어는 다음처럼 쉽게 합집합을 표현할 수 있도록 한다.\nfunction padLeft(value: string, padding: string | number);\n위의 enum으로 표현한 합타입과 밑의 |로 표현한 합타입은 무슨 차이가 있을까?\n같은 타입을 합쳤을 경우를 살펴보자:\nlet bnb = boolean | boolean;\n|로 같은 타입을 합집합을 만들 경우 본래의 타입과 다를 바가 없다. 같은 집합의\n원소를 모으면 본래의 집합과 동일하다.\nenum BnB {\nB1(bool),\nB2(bool),\n}\n타입 생성자(위의 B1, B2)와 함께 정의한 경우 그냥 합집합이 아니라 서로소\n합집합(disjoint union)이 된다. B1으로 정의하는 bool과 B2로 정의하는\nbool은 서로 다른 타입이다. 값도 동일하지 않다. B1(true)과 B2(true)는\n다른 값이다. 따라서 타입 BnB의 가능한 값은 총 네 가지이다.","교집합#교집합":"합집합이 있으므로 교집합도 있지 않을까?\n는 의 원소이면서 동시에 의 원소인 값들의 집합이다.","곱집합#곱집합":"집합을 합할 수 있으므로 곱할수도 있다. 곱집합(product set)은 두 집합의 원소로\n만들 수 있는 가능한 모든 쌍의 집합으로 정의한다.곱타입은 구조체(struct) 혹은 튜플로 정의할 수 있다. 이를 이용하면\n타입을 조합할 수 있다."}},"/notes/uibox":{"title":"UiBox","data":{"":"","용도#용도":"NAS 서버\nbitwarden 서버","하드웨어#하드웨어":"구분\t이름\t비용\t케이스\tJonsbo N2\t154,627 원\tCPU\ti5-12400\t\t메인보드\tB660I snow dream\t\tRAM\tDDR4 16GB\t\tPSU\tSupernova 650 SFX\t\tHDD1\tWD 14TB\t\tHHD2\t? 2TB","운영체제#운영체제":"Proxmox VE를 호스트로 사용 중.Proxmox VE Admin Guide\nproxmox 기초설정\nnginx로 리버스 프록시\nproxmox 저장장치","참고#참고":"Building a Power Efficient Home Server! - YouTube\n서버포럼 - IT, Server, Nas, Linux, ETC..\n클리앙 : 나스당\n2cpu, 지름이 시작되는 곳!\nhomelabbity"}},"/notes/unix-signal":{"title":"유닉스 신호","data":{"":"유닉스 신호를 사용하는 리눅스, macOS, BSD 계열 OS에 한정한 이야기이다.각각의 프로세스들은 서로와, 그리고 운영체제와 유닉스 신호(unix signal)을\n이용하여 소통한다. CLI에서 프로그램을 쓰다가 Ctrl+C를 눌러 종료할 때에도\n유닉스 신호가 전달된다.아래의 C 프로그램은 SIGINT 신호를 받을 때까지 대기하고, 받으면 종료한다.\n일반적으로는 프로그램이 실행되고 있을 때 Ctrl-C를 눌러 신호를 보낼 수 있다.\n##include <signal.h> // signal function\n##include <stdio.h>  // printf function\n##include <unistd.h> // sleep function\n##include <stdlib.h> // exit function\n\nvoid handle_sigint(int signum) {\nprintf(\"%d: SIGINT catched.\\n\", signum);\nexit(0);\n}\n\nint main() {\nsignal(SIGINT, handle_sigint);\n\nwhile (1) {\nsleep(1);\n}\n\nreturn 0;\n}\n\n$ clang test.c\n$ ./a.out\n^C2: SIGINT catched.\n신호는 기본적으로 프로세스를 인터럽트한다. 위의 C 예시에서 프로세스는\nwhile문을 실행하고 있겠지만, 유닉스 신호를 받는 순간\nvoid handle_sigint(int) 콜백부터 처리한다.","신호-보내기#신호 보내기":"유닉스 신호 전체는 man signal로 볼 수 있다.주로 쓰는 유닉스 신호와 신호 번호(signum), 매핑된 단축키는 아래와 같다.\n번호는 유닉스의 macOS signal 메뉴얼을 참고하였는데, 리눅스의\n그것과 다를 수도 있다.\n신호이름\t번호\t단축키\t설명\t기본동작\tSIGHUP\t1\t없음\t신호 끊김(hang up)\t프로세스 종료\tSIGINT\t2\tCtrl-C\t프로세스 인터럽트\t프로세스 종료\tSIGQUIT\t3\tCtrl-\\\t프로세스 종료\t코어 덤프\tSIGKILL\t9\t없음\t프로세스 강제종료\t코어 덤프\tSIGSTOP\t17\t없음\t프로세스 멈춤 (무시할 수 없음)\t프로세스 멈춤\tSIGTSTP\t18\tCtrl-Z\t프로세스 멈춤 (키보드로 발생)\t프로세스 멈춤\tSIGCONT\t19\t없음\t프로세스 재개\t신호 무시\tSIGCHLD\t20\t없음\t자식 프로세스의 상태가 바뀜\t신호 무시\tSIGUSR1\t30\t없음\t프로세스 재개\t신호 무시\n\n프로세스 종료(terminate): 프로세스의 작동을 멈추고 종료한다.\n프로세스 멈춤(stop): 프로세스를 정지시킨다. SIGCONT로 다시 실행시킬 수\n있다.\n코어 덤프(create core image): 프로세스를 종료(terminate)하고 메모리\n상태를 기록한다. 프로그램이 종료되었을 때 상태를 확인하고 재현할 수 있도록\n하기 위함이다.","sighup#SIGHUP?":"signal hang up의 약어이다. hang up이 전화를 끊다라는 뜻인데,\n전화선으로프로세스를 실행하고 있는 터미널이 종료되면 프로세스에게 SIGHUP 신호가\n전달된다. 기본 동작은 종료이기 때문에 터미널을 종료하면 켜놓았던 프로세스는\n다 종료된다. 이를 막으려면 nohup 명령어를 사용하면 된다.","sigquit과-sigkill의-차이#SIGQUIT과 SIGKILL의 차이":"SIGQUIT은 프로세스에 멈춤 신호를 보내어 자식 프로세스나 메모리를 정리하도록\n한다. 반면 SIGKILL은 강제로 종료해버린다. 그래서 문제가 생긴 프로세스를\n강제 종료할 때에는 아래와 같이 kill -9으로 SIGKILL 신호를 보내어 강제로\n종료한다.\n$ kill -9 [pid]","sigstop과-sigtstp의-차이#SIGSTOP과 SIGTSTP의 차이":"둘 다 프로세스에 멈추라는 신호를 보낸다. SIGTSTP은 주로 tty를 통하여\n키보드로 보내며 (보통 ctrl-z) 프로그램이 무시할 수 있는 반면 SIGSTOP은\nkill등의 명령어와 조합하여 신호를 보내며 무시할 수 없다.프로세스가 멈추면 종료되는 것과는 다르게 일시중지된 상태로 현재 세션에\n남아있는다.\n## <c-z>를 눌러 SIGTSTP 신호 보내기\n$ ruby test.rb\n^Z\nzsh: suspended  ruby test.rb\n\n## `kill` 명령어를 이용하여 SIGSTOP 신호 보내기\n$ ruby test.rb &\n[2] 69330\n$ kill -17 69330\n[2]  + suspended (signal)  ruby test.rb\n\n## 일시 중지된 작업 보기\n$ jobs\n[1]  - suspended  ruby test.rb\n[2]  + suspended (signal)  ruby test.rb\n이렇게 일시 중지된 작업들은 fg 명령어로 포어그라운드에서, bg 명령어로\n백그라운드에서 작업을 재개할 수 있다. 이대로 종료하고 싶다면 kill 명령어로\nSIGINT 등의 신호를 보내면 된다.","프로그래밍-언어에서#프로그래밍 언어에서":"","러스트에서#러스트에서":"러스트에서는 표준 라이브러리만으로는 유닉스 신호를 처리하기 힘들다.\n표준 라이브러리로 std::io::signal이 있었으나, 처리를 위하여 운영체제에 의존한\n런타임 라이브러리가 필요해서 삭제된 것 같다. [CtrlC]와 같은  외부\n라이브러리를 이용하면 처리할 수 있다.https://github.com/rust-lang/rust/pull/17673\n[CtrlC]: https://crates.io/crates/ctrlc","참고#참고":"Signal handling\nsignal(7) - Linux manual page"}},"/notes/web-backend":{"title":"🌍 웹 백엔드","data":{"":"웹\n인터넷\nHTTP\nDNS, 도메인\n\n\n프로그래밍 언어와 웹 프레임워크\nElixir with phoenix\nJavaScript with NextJS\n\n\n버전 컨트롤과 협업\nGit\nGitHub\n\n\n데이터베이스\nRDBMS (PostgreSQL)\nNoSQL 데이터베이스\nN+1 문제, 트랜잭션, 정규화, ACID, ORM, 인덱싱, ...\n\n\nAPI\n상태 관리 (쿠키, 세션, JWT)\n인/허가\nREST, JSON, gRPC, GraphQL, ...\n\n\n테스트\n단위 테스트\n통합 테스트\n종단간 테스트\nCI\n\n\n보안\n단방향 암호화 (해싱)\n양방향 암호화 (대칭, 비대칭)\nSSL/TLS\n\n\n배포\n웹서버 (nginx)\nCI/D\n가상화와 컨테이너\n\n\n기초 CS\n운영체제\n동시성 문제\n프로세스 관리","보안#보안":"","owasp#OWASP":"OWASP Top Ten | OWASP FoundationOWASP(Open Web Application Security Project)는 웹 애플리케이션에 대한 보안을 연구하는 프로젝트이다. 그중 영향력이 큰 10개를 3~4년에 한 번 씩 TOP10으로 발표한다. 번호는 A번호:년도로 붙인다.OWASP Cheat Sheet SeriesOWASP Cheat Sheet에서 각 공격 방법에 대한 소개와 방어법을 간결하게 볼 수 있다.","csrf#CSRF":"Cross Site Request Forgery (CSRF) | OWASP FoundationCross Site Request Forgery attack. 크로스-사이트 요청 변조는 인증된 웹 애플리케이션을 통하여 사용자가 원치 않는 작업을 실행하는 공격이다.","csrf-토큰#CSRF 토큰":"서버는 클라이언트에게 무작위하고 유일한 CSRF 토큰을 발행한다.\n클라이언트는 요청을 보낼 때 CSRF 토큰을 포함하여 요청을 보낸다.\n서버는 클라이언트가 보낸 CSRF 토큰이 유효한지 확인하여 요청이 안전한지 검증한다.\n\n공격자는 유효한 CSRF 토큰을 만들어낼 수 없기 때문에, 공격자가 의도한 요청이 아님을 알 수 있다.대부분의 웹 프레임워크는 아래와 같이 form을 생성할 때 CSRF 토큰 필드를 함께 생성한다:","테스트#테스트":"","원칙#원칙":"빨라야한다 -- 각 테스트는 빨라야하며 가능하면 동시적으로 돌릴 수 있어야\n한다.\n독립되어야한다 -- 적정 수준의 독립성을 유지해야한다. 너무 독립적이면\n유용하지 않고, 독립적이지 못하면 이해와 관리가 어렵다.\nDRY -- 쓸모없는 반복이 없어야 한다.\n반복가능해야한다 -- 같은 코드를 같은 테스트를 돌리면 그 결과도 같아야한다.","종류#종류":"단위 테스트 -- 어플리케이션의 단일 계층의 각 기능을 검증한다.\n통합 테스트 -- 여러 계층이 함께 잘 동작하는지 검증한다.","참고#참고":"Chris McCord, Bruce Tate and José Valim, Programming Phoenix ≥ 1.4.","참고-1#참고":"Backend Developer Roadmap\n코드 리뷰는 스포츠다 - 재그지그의 개발 블로그"}},"/notes/zsh":{"title":"zsh","data":{"":"","이상한-괄호쌍#이상한 괄호쌍":"쉘을 쓰다 보면 너무나도 다양한 괄호쌍이 나온다. 헷갈려서 정리했다.대괄호, 중괄호, 소괄호를 영어로는 각각 brackets, curly braces, parenthese라고\n한다.\n단일 대괄호([ ]): 조건 표현문. POSIX 표준\n이중 대괄호([[ ]]): [의 개선판.\n중괄호({ }): 중괄호 확장문(brace expansion)\n단일 소괄호(( )): 배열 표현.\n이중 소괄호((( ))): 산술 표현문.\n산술 확장문($[ ]): 더 이상 쓰지 않는다.\n변수 확장문(${ })\n명령어 대치문($( )): 명령어를 실행하고 그 결과로 값을 대치한다.\n산술 확장문($(( )))\n\nhttps://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.htmlhttps://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.htmlhttps://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html","대괄호#대괄호":"[ ](단일 대괄호, single bracket), [[ ]](이중 대괄호, double bracket)\n모두 조건 검사에 쓴다.[ ]는 조건 검사 명령어이다. 보통 /bin/[에 위치하며 /bin/test와 동치이다.\nPOSIX 호환 문법이다.https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html[[ ]]는 확장 문법이다. korn, bash, zsh 등의 쉘에서 폭넓게 사용한다. 해당 쉘을\n쓴다면 [[ ]]만 알아도 충분하다.자세한 사용법은 Bash Conditional Expressions 참고.$[ ](산술 대치문, arithmetic expansion)은 $(( ))로 대치되어 현재는 쓰지\n않는다.https://wiki.bash-hackers.org/scripting/obsolete","중괄호#중괄호":"{ }(중괄호, braces, curly braces)는 문자열의 리스트를 만들 때 쓴다.아래의 두 명령어는 똑같다. { }를 이용하여 간편하게 줄여 쓸 수 있다.\n$ mv -i lib/user/{accont,account}.ex\n$ mv -i lib/user/accont.ex lib/user/account.ex\n아래와 같이 범위를 지정할 수도 있다. 이는 문자열도 가능하다.\n$ mkdir test_dir_{00..99..2}\n$ touch {가..힣} # 왜 이런 짓을...?\n${ }(변수 확장문, parameter expansion)을 쓰면 변수를 결과값으로\n대치(substitute)할 뿐 아니라, 여러가지 옵션으로 확장할 수 있다.변수와 뒤에 오는 문자열을 구분해야 할 경우 $var 대신 쓸 수 있다.\n$ DIR_PREFIX=hello\n$ echo $DIR_PREFIX_world\n##\n$ echo ${DIR_PREFIX}_world\n## hello_world\n옵션으로 확장하면 다양한 기능을 함께 쓸 수 있다. ${var=str} 문법은 var\n변수가 정의되어 있으면 그걸 쓰고, 정의되어 있지 않다면 var에 str을 대입하고\nstr 값을 결과로 쓴다. 아래의 코드는 $EDITOR 변수가 정의되어 있으면 해당\n편집기로 config 파일을 열고, 아니라면 vim으로 여는 명령어이다.\n$ ${EDITOR=vim} config\n그 외의 옵션은 Shell parameter Expansion 참고.","소괄호#소괄호":"( )(단일 소괄호, single parentheses)는 배열을 만들 때 쓴다.\n$ array=(1 2 3)\n$ $array\n## 1 2 3\n(( ))(이중 소괄호, double parentheses)는 산술 연산에 쓴다.\n$ i=10\n$ i+=10\n## i = 1010\n\n$ i=10\n$ ((i += 10))\n## i = 20\n$(( ))(산술 확장문, arithmetic expansion)은 산술 계산 후 결과값으로\n대치된다.\n$ echo ((i += 10))\n## zsh: no maches found: ((i += 10))\n$ echo $((i += 10))\n## 30","팁#팁":"","특정-명령어가-있는지-확인하기#특정 명령어가 있는지 확인하기":"(( $+commands[foobar] )) 쓰면 된다.Speed Test: Check the Existence of a Command in Bash and Zsh\ntype foobar &> /dev/null\nhash foobar &> /dev/null\ncommand -v foobar &> /dev/null\nwhich foobar &> /dev/null\n(( $+commands[foobar] ))\n\n아래와 같이 쓸 수 있다.\nexport EDITOR=vi\n\nif (( $+commands[vim] )); then\nexport EDITOR=vim\nfi\n\nif (( $+commands[helix] )); then\nexport EDITOR=helix\nalias hx='helix'\nfi"}},"/notes/programming-languages":{"title":"프로그래밍 언어","data":{"":"엘릭서\nidris\n스칼라","알아야-하는-것들#알아야 하는 것들":"기본 도구와 생태계\n버전 관리자\n의존성 (VM 혹은 라이브러리)\nIDE, LSP, REPL\n\n\n타이핑 모델\n강타입인가 약타입인가?\n동적인가 정적인가?\n명목적(nominal)인가 구조적(structural)인가?\n\n\n프로그래밍 패러다임\n함수형, 객체지향, 스택 기반, 배열 기반 등등등\n혹은 이 언어만의 특별한 점\n\n\n수를 다루는 방법\n산술연산\n논리연산\n\n\n자료구조\n리스트 등 내장 컨테이너\n합타입, 곱타입\n\n\n제어구조\n논리제어, 반복제어, 패턴매칭 등\n\n\n문자열을 다루는 방법\n함수\n익명함수, 클로저\n\n\n모듈과 파일 관리\n문서화\n예외를 처리하는 방법\n다형성을 달성하는 방법\nThe Four Polymorphisms in C++\n다형성이란 무엇인가\n파라메트릭 다형성, ad hoc 다형성\n트레잇, 제네릭\n\n\n동시성을 달성하는 방법\n런타임에서 제공하는 기능들\n커뮤니티에서 권장하는 것들\n스타일 가이드\n커뮤니티 라이브러리","런타임#런타임":"C언어의 런타임은 The C Runtime Initialization 참고.러스트는 최소한의 런타임만 구현되어 있으며 필요에 따라 라이브러리 런타임을 사용한다.\ntokio — asynchronous rust runtime\nactix — actor framework for rust\n\nrfcs/0230을 보면 예전에는 librustrt라는 이름의 런타임이 있었으나 현재는 완전 삭제되었다.","참고#참고":"니시오 히로카츠, 코딩을 지탱하는 기술.\n이광근, 컴퓨터과학이 여는 세계.\n지민규, 9가지 프로그래밍 언어로 배우는 개념: 1편 - 타입 이론.\n탐정토끼, 합성으로 연결되는 함수형과 객체지향."}}}