#!/usr/bin/env elixir
# Preprocess markdown files.

defmodule Markdown do
  def preprocess(path) do
    stream = File.stream!(path)

    stream
    |> validate_frontmatter()
  end

  defp validate_frontmatter(stream) do
    stream
    |> find_frontmatter
  end

  @spec find_frontmatter(File.Stream) ::
          {:ok, Markdown.Frontmatter} | {:error, :not_found} | {:error, :single_divider}
  defp find_frontmatter(stream) do
    reducer = fn
      "---\n", {1, frontmatter} -> {:halt, {:found, frontmatter}}
      "---\n", {0, []} -> {:cont, {1, []}}
      line, {1, frontmatter} -> {:cont, {1, [line | frontmatter]}}
      _line, {0, []} -> {:cont, {0, []}}
    end

    # acc = {num_of_divider, content_of_frontmatter}
    find_result = Enum.reduce_while(stream, {0, []}, reducer)

    case find_result do
      {:found, frontmatter} -> {:ok, Markdown.Frontmatter.new(frontmatter)}
      {0, []} -> {:error, :not_found}
      {1, _} -> {:error, :single_divider}
    end
  end
end

defmodule Markdown.Frontmatter do
  defstruct [:title, :tags]

  @type t :: %__MODULE__{
          title: String.t(),
          tags: [String.t()]
        }

  @spec new([String.t()]) :: %__MODULE__{}
  def new(ls) do
    opts =
      Enum.reduce(ls, [], fn line, acc ->
        [attr_name, attr] = line |> String.trim_trailing() |> String.split(": ")

        case attr_name do
          "title" -> [{:title, attr} | acc]
          "tags" -> [{:tags, attr} | acc]
          _ -> acc
        end
      end)

    struct(Markdown.Frontmatter, opts)
  end
end

Path.wildcard("notes/**/*.md")
|> Enum.map(&Markdown.preprocess/1)
